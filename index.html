<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trader Survivor - Trading Journal Profesional V2</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- Incluir Dexie.js -->
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>
    <!-- Incluir CryptoJS para firmas HMAC -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Incluir Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <!-- Supabase CDN -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        /* Paleta de colores: Negro, Verde Fluorescente y Blanco */
        :root {
            --primary: #39ff14;       /* Verde Fluorescente */
            --secondary: #28e000;     /* Verde Fluorescente más oscuro para hover */
            --background: #0a0a0a;     /* Negro Oscuro */
            --surface: #141414;       /* Negro ligeramente más claro para tarjetas */
            --surface-light: #2a2a2a; /* Gris muy oscuro para bordes e inactivos */
            --text: #ffffff;           /* Blanco Puro */
            --text-secondary: #a0a0a0; /* Gris claro para texto secundario */
            --red: #ff4136;            /* Rojo brillante para pérdidas */
            --green: #39ff14;          /* Verde Fluorescente para ganancias */
            --yellow: #f59e0b;         /* Amarillo para métricas neutrales */
            --success: #10b981;        /* Verde para métricas positivas */
            --danger: #ef4444;         /* Rojo para métricas negativas */
            --warning: #eab308;        /* Amarillo para métricas de alerta */
            --accent: #3b82f6;         /* Azul para métricas especiales */
            --border: #2a2a2a;         /* Color de bordes */
        }
        
        /* Clases de utilidad para colores dinámicos en JS */
        .text-positive { color: var(--green); }
        .text-negative { color: var(--red); }
        .text-neutral { color: var(--text-secondary); }
        .text-success { color: var(--success); }
        .text-danger { color: var(--danger); }
        .text-warning { color: var(--warning); }
        .text-accent { color: var(--accent); }
        .text-primary { color: var(--primary); }
        
        .bg-success { background-color: var(--success); }
        .bg-danger { background-color: var(--danger); }
        .bg-warning { background-color: var(--warning); }
        .bg-accent { background-color: var(--accent); }
        .bg-primary { background-color: var(--primary); }
        .bg-surface { background-color: var(--surface); }
        
        .border-border { border-color: var(--border); }

        /* Logo Trader Survivor - Escudo con efectos */
        .logo-shield {
            position: relative;
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 8px rgba(57, 255, 20, 0.2));
            font-size: 1.5em;
            color: var(--primary) !important;
        }
        
        .logo-shield:hover {
            transform: scale(1.1);
            text-shadow: 0 0 15px rgba(57, 255, 20, 0.8);
            filter: drop-shadow(0 0 15px rgba(57, 255, 20, 0.6));
        }
        
        /* Logo simple - Solo el escudo */
        .logo-container {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        /* Estilo base del cuerpo */
        body {
            font-family: 'Segoe UI', 'Roboto', system-ui, -apple-system, sans-serif;
            background-color: var(--background);
            color: var(--text);
            margin: 0;
            padding: 0;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        /* Pestañas de navegación */
        .nav-tabs {
            border-bottom: 1px solid var(--surface-light);
        }
        .nav-tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            white-space: nowrap;
        }
        .nav-tab.active {
            color: var(--text);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        .nav-tab:hover:not(.active) {
            color: var(--text);
            border-bottom-color: var(--surface-light);
        }

        /* Contenedor de sección */
        .section-container {
            display: none;
            padding: 1.5rem 0;
            margin-bottom: 2rem;
        }
        .section-container.active { display: block; }

        /* Tarjetas de métricas */
        .metric-card {
            background-color: var(--surface);
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid var(--surface-light);
            transition: all 0.2s ease-in-out;
        }
        .metric-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.05);
        }

        /* Tarjetas de Cuentas */
        .account-card {
            background-color: var(--surface);
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid var(--surface-light);
            transition: all 0.2s ease-in-out;
        }
        .account-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);
            transform: translateY(-2px);
        }
        .account-card.selected {
            border-color: var(--primary);
            box-shadow: 0 0 25px rgba(57, 255, 20, 0.15);
        }
        
        /* Calendario */
        .calendar-day {
            width: 100%; aspect-ratio: 1 / 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 0.25rem; cursor: pointer; transition: all 0.2s ease; position: relative;
            background-color: var(--surface); border: 1px solid var(--surface-light);
        }
        .calendar-day.empty { background-color: transparent; border-color: var(--background); cursor: default; }
        .calendar-day.empty:hover { transform: none; }
        .calendar-day.profit { background-color: rgba(57, 255, 20, 0.05); border-color: var(--green); }
        .calendar-day.loss { background-color: rgba(255, 65, 54, 0.05); border-color: var(--red); }
        .calendar-day:not(.empty):hover { transform: scale(1.05); z-index: 10; border-color: var(--primary); }
        .day-number { font-size: 1.2rem; font-weight: 600; }
        .day-profit.positive { color: var(--green); }
        .day-profit.negative { color: var(--red); }
        .day-trades { font-size: 0.7rem; color: var(--text-secondary); }
        
        /* Selección manual de días y semanas */
        .calendar-day.selected { 
            border: 2px solid var(--primary) !important; 
            background-color: rgba(59, 130, 246, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .calendar-day.selected::after {
            content: '✓';
            position: absolute;
            top: 2px;
            right: 2px;
            color: var(--primary);
            font-size: 12px;
            font-weight: bold;
        }
        .week-summary.selected {
            border: 2px solid var(--primary) !important;
            background-color: rgba(59, 130, 246, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .calendar-selection-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 16px;
        }
        .selection-mode-btn {
            padding: 6px 12px;
            background: var(--surface);
            border: 1px solid var(--surface-light);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .selection-mode-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .selection-mode-btn:hover:not(.active) {
            background: var(--surface-light);
        }

        /* Botones */
        button {
            background-color: var(--surface-light); color: var(--text); border: 1px solid var(--surface-light);
            border-radius: 0.25rem; padding: 0.6rem 1.2rem; cursor: pointer; transition: all 0.2s ease; font-weight: 500;
        }
        button:hover { background-color: var(--primary); border-color: var(--primary); color: var(--background); font-weight: bold; }
        button.primary { background-color: var(--primary); border-color: var(--primary); color: var(--background); font-weight: bold; }
        button.primary:hover { background-color: var(--secondary); border-color: var(--secondary); }
        button.secondary { background-color: var(--surface); border-color: var(--surface-light); color: var(--text); font-weight: 500; }
        button.secondary:hover { background-color: var(--surface-light); border-color: var(--primary); color: var(--primary); }
        button.warning { background-color: #f59e0b; border-color: #f59e0b; color: white; font-weight: 500; }
        button.warning:hover { background-color: #d97706; border-color: #d97706; }
        button.success { background-color: var(--green); border-color: var(--green); color: var(--background); font-weight: bold; }
        button.danger { background-color: var(--red); border-color: var(--red); }
        #operations-table td button, #accounts-container button, #finances-table-body td button {
            padding: 0.3rem 0.6rem; font-size: 0.875rem; background-color: transparent; border: none;
        }
        #operations-table td button:hover, #accounts-container button:hover, #finances-table-body td button:hover {
            opacity: 0.8; color: var(--primary);
        }

        /* Formularios */
        input, select, textarea {
            background-color: var(--surface); color: var(--text); border: 1px solid var(--surface-light);
            border-radius: 0.25rem; padding: 0.6rem; width: 100%; transition: border-color 0.2s ease;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        input[type="file"]::file-selector-button {
            background-color: var(--primary); color: var(--background); border: none; padding: 0.5rem 1rem;
            border-radius: 0.25rem; cursor: pointer; transition: background-color 0.3s ease; margin-right: 0.8rem; font-weight: bold;
        }
        input[type="file"]::file-selector-button:hover { background-color: var(--secondary); }

        /* Tablas */
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        th {
            text-align: left; padding: 0.8rem 1rem; background-color: transparent;
            font-weight: 600; color: var(--text-secondary); text-transform: uppercase; font-size: 0.75rem;
            letter-spacing: 0.05em; border-bottom: 1px solid var(--surface-light);
        }
        td {
            padding: 0.8rem 1rem; border-bottom: 1px solid var(--surface);
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle;
        }
        tr:hover td { background-color: rgba(57, 255, 20, 0.03); }
        #operations-table tr.cursor-pointer:hover td { background-color: rgba(57, 255, 20, 0.08); }
        #best-trades tr.cursor-pointer:hover td, #worst-trades tr.cursor-pointer:hover td, #day-modal-table-body tr.cursor-pointer:hover td {
             background-color: rgba(57, 255, 20, 0.08);
        }
        /* Tablas clicables en Analytics */
        #analytics-monthly-performance tr, #analytics-daily-performance tr {
            cursor: pointer;
        }
        #analytics-monthly-performance tr:hover td, #analytics-daily-performance tr:hover td {
            background-color: rgba(57, 255, 20, 0.08);
        }

        /* --- NUEVO: Estilo para cabeceras de tabla ordenables --- */
        #operations-table-render th[data-sort] {
            cursor: pointer;
            position: relative;
        }
        #operations-table-render th[data-sort]:hover {
            color: var(--text);
        }
        #operations-table-render th[data-sort].sorted::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
        }
        #operations-table-render th[data-sort].sorted.asc::after {
            border-bottom-color: var(--primary);
            margin-top: -2px;
        }
        #operations-table-render th[data-sort].sorted.desc::after {
            border-top-color: var(--primary);
            margin-top: 2px;
        }

        /* --- Optimización de tabla de operaciones --- */
        #operations-table-render {
            font-size: 0.875rem; /* Reducir tamaño de fuente ligeramente */
            table-layout: fixed; /* Layout fijo para mejor control de anchos */
            width: 100%;
        }
        #operations-table-render th,
        #operations-table-render td {
            padding: 0.5rem 0.25rem; /* Reducir padding para más espacio */
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Anchos específicos para cada columna */
        #operations-table-render th:nth-child(1) { width: 8%; } /* Fecha */
        #operations-table-render th:nth-child(2) { width: 6%; } /* Entrada */
        #operations-table-render th:nth-child(3) { width: 6%; } /* Salida */
        #operations-table-render th:nth-child(4) { width: 10%; } /* Cuenta */
        #operations-table-render th:nth-child(5) { width: 12%; } /* Instrumento */
        #operations-table-render th:nth-child(6) { width: 6%; } /* Tipo */
        #operations-table-render th:nth-child(7) { width: 8%; } /* Entrada */
        #operations-table-render th:nth-child(8) { width: 8%; } /* Salida */
        #operations-table-render th:nth-child(9) { width: 6%; } /* Volumen */
        #operations-table-render th:nth-child(10) { width: 7%; } /* Resultado */
        #operations-table-render th:nth-child(11) { width: 8%; } /* P&L */
        #operations-table-render th:nth-child(12) { width: 6%; } /* Fees */
        #operations-table-render th:nth-child(13) { width: 5%; } /* Divisa */
        #operations-table-render th:nth-child(14) { width: 6%; } /* Sesión */
        #operations-table-render th:nth-child(15) { width: 8%; } /* Acciones */

        /* --- ESTILOS PARA PLATAFORMAS --- */
        .platform-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .platform-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .platform-card .metric-card {
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .platform-card:hover .metric-card {
            border-color: var(--primary);
        }
        .platform-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .platform-card.disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* Quick Sync Button */
        #bingx-quick-sync {
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #bingx-quick-sync:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        #bingx-quick-sync:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        #bingx-quick-sync i {
            transition: transform 0.3s ease;
        }
        #bingx-quick-sync:hover i {
            transform: rotate(180deg);
        }

        /* MEXC Quick Sync Button Animation */
        #mexc-quick-sync {
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #mexc-quick-sync:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        #mexc-quick-sync:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        #mexc-quick-sync i {
            transition: transform 0.3s ease;
        }
        #mexc-quick-sync:hover i {
            transform: rotate(180deg);
        }

        /* Currency Switch */
        .currency-switch { display: inline-flex; overflow: hidden; border-radius: 0.25rem; background-color: var(--surface); border: 1px solid var(--surface-light); }
        .currency-switch label { padding: 0.5rem 1rem; cursor: pointer; transition: all 0.2s ease; color: var(--text-secondary); font-size: 0.875rem; }
        .currency-switch input[type="radio"] { display: none; }
        .currency-switch input[type="radio"]:checked + label { background-color: var(--primary); color: var(--background); font-weight: 600; }
        .currency-switch label:hover:not(.active) { background-color: var(--surface-light); }
        
        /* Gráficos */
        .chart-container { position: relative; height: 320px; margin-bottom: 1rem; }

        /* Loading Spinner */
        .loading { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(10, 10, 10, 0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .spinner { border: 4px solid var(--surface-light); border-radius: 50%; border-top: 4px solid var(--primary); width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Animaciones para notificaciones */
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Modals */
        .image-modal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.95); align-items: center; justify-content: center; }
        .image-modal-content { max-width: 90%; max-height: 90%; border-radius: 5px; }
        .image-modal-close { position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; cursor: pointer; }
        
        #day-detail-modal { background-color: rgba(0,0,0,0.8); }
        #day-detail-modal > div { background-color: var(--surface); border: 1px solid var(--surface-light); }
        
        /* --- NUEVO: Estilo para el modal de detalles de Analytics --- */
        #analytics-detail-modal {
            display: none; /* Oculto por defecto */
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.9);
            z-index: 1002;
            padding: 2rem;
            overflow-y: auto;
        }
        .analytics-detail-container {
            background-color: var(--background);
            border: 1px solid var(--surface-light);
            border-radius: 0.5rem;
            max-width: 1400px;
            margin: 2rem auto;
            padding: 2rem;
        }

        
        /* --- AUTHENTICATION MODAL STYLES --- */
        .auth-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1050;
            align-items: center;
            justify-content: center;
        }
        
        .auth-modal {
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            border-radius: 0.75rem;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            margin: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        .auth-tabs {
            display: flex;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--surface-light);
        }
        
        .auth-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            text-align: center;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .auth-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }
        
        .auth-tab:hover:not(.active) {
            color: var(--text);
        }
        
        .auth-form {
            display: none;
        }
        
        .auth-form.active {
            display: block;
        }
        
        .auth-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: var(--background);
            border: 1px solid var(--surface-light);
            border-radius: 0.5rem;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
        }
        
        .auth-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(57, 255, 20, 0.1);
        }
        
        .auth-input::placeholder {
            color: var(--text-secondary);
        }
        
        .auth-button {
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: var(--primary);
            color: var(--background);
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
        }
        
        .auth-button:hover {
            background-color: var(--secondary);
        }
        
        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .auth-error {
            background-color: rgba(255, 65, 54, 0.1);
            border: 1px solid var(--red);
            color: var(--red);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }
        
        .auth-success {
            background-color: rgba(57, 255, 20, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--text);
            font-size: 0.875rem;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--primary);
            color: var(--background);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .logout-button {
            padding: 0.5rem 1rem;
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            color: var(--text);
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }
        
        .logout-button:hover {
            background-color: var(--surface-light);
            border-color: var(--primary);
        }
        
        .app-hidden {
            display: none !important;
        }
        /* --- END: AUTHENTICATION STYLES --- */
        
        /* --- OPERATIONS METRICS STYLES --- */
        .circular-chart {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        
        .circular-chart .circle {
            transition: stroke-dasharray 0.5s ease;
            transform: rotate(-90deg);
            transform-origin: center;
        }
        
        .circular-chart .percentage {
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
        }
        /* --- END: OPERATIONS METRICS STYLES --- */
    </style>
</head>
<body>
    <!-- Authentication Modal -->
    <div id="authModal" class="auth-overlay">
        <div class="auth-modal">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-white flex items-center justify-center">
                    <span class="logo-container mr-3">
                        <i class="fas fa-shield-alt logo-shield"></i>
                    </span>
                    Trader Survivor
                </h2>
                <p class="text-text-secondary mt-2">Accede a tu trading journal profesional</p>
            </div>
            
            <div class="auth-tabs">
                <div class="auth-tab active" data-tab="login">
                    <i class="fas fa-sign-in-alt mr-2"></i>
                    Iniciar Sesión
                </div>
                <div class="auth-tab" data-tab="register">
                    <i class="fas fa-user-plus mr-2"></i>
                    Registrarse
                </div>
            </div>

            <!-- Login Form -->
            <form id="loginForm" class="auth-form active">
                <div id="authMessage" class="auth-error" style="display: none;"></div>
                
                <input
                    type="email"
                    id="loginEmail"
                    class="auth-input"
                    placeholder="Email"
                    required
                />
                
                <input
                    type="password"
                    id="loginPassword"
                    class="auth-input"
                    placeholder="Contraseña"
                    required
                />
                
                <button type="submit" class="auth-button">
                    <i class="fas fa-sign-in-alt mr-2"></i>
                    Iniciar Sesión
                </button>
            </form>

            <!-- Register Form -->
            <form id="registerForm" class="auth-form">
                <input
                    type="email"
                    id="registerEmail"
                    class="auth-input"
                    placeholder="Email"
                    required
                />
                
                <input
                    type="password"
                    id="registerPassword"
                    class="auth-input"
                    placeholder="Contraseña (mínimo 6 caracteres)"
                    minlength="6"
                    required
                />
                
                <input
                    type="password"
                    id="confirmPassword"
                    class="auth-input"
                    placeholder="Confirmar Contraseña"
                    minlength="6"
                    required
                />
                
                <button type="submit" class="auth-button">
                    <i class="fas fa-user-plus mr-2"></i>
                    Crear Cuenta
                </button>
            </form>
        </div>
    </div>
    
    <div class="app-container app-hidden" id="mainApp">
        <header class="flex flex-wrap justify-between items-center mb-6 gap-4">
            <h1 class="text-3xl font-bold flex items-center text-white">
                <span class="logo-container mr-4">
                    <i class="fas fa-shield-alt logo-shield"></i>
                </span>
                Trader Survivor
            </h1>

            <div class="currency-switch">
                <input type="radio" id="usd" name="currency" value="USD" checked>
                <label for="usd">USD</label>
                <input type="radio" id="eur" name="currency" value="EUR">
                <label for="eur">EUR</label>
                <input type="radio" id="percentage" name="currency" value="%">
                <label for="percentage">%</label>
            </div>
            
            <!-- User Info -->
            <div id="userInfo" class="user-info" style="display: none;">
                <div class="user-avatar" id="userAvatar">U</div>
                <span id="userEmail" class="text-sm">usuario@ejemplo.com</span>
                <button id="logoutBtn" class="logout-button">
                    <i class="fas fa-sign-out-alt mr-1"></i>
                    Cerrar Sesión
                </button>
            </div>
        </header>

        <nav class="mb-6 overflow-x-auto">
            <div class="nav-tabs flex">
                <div class="nav-tab active" data-target="dashboard">Dashboard</div>
                <div class="nav-tab" data-target="analytics">Analytics</div>
                <div class="nav-tab" data-target="calendar">Calendario</div>
                <div class="nav-tab" data-target="operations">Operaciones</div>
                <div class="nav-tab" data-target="accounts">Cuentas</div>
                <div class="nav-tab" data-target="finances">Finanzas</div>
                <div class="nav-tab" data-target="platforms">Plataformas</div>
                <div class="nav-tab" data-target="news">Noticias</div>
                <div class="nav-tab" data-target="config">Configuración</div>
            </div>
        </nav>

        <section id="dashboard" class="section-container active">
            <div id="account-selector" class="mb-6 flex flex-wrap justify-between items-center gap-4">
                <div class="flex items-center space-x-2">
                    <div class="flex items-center gap-3">
                        <div id="dashboard-account-logo" class="w-8 h-8 rounded-lg flex items-center justify-center" style="display: none;">
                            <img id="dashboard-account-logo-img" src="" alt="" class="w-6 h-6 object-contain">
                        </div>
                        <select id="dashboard-account-select" class="w-64">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    <button id="dashboard-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                        <i class="fas fa-calendar-alt"></i>
                    </button>
                    <div id="dashboard-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">P/L Neto</h3>
                    <p id="current-balance" class="text-3xl font-bold text-green">$0.00</p>
                </div>

                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Win Rate</h3>
                    <p id="win-rate" class="text-3xl font-bold text-green">0%</p>
                </div>

                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Profit Factor</h3>
                    <p id="profit-factor" class="text-3xl font-bold text-yellow">0.00</p>
                </div>

                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Operaciones</h3>
                    <p id="total-trades" class="text-3xl font-bold text-white">0</p>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                <div class="metric-card lg:col-span-2">
                    <h3 class="text-lg font-semibold mb-2">Evolución de la Cuenta</h3>
                    <div class="time-range-buttons mb-3 text-sm">
                        <button data-range="1W" class="time-range-btn">1S</button>
                        <button data-range="1M" class="time-range-btn">1M</button>
                        <button data-range="3M" class="time-range-btn">3M</button>
                        <button data-range="6M" class="time-range-btn">6M</button>
                        <button data-range="1Y" class="time-range-btn">1A</button>
                        <button data-range="ALL" class="time-range-btn active">Todo</button>
                    </div>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="account-evolution-chart"></canvas>
                    </div>
                </div>

                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Puntuación de Rendimiento</h3>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="dashboard-radar-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-8">
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Total Ganado</h3>
                    <p id="dashboard-total-win" class="text-2xl font-bold text-green">$0.00</p>
                </div>
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Total Perdido</h3>
                    <p id="dashboard-total-loss" class="text-2xl font-bold text-red">$0.00</p>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 my-8">
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Retorno Prom. / Ganador</h3>
                    <p id="dashboard-avg-win" class="text-2xl font-bold text-green">$0.00</p>
                </div>
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">Retorno Prom. / Perdedor</h3>
                    <p id="dashboard-avg-loss" class="text-2xl font-bold text-red">$0.00</p>
                </div>
                <div class="metric-card">
                    <h3 class="text-sm font-medium text-text-secondary mb-1">P/L Promedio / Trade</h3>
                    <p id="dashboard-avg-pl" class="text-2xl font-bold text-white">$0.00</p>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Rendimiento por Instrumento</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="instrument-performance-chart"></canvas>
                    </div>
                </div>

                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Rendimiento por Día de la Semana</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="day-performance-chart"></canvas>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 gap-6 mt-8">
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Rendimiento por Tipo de Operación (Long/Short)</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="type-performance-chart"></canvas>
                    </div>
                </div>
            </div>

        </section>

        <section id="analytics" class="section-container">
            <h2 class="text-xl font-semibold mb-6">Análisis Detallado</h2>
            <div class="mb-6">
                <div class="flex items-center space-x-2">
                    <div class="flex items-center gap-3">
                        <div id="analytics-account-logo" class="w-8 h-8 rounded-lg flex items-center justify-center" style="display: none;">
                            <img id="analytics-account-logo-img" src="" alt="" class="w-6 h-6 object-contain">
                        </div>
                        <select id="analytics-account-select" class="w-64">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    <button id="analytics-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                        <i class="fas fa-calendar-alt"></i>
                    </button>
                </div>
                <div id="analytics-date-filter-display" class="date-filter-display-text text-sm text-text-secondary mt-1">Sin filtro de fecha</div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-8">
                 <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">P/L Neto Total</h3><p id="analytics-total-pl" class="text-2xl font-bold text-green">$0.00</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Win Rate</h3><p id="analytics-win-rate" class="text-2xl font-bold text-green">0%</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Profit Factor</h3><p id="analytics-profit-factor" class="text-2xl font-bold text-yellow">0.00</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Total Trades</h3><p id="analytics-total-trades" class="text-2xl font-bold text-white">0</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Comisiones Totales</h3><p id="analytics-total-fees" class="text-2xl font-bold text-red">$0.00</p></div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Métricas Clave</h3><dl class="space-y-2 text-sm">
                    <div class="flex justify-between"><dt>Ganancia Promedio:</dt><dd id="analytics-avg-win" class="font-semibold text-green">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Pérdida Promedio:</dt><dd id="analytics-avg-loss" class="font-semibold text-red">$0.00</dd></div>
                    <div class="flex justify-between"><dt>P/L Promedio / Trade:</dt><dd id="analytics-avg-pl-trade" class="font-semibold text-white">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Comisión Promedio:</dt><dd id="analytics-avg-fee" class="font-semibold text-yellow">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Expectativa:</dt><dd id="analytics-expectancy" class="font-semibold text-white">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Mayor Ganancia:</dt><dd id="analytics-largest-win" class="font-semibold text-green">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Mayor Pérdida:</dt><dd id="analytics-largest-loss" class="font-semibold text-red">$0.00</dd></div></dl>
                </div>
                 <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Rachas y Costos</h3><dl class="space-y-2 text-sm"><div class="flex justify-between"><dt>Racha Ganadora Máx.:</dt><dd id="analytics-longest-win-streak" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Racha Perdedora Máx.:</dt><dd id="analytics-longest-loss-streak" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Ganadores:</dt><dd id="analytics-total-wins-count" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Perdedores:</dt><dd id="analytics-total-losses-count" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Breakeven:</dt><dd id="analytics-total-breakeven-count" class="font-semibold">0</dd></div><div class="flex justify-between border-t border-surface-light pt-2 mt-2"><dt class="font-bold">Comisiones Totales:</dt><dd id="analytics-fees-total" class="font-bold text-red">$0.00</dd></div><div class="flex justify-between"><dt>P/L Neto (después fees):</dt><dd id="analytics-net-pl-after-fees" class="font-bold text-green">$0.00</dd></div></dl></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Métricas de Riesgo y Consistencia</h3><dl class="space-y-2 text-sm">
                    <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="analytics-max-drawdown" class="font-semibold text-red">$0.00 (0%)</dd></div>
                    <div class="flex justify-between"><dt>Ratio Ganancia/Pérdida Prom:</dt><dd id="analytics-avg-wl-ratio" class="font-semibold">0.00</dd></div>
                    <div class="flex justify-between"><dt>Tiempo Prom. por Operación:</dt><dd id="analytics-avg-hold-time" class="font-semibold">N/A</dd></div>
                    <div class="flex justify-between"><dt>Desv. Estándar del P/L:</dt><dd id="analytics-std-dev-pl" class="font-semibold">$0.00</dd></div>
                </dl></div>
            </div>

             <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Mes (Clic para detalles)</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Mes</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-monthly-performance"></tbody></table></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Día de la Semana (Clic para detalles)</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Día</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-daily-performance"></tbody></table></div></div>
            </div>

             <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Instrumento (Top 10)</h3><div class="chart-container" style="height: 280px;"><canvas id="analytics-instrument-performance-chart"></canvas></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Hora del Día (Entrada)</h3><div class="chart-container" style="height: 280px;"><canvas id="analytics-hourly-performance-chart"></canvas></div></div>
            </div>
        </section>

        <section id="calendar" class="section-container">
            <div class="flex flex-wrap justify-between items-center mb-6 gap-4">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center gap-3">
                        <div id="calendar-account-logo" class="w-8 h-8 rounded-lg flex items-center justify-center" style="display: none;">
                            <img id="calendar-account-logo-img" src="" alt="" class="w-6 h-6 object-contain">
                        </div>
                        <select id="calendar-account-select" class="w-48"><option value="all">Todas las cuentas</option></select>
                    </div>
                     <div class="currency-switch"><input type="radio" id="cal-usd" name="cal-currency" value="USD" checked><label for="cal-usd">USD</label><input type="radio" id="cal-eur" name="cal-currency" value="EUR"><label for="cal-eur">EUR</label><input type="radio" id="cal-percentage" name="cal-currency" value="%"><label for="cal-percentage">%</label></div>
                </div>
                <div class="flex items-center"><button id="prev-month" class="mr-2 px-3 py-2"><i class="fas fa-chevron-left"></i></button><h2 id="current-month" class="text-xl font-semibold mx-4 w-40 text-center">Abril 2025</h2><button id="next-month" class="ml-2 px-3 py-2"><i class="fas fa-chevron-right"></i></button></div>
            </div>
            <div class="grid grid-cols-8 gap-2 text-center font-bold p-2 mb-2 text-text-secondary"><div>Dom</div><div>Lun</div><div>Mar</div><div>Mié</div><div>Jue</div><div>Vie</div><div>Sáb</div><div>Semana</div></div>
            <div id="calendar-grid" class="grid grid-cols-8 gap-2"></div>
            <div class="mt-8"><h3 class="text-xl font-semibold mb-4">Resumen Mensual</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">P&L Mensual</h4><p id="monthly-pl" class="text-2xl font-bold text-green">$0.00</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Operados</h4><p id="monthly-trading-days" class="text-2xl font-bold text-white">0</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Ganadores</h4><p id="monthly-winning-days" class="text-2xl font-bold text-green">0</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Perdedores</h4><p id="monthly-losing-days" class="text-2xl font-bold text-red">0</p></div></div></div>
            <div class="mt-8"><h3 class="text-xl font-semibold mb-4">Tendencia Semanal</h3><div class="chart-container"><canvas id="weekly-trend-chart"></canvas></div></div>
        </section>

        <section id="operations" class="section-container">
            <div class="flex flex-wrap justify-between items-center mb-6"><h2 class="text-xl font-semibold">Registro de Operaciones</h2><button id="add-operation-btn" class="primary"><i class="fas fa-plus mr-2"></i>Añadir Operación</button></div>
            
            <!-- Métricas de Performance -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <!-- Net Cumulative P&L Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1">Net Cumulative P&L</p>
                            <p id="ops-cumulative-pl" class="text-3xl font-bold text-success">$0.00</p>
                        </div>
                        <div class="text-success bg-success bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-chart-line text-xl"></i>
                        </div>
                    </div>
                    <div style="height: 100px; width: 100%; position: relative;">
                        <canvas id="ops-cumulative-chart"></canvas>
                    </div>
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-border">
                        <span class="text-xs text-text-secondary">ROI</span>
                        <span id="ops-roi" class="text-sm font-semibold text-success">0%</span>
                    </div>
                </div>

                <!-- Profit Factor Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1 flex items-center">
                                Profit Factor
                                <i class="fas fa-info-circle text-xs ml-1 cursor-help" title="Ganancias brutas / Pérdidas brutas"></i>
                            </p>
                            <p id="ops-profit-factor" class="text-3xl font-bold text-primary">0.00</p>
                        </div>
                        <div class="text-primary bg-primary bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-balance-scale text-xl"></i>
                        </div>
                    </div>
                    <div class="mt-4">
                        <!-- Gauge visual -->
                        <div class="relative h-3 bg-surface rounded-full overflow-hidden">
                            <div id="ops-pf-gauge" class="h-full transition-all duration-500" style="width: 0%; background: linear-gradient(to right, #ef4444, #eab308, #22c55e);"></div>
                        </div>
                        <div class="flex justify-between text-xs text-text-secondary mt-1">
                            <span>Poor</span>
                            <span>Good</span>
                            <span>Excellent</span>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-border">
                        <span class="text-xs text-text-secondary">Gross Win</span>
                        <span id="ops-gross-win" class="text-sm font-semibold text-success">$0</span>
                    </div>
                </div>

                <!-- Trade Win % Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1">Trade Win %</p>
                            <p id="ops-win-rate" class="text-3xl font-bold text-accent">0%</p>
                        </div>
                        <div class="text-accent bg-accent bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-bullseye text-xl"></i>
                        </div>
                    </div>
                    <div class="mt-4">
                        <!-- Donut chart simulado -->
                        <div class="relative mx-auto" style="width: 120px; height: 120px;">
                            <svg viewBox="0 0 36 36" class="circular-chart">
                                <path class="circle-bg"
                                    stroke="#2a2a2a"
                                    stroke-width="3"
                                    fill="none"
                                    d="M18 2.0845
                                    a 15.9155 15.9155 0 0 1 0 31.831
                                    a 15.9155 15.9155 0 0 1 0 -31.831"
                                />
                                <path id="ops-win-circle" class="circle"
                                    stroke="#3b82f6"
                                    stroke-width="3"
                                    stroke-dasharray="0, 100"
                                    stroke-linecap="round"
                                    fill="none"
                                    d="M18 2.0845
                                    a 15.9155 15.9155 0 0 1 0 31.831
                                    a 15.9155 15.9155 0 0 1 0 -31.831"
                                />
                                <text x="18" y="20.35" class="percentage" fill="#fff" font-size="8" text-anchor="middle" id="ops-win-text">0%</text>
                            </svg>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-border">
                        <span class="text-xs text-text-secondary">
                            <i class="fas fa-check-circle text-success mr-1"></i><span id="ops-total-wins">0</span> wins
                        </span>
                        <span class="text-xs text-text-secondary">
                            <i class="fas fa-times-circle text-danger mr-1"></i><span id="ops-total-losses">0</span> losses
                        </span>
                    </div>
                </div>
            </div>

             <div id="add-operation-form" class="metric-card mb-6" style="display: none;"><h3 class="text-lg font-semibold mb-4">Nueva Operación</h3><form id="operation-details-form"><div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 mb-4"><div><label class="block mb-1">Fecha</label><input type="date" id="op-date"></div><div><label class="block mb-1">Cuenta</label><select id="op-account"></select></div><div class="lg:col-span-2"><label class="block mb-1">Instrumento</label><input type="text" id="op-instrument" placeholder="EURUSD, AAPL, etc."></div><div><label class="block mb-1">Precio de Entrada</label><input type="number" id="op-entry" step="any"></div><div><label class="block mb-1">Hora Entrada</label><input type="time" id="op-entry-time"></div><div><label class="block mb-1">Precio de Salida</label><input type="number" id="op-exit" step="any"></div><div><label class="block mb-1">Hora Salida</label><input type="time" id="op-exit-time"></div><div><label class="block mb-1">Volumen</label><input type="number" id="op-volume" step="any"></div><div><label class="block mb-1">Divisa</label><select id="op-currency"><option value="USD">USD</option><option value="EUR">EUR</option><option value="USDT">USDT</option></select></div><div><label class="block mb-1">Tipo</label><select id="op-type"><option value="buy">Compra (Long)</option><option value="sell">Venta (Short)</option></select></div>
                <!-- NUEVO CAMPO: SESIÓN -->
                <div>
                    <label class="block mb-1">Sesión</label>
                    <select id="op-session">
                        <option value="">Seleccionar Sesión</option>
                        <option value="Asia">Asia</option>
                        <option value="Londres">Londres</option>
                        <option value="New York">New York</option>
                        <option value="Otro">Otro</option>
                    </select>
                </div>
                <!-- FIN NUEVO CAMPO: SESIÓN -->
                <div><label class="block mb-1">Resultado</label><div class="flex"><button type="button" id="op-win-btn" class="flex-1 mr-1 success">Ganancia</button><button type="button" id="op-loss-btn" class="flex-1 ml-1 danger">Pérdida</button></div></div><div class="md:col-span-2"><label class="block mb-1">Notas</label><textarea id="op-notes" rows="3"></textarea></div><div><label class="block mb-1">P&L Manual (opcional)</label><input type="number" id="op-manual-pl" step="any" placeholder="Sobrescribe P&L calculado"></div><div><label class="block mb-1">Comisiones/Fees</label><input type="number" id="op-fees" step="0.01" placeholder="0.00" title="Comisiones cobradas por el broker"></div><div class="lg:col-span-4"><label class="block mb-1">Adjuntar Imágenes (Máx. 5)</label><input type="file" id="op-image" accept="image/png, image/jpeg, image/jpg" multiple><div id="op-image-previews-container" class="mt-2 grid grid-cols-3 sm:grid-cols-5 gap-2"></div></div></div><div class="flex justify-end"><button type="button" id="op-cancel" class="mr-2">Cancelar</button><button type="button" id="op-save" class="primary">Guardar</button></div></form></div>
            <div class="flex flex-wrap justify-between items-end mb-4"><div class="flex flex-wrap items-end space-x-4"><div><label for="filter-account" class="block mb-1 text-sm text-text-secondary">Filtrar por cuenta:</label><div class="flex items-center gap-2"><div id="filter-account-logo" class="w-8 h-8 rounded-lg flex items-center justify-center" style="display: none;"><img id="filter-account-logo-img" src="" alt="" class="w-6 h-6 object-contain"></div><select id="filter-account" class="w-56 h-12"><option value="all">Todas las cuentas</option></select></div></div><div class="flex items-end space-x-2"><div><label for="filter-instrument" class="block mb-1 text-sm text-text-secondary">Filtrar por instrumento:</label><input type="text" id="filter-instrument" placeholder="Escribir instrumento..." class="w-56 h-12"></div><button id="operations-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded h-12" title="Filtrar por fecha"><i class="fas fa-calendar-alt"></i></button></div></div></div>
            <div id="operations-date-filter-display" class="date-filter-display-text text-sm text-text-secondary mb-4">Sin filtro de fecha</div>
            <div class="metric-card p-0"><table id="operations-table-render" class="w-full">
                <thead>
                    <tr>
                        <th data-sort="date">Fecha</th>
                        <th data-sort="entryTime">Entrada</th>
                        <th data-sort="exitTime">Salida</th>
                        <th data-sort="accountId">Cuenta</th>
                        <th data-sort="instrument">Instrumento</th>
                        <th data-sort="type">Tipo</th>
                        <th data-sort="entry">Precio E.</th>
                        <th data-sort="exit">Precio S.</th>
                        <th data-sort="volume">Vol.</th>
                        <th data-sort="result">Resultado</th>
                        <th data-sort="pl">P&L</th>
                        <th data-sort="fees">Comis.</th>
                        <th data-sort="currency">Divisa</th>
                        <th data-sort="session">Sesión</th>
                        <th class="text-center">Acciones</th>
                    </tr>
                </thead>
                <tbody id="operations-table"></tbody>
            </table></div>
        </section>

        <!-- Nueva Sección de Página Completa para Detalles de Operación -->
        <section id="operation-detail-page" class="section-container">
            <button id="back-to-operations-btn" class="mb-4 button"><i class="fas fa-arrow-left mr-2"></i> Volver a Operaciones</button>
            <div class="metric-card p-6">
                <h2 id="op-detail-page-title" class="text-3xl font-bold mb-6 text-primary">Detalles de la Operación</h2>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 mb-6 text-sm">
                    <div><strong>Fecha:</strong> <span id="op-detail-date"></span></div>
                    <div><strong>Cuenta:</strong> <span id="op-detail-account"></span></div>
                    <div><strong>Instrumento:</strong> <span id="op-detail-instrument"></span></div>
                    <div><strong>Tipo:</strong> <span id="op-detail-type"></span></div>
                    <div><strong>Entrada:</strong> <span id="op-detail-entry"></span></div>
                    <div><strong>Hora Entrada:</strong> <span id="op-detail-entry-time"></span></div>
                    <div><strong>Salida:</strong> <span id="op-detail-exit"></div>
                    <div><strong>Hora Salida:</strong> <span id="op-detail-exit-time"></span></div>
                    <div><strong>Volumen:</strong> <span id="op-detail-volume"></span></div>
                    <div><strong>Divisa:</strong> <span id="op-detail-currency"></span></div>
                    <div><strong>P&L Manual:</strong> <span id="op-detail-manual-pl"></span></div>
                    <div><strong>Comisión/Fee:</strong> <span id="op-detail-fee" class="text-red font-semibold"></span></div>
                    <div><strong>Sesión:</strong> <span id="op-detail-session"></span></div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">Resultado</h4>
                        <p id="op-detail-result" class="text-xl font-bold"></p>
                    </div>
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">P&L Bruto</h4>
                        <p id="op-detail-pl" class="text-xl font-bold"></p>
                    </div>
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">P&L Neto (después fee)</h4>
                        <p id="op-detail-net-pl" class="text-xl font-bold"></p>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">Notas:</h3>
                    <p id="op-detail-notes" class="text-sm bg-background p-3 rounded min-h-[80px] whitespace-pre-wrap"></p>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">Imágenes Adjuntas:</h3>
                    <div id="op-detail-images" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                        <p class="text-sm text-text-secondary md:col-span-3 text-center">No hay imágenes adjuntas.</p>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2">Análisis de Sesión:</h3>
                    <p class="text-sm mb-3">Esta operación se inició durante la sesión de: <span id="op-detail-session-current" class="font-bold text-primary">N/A</span></p>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead>
                                <tr>
                                    <th>Sesión</th>
                                    <th>P&L Total</th>
                                    <th>Comisiones</th>
                                    <th>P&L Neto</th>
                                    <th>Trades</th>
                                    <th>Win %</th>
                                </tr>
                            </thead>
                            <tbody id="op-detail-session-metrics">
                                <!-- Las métricas de sesión se rellenarán aquí -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <section id="accounts" class="section-container">
            <div class="flex justify-between items-center mb-6"><h2 class="text-xl font-semibold">Gestión de Cuentas</h2><button id="add-account-btn" class="primary"><i class="fas fa-plus mr-2"></i>Agregar Cuenta</button></div>
            <div id="add-account-form" class="metric-card mb-6" style="display: none;"><h3 class="text-lg font-semibold mb-4">Nueva Cuenta</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4"><div><label class="block mb-1">Nombre de la cuenta</label><input type="text" id="acc-name" placeholder="FTMO, PropFirm, etc."></div><div><label class="block mb-1">Balance inicial</label><input type="number" id="acc-balance" step="0.01" placeholder="100000"></div><div><label class="block mb-1">Divisa</label><select id="acc-currency"><option value="USD">USD</option><option value="EUR">EUR</option><option value="USDT">USDT</option></select></div><div><label class="block mb-1">Plataforma</label><select id="acc-platform"><option value="meta-trader-4">Meta Trader 4</option><option value="meta-trader-5">Meta Trader 5</option><option value="tradelocker">TradeLocker</option><option value="ctrader">cTrader</option><option value="tradingview">TradingView</option><option value="bingx">BingX</option><option value="bitget">Bitget</option><option value="mexc">MEXC</option><option value="primexbt">PrimeXBT</option><option value="bitunix">Bitunix</option><option value="matchtrader">Machtrader</option><option value="other">Otra</option></select></div></div><div class="flex justify-end"><button id="acc-cancel" class="mr-2">Cancelar</button><button id="acc-save" class="primary">Guardar</button></div></div>
            <div id="accounts-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>
            <div id="selected-account-details" class="mt-8" style="display: none;">
                <h3 id="account-detail-name" class="text-xl font-semibold mb-4">Detalles de la Cuenta</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Evolución de la Cuenta</h3>
                        <div class="time-range-buttons mb-3 text-sm" id="account-detail-time-range">
                            <button data-range="1W" class="time-range-btn">1S</button>
                            <button data-range="1M" class="time-range-btn">1M</button>
                            <button data-range="3M" class="time-range-btn">3M</button>
                            <button data-range="6M" class="time-range-btn">6M</button>
                            <button data-range="1Y" class="time-range-btn">1A</button>
                            <button data-range="ALL" class="time-range-btn active">Todo</button>
                        </div>
                        <div class="chart-container"><canvas id="account-detail-chart"></canvas></div>
                    </div>
                    <div class="metric-card p-6">
                        <h3 class="text-lg font-semibold mb-4">Métricas de la Cuenta</h3>
                        <div class="grid grid-cols-2 gap-x-8 gap-y-4 mb-4">
                            <div><p class="text-sm text-text-secondary">P&L Total</p><p id="account-detail-pl" class="text-2xl font-bold">$0.00</p></div>
                            <div><p class="text-sm text-text-secondary">Win Rate</p><p id="account-detail-winrate" class="text-2xl font-bold">0%</p></div>
                            <div><p class="text-sm text-text-secondary">Operaciones</p><p id="account-detail-trades" class="text-2xl font-bold">0</p></div>
                            <div><p class="text-sm text-text-secondary">Profit Factor</p><p id="account-detail-pf" class="text-2xl font-bold">0.00</p></div>
                        </div>
                        <h3 class="text-lg font-semibold mb-2 mt-4">Puntuación de Rendimiento</h3>
                        <div class="chart-container" style="height: 220px;">
                            <canvas id="account-detail-radar-chart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-1 xl:grid-cols-3 gap-6">
                    <div class="metric-card xl:col-span-1">
                        <h3 class="text-lg font-semibold mb-3">Estadísticas Adicionales</h3>
                        <dl class="space-y-3 text-sm">
                            <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="account-detail-drawdown" class="font-semibold text-red">$0.00 (0%)</dd></div>
                            <div class="flex justify-between"><dt>Ratio Ganancia/Pérdida Prom:</dt><dd id="account-detail-avg-w-l-ratio" class="font-semibold">0.00</dd></div>
                            <div class="flex justify-between"><dt>Racha Ganadora Máx:</dt><dd id="account-detail-win-streak" class="font-semibold">0</dd></div>
                            <div class="flex justify-between"><dt>Racha Perdedora Máx:</dt><dd id="account-detail-loss-streak" class="font-semibold">0</dd></div>
                            <div class="flex justify-between"><dt>Tiempo Prom. por Operación:</dt><dd id="account-detail-hold-time" class="font-semibold">N/A</dd></div>
                        </dl>
                        <h3 class="text-lg font-semibold mt-6 mb-3">Análisis Long/Short</h3>
                        <table class="w-full text-xs"><thead><tr><th>Tipo</th><th>Trades</th><th>P&L</th><th>Win%</th></tr></thead><tbody id="account-long-short-analysis"></tbody></table>
                    </div>
                    <div class="metric-card xl:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div><h3 class="text-lg font-semibold mb-2">Mejores Operaciones</h3><table class="w-full"><thead><tr><th>Fecha</th><th>Instrumento</th><th>P&L</th></tr></thead><tbody id="best-trades"></tbody></table></div>
                        <div><h3 class="text-lg font-semibold mb-2">Peores Operaciones</h3><table class="w-full"><thead><tr><th>Fecha</th><th>Instrumento</th><th>P&L</th></tr></thead><tbody id="worst-trades"></tbody></table></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="finances" class="section-container">
            <div class="flex flex-wrap justify-between items-center mb-6"><h2 class="text-xl font-semibold">Finanzas Manuales (Ingresos/Gastos)</h2><button id="add-finance-entry-btn" class="primary"><i class="fas fa-plus mr-2"></i>Añadir Movimiento</button></div>
            <div id="add-finance-entry-form" class="metric-card mb-6" style="display: none;"><h3 class="text-lg font-semibold mb-4">Nuevo Movimiento Financiero</h3><form id="finance-entry-details-form"><div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4"><div><label class="block mb-1">Fecha</label><input type="date" id="finance-date"></div><div><label class="block mb-1">Monto (+/-)</label><input type="number" id="finance-amount" step="any" placeholder="Ej: 500 o -150"></div><div><label class="block mb-1">Divisa</label><select id="finance-currency"><option value="USD">USD</option><option value="EUR">EUR</option><option value="USDT">USDT</option></select></div><div class="md:col-span-3"><label class="block mb-1">Descripción / Notas</label><textarea id="finance-notes" rows="2" placeholder="Ej: Retiro de broker, Compra de curso..."></textarea></div></div><div class="flex justify-end"><button type="button" id="finance-cancel-btn" class="mr-2">Cancelar</button><button type="button" id="finance-save-btn" class="primary">Guardar</button></div></form></div>
             <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                <div><label class="block mb-2 text-text-secondary">Filtrar por fecha:</label><div class="flex items-center space-x-2"><button id="finances-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha"><i class="fas fa-calendar-alt"></i></button><div id="finances-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div></div></div>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 w-full lg:w-auto"><div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">P/L de Trading</h4><p id="finance-trading-pl" class="text-xl font-bold text-green">$0.00</p></div><div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Win Rate</h4><p id="finance-win-rate" class="text-xl font-bold text-green">0%</p></div><div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Ingresos</h4><p id="finance-total-income" class="text-xl font-bold text-green">$0.00</p></div><div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Gastos</h4><p id="finance-total-expenses" class="text-xl font-bold text-red">$0.00</p></div><div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Balance Neto</h4><p id="finance-net-balance" class="text-xl font-bold text-white">$0.00</p></div></div>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Evolución Financiera</h3><div class="chart-container" style="height: 350px;"><canvas id="finances-evolution-chart"></canvas></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Registro de Movimientos</h3><div class="overflow-y-auto max-h-[350px]"><table id="finances-table" class="w-full"><thead><tr><th class="w-1/4">Fecha</th><th class="w-2/5">Descripción</th><th class="w-1/5">Monto</th><th class="w-1/6">Divisa</th><th class="w-1/5 text-center">Acciones</th></tr></thead><tbody id="finances-table-body"></tbody></table></div></div>
            </div>
        </section>

        <section id="news" class="section-container">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="metric-card p-0 flex flex-col">
                    <h3 class="text-lg font-semibold p-4 pb-2">Calendario de Noticias Económicas</h3>
                    <div class="flex-grow" style="min-height: 600px;">
                        <!-- TradingView Widget BEGIN -->
                        <div class="tradingview-widget-container">
                          <div class="tradingview-widget-container__widget"></div>
                          <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-events.js" async>
                          {"colorTheme":"dark","isTransparent":true,"width":"100%","height":"100%","locale":"es","importanceFilter":"-1,0,1","currencyFilter":"USD,EUR,JPY,GBP,CHF,AUD,CAD,NZD,CNY"}
                          </script>
                        </div>
                        <!-- TradingView Widget END -->
                    </div>
                </div>
                <div class="metric-card p-0 flex flex-col">
                    <h3 class="text-lg font-semibold p-4 pb-2">Últimas Noticias del Mercado</h3>
                    <div class="flex-grow" style="min-height: 600px;">
                        <!-- TradingView Widget BEGIN -->
                        <div class="tradingview-widget-container">
                          <div class="tradingview-widget-container__widget"></div>
                                                    <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-timeline.js" async>
                                                    {"feedMode":"all_symbols","colorTheme":"dark","isTransparent":true,"displayMode":"regular","width":"100%","height":"100%","locale":"es"}
                                                    </script>
                        </div>
                        <!-- TradingView Widget END -->
                    </div>
                </div>
            </div>
             <div class="metric-card p-4 mt-6">
                <h3 class="text-lg font-semibold mb-2">Visión General del Mercado</h3>
                <!-- TradingView Widget BEGIN -->
                <div class="tradingview-widget-container">
                  <div class="tradingview-widget-container__widget"></div>
                                    <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-market-overview.js" async>
                                    {"colorTheme":"dark","dateRange":"12M","showChart":true,"locale":"es","largeChartUrl":"","isTransparent":true,"showSymbolLogo":true,"showFloatingTooltip":false,"width":"100%","height":"660","plotLineColorGrowing":"rgba(57, 255, 20, 1)","plotLineColorFalling":"rgba(255, 65, 54, 1)","gridLineColor":"rgba(42, 42, 42, 1)","scaleFontColor":"rgba(160, 160, 160, 1)","belowLineFillColorGrowing":"rgba(57, 255, 20, 0.12)","belowLineFillColorFalling":"rgba(255, 65, 54, 0.12)","belowLineFillColorGrowingBottom":"rgba(57, 255, 20, 0)","belowLineFillColorFallingBottom":"rgba(255, 65, 54, 0)","symbolActiveColor":"rgba(57, 255, 20, 0.12)","tabs":[{"title":"Índices","symbols":[{"s":"FOREXCOM:SPXUSD","d":"S&P 500"},{"s":"FOREXCOM:NSXUSD","d":"US 100"},{"s":"FOREXCOM:DJI","d":"Dow 30"},{"s":"INDEX:DEU40","d":"DAX 40"},{"s":"FOREXCOM:UKXGBP","d":"UK 100"},{"s":"CAPITALCOM:JP225","d":"Nikkei 225"}],"originalTitle":"Indices"},{"title":"Criptomonedas","symbols":[{"s":"BITSTAMP:BTCUSD","d":"Bitcoin"},{"s":"BITSTAMP:ETHUSD","d":"Ethereum"},{"s":"COINBASE:SOLUSD","d":"Solana"},{"s":"COINBASE:XRPUSD","d":"Ripple"},{"s":"COINBASE:DOGEUSD","d":"Dogecoin"},{"s":"COINBASE:ADAUSD","d":"Cardano"}],"originalTitle":"Cryptocurrencies"},{"title":"Materias primas","symbols":[{"s":"COMEX:GC1!","d":"Oro"},{"s":"NYMEX:CL1!","d":"Petróleo Crudo"},{"s":"TVC:SILVER","d":"Plata"},{"s":"NYMEX:NG1!","d":"Gas Natural"},{"s":"TVC:COPPER","d":"Cobre"},{"s":"CBOT:ZC1!","d":"Maíz"}],"originalTitle":"Commodities"},{"title":"Forex","symbols":[{"s":"FX:EURUSD","d":"EUR/USD"},{"s":"FX:GBPUSD","d":"GBP/USD"},{"s":"FX:USDJPY","d":"USD/JPY"},{"s":"FX:USDCHF","d":"USD/CHF"},{"s":"FX:AUDUSD","d":"AUD/USD"},{"s":"FX:USDCAD","d":"USD/CAD"}],"originalTitle":"Forex"}]}
                                    </script>
                </div>
                <!-- TradingView Widget END -->
            </div>
        </section>

        <section id="config" class="section-container">
            <h2 class="text-xl font-semibold mb-6">Configuración</h2>
            
            <!-- Estado de Autenticación -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Estado de Sesión</h3>
                <div id="auth-status-container">
                    <div id="auth-status-logged-out" class="p-4 bg-yellow-800 border border-yellow-600 rounded-md mb-4">
                        <div class="flex items-center">
                            <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                            <div>
                                <p class="font-semibold text-yellow-100">Sin sesión activa</p>
                                <p class="text-sm text-yellow-200 mt-1">Sus operaciones se guardan localmente. Para acceder desde otros dispositivos, inicie sesión.</p>
                            </div>
                        </div>
                        <button id="show-auth-modal-btn" class="mt-3 bg-primary text-black font-semibold py-2 px-4 rounded hover:bg-secondary transition-colors">
                            <i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión / Registrarse
                        </button>
                    </div>
                    
                    <div id="auth-status-logged-in" class="p-4 bg-green-800 border border-green-600 rounded-md mb-4" style="display: none;">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <i class="fas fa-check-circle text-green-300 text-xl mr-3"></i>
                                <div>
                                    <p class="font-semibold text-green-100">Sesión activa</p>
                                    <p class="text-sm text-green-200 mt-1">Usuario: <span id="current-user-email"></span></p>
                                    <p class="text-xs text-green-300 mt-1">Sus datos se guardan automáticamente</p>
                                </div>
                            </div>
                            <div class="flex space-x-2">
                                <button id="logout-btn-config" class="bg-red-600 text-white font-semibold py-2 px-4 rounded hover:bg-red-700 transition-colors">
                                    <i class="fas fa-sign-out-alt mr-2"></i>Cerrar Sesión
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-4">Ajustes y Datos</h3><div class="mb-6"><h4 class="font-semibold mb-2">Opciones de Visualización</h4><div class="mb-4"><label class="flex items-center mb-2"><input type="checkbox" id="dark-mode" checked disabled><span class="ml-2 opacity-50">Modo oscuro (Siempre activo)</span></label><label class="flex items-center mb-2"><input type="checkbox" id="show-tooltips" checked><span class="ml-2">Mostrar tooltips en gráficos</span></label><label class="flex items-center mb-2"><input type="checkbox" id="auto-refresh" checked disabled><span class="ml-2 opacity-50">Actualizar auto. (Desactivado)</span></label></div></div>
                    <div id="csv-import-section" class="mb-6"><h4 class="font-semibold mb-2">Importar Operaciones desde CSV</h4><div class="grid grid-cols-1 gap-4 items-end"><div><label for="csv-file-input" class="block mb-1">Seleccionar archivo CSV:</label><input type="file" id="csv-file-input" accept=".csv"></div><button id="import-csv-btn" class="primary h-12"><i class="fas fa-upload mr-2"></i>Importar CSV</button></div><p class="text-xs text-text-secondary mt-2">Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)</p><div id="csv-import-status" class="mt-2 text-sm"></div></div>
                    <div class="mb-6"><h4 class="font-semibold mb-2">Respaldo y Datos</h4><div class="grid grid-cols-1 gap-4"><button id="export-data" class="primary"><i class="fas fa-download mr-2"></i>Exportar datos (.json)</button><div><label for="import-data" class="block w-full text-center py-3 px-4 bg-surface-light hover:bg-primary hover:text-background cursor-pointer rounded-md transition-all font-bold"><i class="fas fa-upload mr-2"></i>Importar datos (.json)</label><input type="file" id="import-data" class="hidden" accept=".json"></div><button id="clear-data" class="danger"><i class="fas fa-trash-alt mr-2"></i>Borrar todos los datos</button></div></div>

                </div>
            </div>
        </section>

        <!-- NUEVA SECCIÓN: PLATAFORMAS -->
        <section id="platforms" class="section-container">
            <h2 class="text-xl font-semibold mb-6">Plataformas de Trading</h2>
            
            <!-- Grid de Plataformas -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                
                <!-- BingX -->
                <div class="platform-card cursor-pointer" data-platform="bingx">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#006FFF]">
                                <img src="https://assets.coingecko.com/coins/images/28602/small/bingx-logo.png" alt="BingX Logo" class="w-10 h-10 object-contain" onerror="this.src='bingx-logo.png'; this.onerror=function(){this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#006FFF] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>BX</div>'}">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">BingX</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="bingx-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="bingx-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="bingx-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="bingx-import-csv" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de BingX">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="bingx-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con BingX">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Bitget -->
                <div class="platform-card cursor-pointer" data-platform="bitget">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#54FDD5]">
                                <img src="bitget-logo.png" alt="Bitget Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#54FDD5] rounded-xl flex items-center justify-center text-black font-bold text-xl\'>BG</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Bitget</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="bitget-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="bitget-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="bitget-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="bitget-import-csv" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de Bitget">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="bitget-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con Bitget">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Binance -->
                <div class="platform-card cursor-pointer" data-platform="binance">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all opacity-50">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#F3BA2F]">
                                <img src="https://cryptologos.cc/logos/binance-coin-bnb-logo.png" alt="Binance Logo" class="w-10 h-10 object-contain" onerror="this.src='binance-logo.png'; this.onerror=function(){this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#F3BA2F] rounded-xl flex items-center justify-center text-black font-bold text-xl\'>BN</div>'}">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Binance</h3>
                                <p class="text-sm text-text-secondary">Exchange Líder</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Próximamente</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-gray-500 bg-surface px-2 py-1 rounded">En desarrollo</span>
                        </div>
                    </div>
                </div>

                <!-- MEXC -->
                <div class="platform-card cursor-pointer" data-platform="mexc">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#00C087]">
                                <img src="https://s2.coinmarketcap.com/static/img/exchanges/64x64/544.png" alt="MEXC Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#00C087] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>MX</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">MEXC</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="mexc-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="mexc-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="mexc-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="mexc-import-csv" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de MEXC">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="mexc-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con MEXC">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Bitunix -->
                <div class="platform-card cursor-pointer" data-platform="bitunix">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all opacity-50">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-gradient-to-r from-purple-500 to-pink-500">
                                <img src="https://pbs.twimg.com/profile_images/1758090503688515584/kJQw5pBK_400x400.jpg" alt="Bitunix Logo" class="w-10 h-10 object-contain rounded-xl" onerror="this.src='bitunix-logo.png'; this.onerror=function(){this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl flex items-center justify-center text-white font-bold text-xl\'>BU</div>'}">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Bitunix</h3>
                                <p class="text-sm text-text-secondary">Exchange Emergente</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Próximamente</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-gray-500 bg-surface px-2 py-1 rounded">En desarrollo</span>
                        </div>
                    </div>
                </div>

                <!-- PrimeXBT -->
                <div class="platform-card cursor-pointer" data-platform="primexbt">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#0066FF]">
                                <img src="primexbt-logo.png" alt="PrimeXBT Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#0066FF] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>PX</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">PrimeXBT</h3>
                                <p class="text-sm text-text-secondary">Trading Avanzado</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Importación manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="primexbt-import-csv" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de PrimeXBT">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- MetaTrader 5 -->
                <!-- MetaTrader 5 -->
                <div class="platform-card cursor-pointer" data-platform="metatrader5">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#1B5E20]">
                                <img src="metatrader5-logo.png" alt="MetaTrader 5 Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#1B5E20] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>MT5</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">MetaTrader 5</h3>
                                <p class="text-sm text-text-secondary">Plataforma Profesional</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Importación manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="mt5-import-html" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar Informe HTML de MT5">
                                <i class="fas fa-file-code text-xs"></i>
                                <span>HTML</span>
                            </button>
                            <button id="mt5-clean-operations" class="bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Limpiar operaciones con errores">
                                <i class="fas fa-broom text-xs"></i>
                                <span>Limpiar</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- cTrader -->
                <div class="platform-card cursor-pointer" data-platform="ctrader">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all opacity-50">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#00A8E1]">
                                <img src="ctrader-logo.png" alt="cTrader Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#00A8E1] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>CT</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">cTrader</h3>
                                <p class="text-sm text-text-secondary">Plataforma Avanzada</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Próximamente</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-gray-500 bg-surface px-2 py-1 rounded">En desarrollo</span>
                        </div>
                    </div>
                </div>

                <!-- TradingView -->
                <div class="platform-card cursor-pointer" data-platform="tradingview">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all opacity-50">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#2962FF]">
                                <img src="tradingview-logo.png" alt="TradingView Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#2962FF] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>TV</div>'">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">TradingView</h3>
                                <p class="text-sm text-text-secondary">Análisis de Mercados</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Próximamente</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-gray-500 bg-surface px-2 py-1 rounded">En desarrollo</span>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- PANTALLA DETALLADA DE BINGX -->
        <section id="platform-bingx" class="section-container" style="display: none;">
            <div class="flex items-center mb-6">
                <button id="back-to-platforms" class="mr-4 p-2 hover:bg-surface-light rounded-lg transition-all">
                    <i class="fas fa-arrow-left text-xl"></i>
                </button>
                <div class="flex items-center">
                    <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4">
                        <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iMjQiIGZpbGw9IiMwMDZGRkYiLz4KPHBhdGggZD0iTTI4LjUgMTJIMzZMMjQgMjRMMTIgMTJIMTkuNUwyNCAyMC41TDI4LjUgMTJaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMTkuNSAzNkgxMkwyNCAyNEwzNiAzNkgyOC41TDI0IDI3LjVMMTkuNSAzNloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPg==" alt="BingX Logo" class="w-full h-full object-contain">
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold">BingX Exchange</h2>
                        <p class="text-text-secondary">Configuración y Sincronización</p>
                    </div>
                </div>
            </div>

            <!-- Estado de Conexión -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Estado de Conexión</h3>
                <div id="bingx-connection-status" class="p-4 bg-yellow-800 border border-yellow-600 rounded-md mb-4">
                    <div class="flex items-center">
                        <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                        <div>
                            <p class="font-semibold text-yellow-100">No conectado</p>
                            <p class="text-sm text-yellow-200 mt-1">Configure sus claves API para comenzar la sincronización automática.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Configuración de API -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Configuración de API</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block mb-2 font-medium">Clave API</label>
                        <input type="password" id="bingx-api-key-detail" class="w-full" placeholder="Introduce tu clave API de BingX">
                        <p class="text-xs text-text-secondary mt-1">La clave API se almacena localmente y de forma segura</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Secret API</label>
                        <input type="password" id="bingx-secret-key-detail" class="w-full" placeholder="Introduce tu secret de BingX">
                        <p class="text-xs text-text-secondary mt-1">El secret se encripta antes de almacenarse</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Cuenta a sincronizar</label>
                        <select id="bingx-account-detail" class="w-full">
                            <option value="">Seleccionar cuenta...</option>
                        </select>
                        <p class="text-xs text-text-secondary mt-1">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-yellow-900 border border-yellow-600 rounded-md">
                    <p class="text-sm text-yellow-100">
                        <i class="fas fa-info-circle mr-2"></i>
                        <strong>¿Error de signature?</strong> Las credenciales pueden ser incorrectas. 
                        Ve a <strong>BingX → Account → API Management</strong> y crea nuevas credenciales con permisos de <strong>Read + Trade</strong>.
                    </p>
                </div>
                
                <div class="flex space-x-3 mt-6">
                    <button id="test-bingx-connection-detail" class="secondary flex-1">
                        <i class="fas fa-plug mr-2"></i>Probar Conexión
                    </button>
                    <button id="test-auth-only" class="warning flex-1">
                        <i class="fas fa-key mr-2"></i>Test Auth
                    </button>
                    <button id="connect-bingx-detail" class="primary flex-1">
                        <i class="fas fa-link mr-2"></i>Conectar BingX
                    </button>
                    <button id="sync-bingx-trades-detail" class="success flex-1">
                        <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                    </button>
                </div>
            </div>

            <!-- Importar CSV -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Importar desde CSV</h3>
                <div class="space-y-4">
                    <div>
                        <label for="bingx-csv-file-input" class="block mb-2 font-medium">Seleccionar archivo CSV:</label>
                        <input type="file" id="bingx-csv-file-input" accept=".csv" class="w-full">
                        <p class="text-xs text-text-secondary mt-1">Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)</p>
                    </div>
                    
                    <button id="bingx-import-csv-btn" class="primary w-full">
                        <i class="fas fa-upload mr-2"></i>Importar CSV
                    </button>
                    
                    <div id="bingx-csv-import-status" class="text-sm"></div>
                </div>
            </div>

            <!-- Información del Proxy Server -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Servidor Proxy</h3>
                <div id="bingx-proxy-status-detail" class="p-4 bg-green-800 border border-green-600 rounded-md">
                    <div class="flex items-center">
                        <i class="fas fa-check-circle text-green-300 text-xl mr-3"></i>
                        <div>
                            <p class="font-semibold text-green-100">Proxy Server Activo</p>
                            <p class="text-sm text-green-200 mt-1">El servidor proxy está corriendo en <span id="proxy-url-display">http://127.0.0.1:8003</span></p>
                            <p class="text-sm text-green-200 mt-1"><strong>Solución CORS:</strong> Las llamadas a BingX pasan por el proxy para evitar restricciones del navegador.</p>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 p-4 bg-orange-900 border border-orange-600 rounded-md">
                    <div class="flex items-start">
                        <i class="fas fa-info-circle text-orange-300 text-xl mr-3 mt-0.5"></i>
                        <div>
                            <p class="font-semibold text-orange-100">Importante - Solo Cuenta Real</p>
                            <p class="text-sm text-orange-200 mt-1">BingX no permite APIs en modo demo/testnet. Solo funciona con cuentas reales.</p>
                            <p class="text-sm text-orange-200 mt-2"><strong>Para pruebas seguras:</strong> Puedes crear operaciones con volúmenes muy pequeños (0.01 lotes).</p>
                            <p class="text-sm text-orange-200 mt-1">La sincronización importará todas las operaciones reales de BingX.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Historial de Sincronización -->
            <div class="metric-card">
                <h3 class="text-lg font-semibold mb-4">Historial de Sincronización</h3>
                <div id="bingx-sync-history" class="space-y-2">
                    <p class="text-text-secondary text-center py-4">No hay sincronizaciones realizadas</p>
                </div>
            </div>
        </section>

        <!-- ============================================
             PANEL DE BITGET
             ============================================ -->
        <section id="platform-bitget" class="section-container" style="display: none;">
            <div class="flex items-center mb-6">
                <button id="back-to-platforms-bitget" class="mr-4 p-2 hover:bg-surface-light rounded-lg transition-all">
                    <i class="fas fa-arrow-left text-xl"></i>
                </button>
                <div class="flex items-center">
                    <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#54FDD5]">
                        <img src="bitget-logo.png" alt="Bitget Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#54FDD5] rounded-xl flex items-center justify-center text-black font-bold text-xl\'>BG</div>'">
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold">Bitget Exchange</h2>
                        <p class="text-text-secondary">Configuración y Sincronización</p>
                    </div>
                </div>
            </div>

            <!-- Estado de Conexión -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Estado de Conexión</h3>
                <div id="bitget-connection-status" class="p-4 bg-yellow-800 border border-yellow-600 rounded-md mb-4">
                    <div class="flex items-center">
                        <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                        <div>
                            <p class="font-semibold text-yellow-100">No conectado</p>
                            <p class="text-sm text-yellow-200 mt-1">Configure sus claves API para comenzar la sincronización automática.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Configuración de API -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Configuración de API</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block mb-2 font-medium">Clave API</label>
                        <input type="password" id="bitget-api-key-detail" class="w-full" placeholder="Introduce tu clave API de Bitget">
                        <p class="text-xs text-text-secondary mt-1">La clave API se almacena localmente y de forma segura</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Secret API</label>
                        <input type="password" id="bitget-secret-key-detail" class="w-full" placeholder="Introduce tu secret de Bitget">
                        <p class="text-xs text-text-secondary mt-1">El secret se encripta antes de almacenarse</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Passphrase</label>
                        <input type="password" id="bitget-passphrase-detail" class="w-full" placeholder="Introduce tu passphrase de Bitget">
                        <p class="text-xs text-text-secondary mt-1">El passphrase es requerido para autenticación en Bitget</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Cuenta a sincronizar</label>
                        <select id="bitget-account-detail" class="w-full">
                            <option value="">Seleccionar cuenta...</option>
                        </select>
                        <p class="text-xs text-text-secondary mt-1">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-blue-900 border border-blue-600 rounded-md">
                    <p class="text-sm text-blue-100">
                        <i class="fas fa-info-circle mr-2"></i>
                        <strong>Configurar API en Bitget:</strong> Ve a <strong>Perfil → API Management</strong> y crea nuevas credenciales con permisos de <strong>Read</strong>.
                        Bitget requiere API Key, Secret y Passphrase para la autenticación.
                    </p>
                </div>
                
                <div class="flex space-x-3 mt-6">
                    <button id="test-bitget-connection-detail" class="secondary flex-1">
                        <i class="fas fa-plug mr-2"></i>Probar Conexión
                    </button>
                    <button id="connect-bitget-detail" class="primary flex-1">
                        <i class="fas fa-link mr-2"></i>Conectar Bitget
                    </button>
                    <button id="sync-bitget-trades-detail" class="success flex-1">
                        <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                    </button>
                </div>
            </div>

            <!-- Importar CSV -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Importar desde CSV</h3>
                <div class="space-y-4">
                    <div>
                        <label for="bitget-csv-file-input" class="block mb-2 font-medium">Seleccionar archivo CSV:</label>
                        <input type="file" id="bitget-csv-file-input" accept=".csv" class="w-full">
                        <p class="text-xs text-text-secondary mt-1">Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)</p>
                    </div>
                    
                    <button id="bitget-import-csv-btn" class="primary w-full">
                        <i class="fas fa-upload mr-2"></i>Importar CSV
                    </button>
                    
                    <div id="bitget-csv-import-status" class="text-sm"></div>
                </div>
            </div>

            <!-- Información adicional -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Información</h3>
                <div class="p-4 bg-blue-900 border border-blue-600 rounded-md">
                    <div class="flex items-start">
                        <i class="fas fa-info-circle text-blue-300 text-xl mr-3 mt-1"></i>
                        <div>
                            <p class="font-semibold text-blue-100">Acerca de Bitget</p>
                            <p class="text-sm text-blue-200 mt-2">Bitget es un exchange de criptomonedas global que ofrece trading spot, futuros y copy trading.</p>
                            <p class="text-sm text-blue-200 mt-2"><strong>API Endpoints:</strong> La integración utiliza la API oficial de Bitget para sincronizar trades automáticamente.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Historial de Sincronización -->
            <div class="metric-card">
                <h3 class="text-lg font-semibold mb-4">Historial de Sincronización</h3>
                <div id="bitget-sync-history" class="space-y-2">
                    <p class="text-text-secondary text-center py-4">No hay sincronizaciones realizadas</p>
                </div>
            </div>
        </section>

        <!-- MEXC Platform Panel -->
        <section id="platform-mexc" class="section-container" style="display: none;">
            <div class="flex items-center mb-6">
                <button id="back-to-platforms-mexc" class="mr-4 p-2 hover:bg-surface-light rounded-lg transition-all">
                    <i class="fas fa-arrow-left text-xl"></i>
                </button>
                <div class="flex items-center">
                    <div class="w-12 h-12 rounded-xl flex items-center justify-center mr-4 bg-[#00C087]">
                        <img src="https://s2.coinmarketcap.com/static/img/exchanges/64x64/544.png" alt="MEXC Logo" class="w-10 h-10 object-contain" onerror="this.parentElement.innerHTML='<div class=\'w-12 h-12 bg-[#00C087] rounded-xl flex items-center justify-center text-white font-bold text-xl\'>MX</div>'">
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold">MEXC Exchange</h2>
                        <p class="text-text-secondary">Configuración y Sincronización</p>
                    </div>
                </div>
            </div>

            <!-- Estado de Conexión -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Estado de Conexión</h3>
                <div id="mexc-connection-status" class="p-4 bg-yellow-800 border border-yellow-600 rounded-md mb-4">
                    <div class="flex items-center">
                        <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                        <div>
                            <p class="font-semibold text-yellow-100">No conectado</p>
                            <p class="text-sm text-yellow-200 mt-1">Importa operaciones mediante archivo CSV.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Configuración de API -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Configuración de API</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block mb-2 font-medium">Clave API</label>
                        <input type="password" id="mexc-api-key-detail" class="w-full" placeholder="Introduce tu clave API de MEXC">
                        <p class="text-xs text-text-secondary mt-1">La clave API se almacena localmente y de forma segura</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Secret API</label>
                        <input type="password" id="mexc-secret-key-detail" class="w-full" placeholder="Introduce tu secret de MEXC">
                        <p class="text-xs text-text-secondary mt-1">El secret se encripta antes de almacenarse</p>
                    </div>
                    
                    <div>
                        <label class="block mb-2 font-medium">Cuenta a sincronizar</label>
                        <select id="mexc-account-detail" class="w-full">
                            <option value="">Seleccionar cuenta...</option>
                        </select>
                        <p class="text-xs text-text-secondary mt-1">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-blue-900 border border-blue-600 rounded-md">
                    <p class="text-sm text-blue-100">
                        <i class="fas fa-info-circle mr-2"></i>
                        <strong>Configurar API en MEXC Futures:</strong> Ve a <strong>Account → API Management → Futures</strong> y crea nuevas credenciales con permisos de <strong>View Account Details</strong> y <strong>View Order Details</strong>.
                        MEXC Futures requiere API Key y Secret para la autenticación.
                    </p>
                </div>

                <!-- Información del Proxy Server -->
                <div class="mt-4">
                    <div id="mexc-proxy-status-detail" class="p-4 bg-green-800 border border-green-600 rounded-md">
                        <div class="flex items-center">
                            <i class="fas fa-server text-green-300 text-xl mr-3"></i>
                            <div>
                                <p class="font-semibold text-green-100">Proxy Server Activo</p>
                                <p class="text-sm text-green-200 mt-1">El servidor proxy está corriendo en <span id="proxy-url-display_2">http://127.0.0.1:8003</span></p>
                                <p class="text-sm text-green-200 mt-1"><strong>Solución CORS:</strong> Las llamadas a MEXC Futures pasan por el proxy para evitar restricciones del navegador.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="flex space-x-3 mt-6">
                    <button id="test-mexc-connection-detail" class="secondary flex-1">
                        <i class="fas fa-plug mr-2"></i>Probar Conexión
                    </button>
                    <button id="connect-mexc-detail" class="primary flex-1">
                        <i class="fas fa-link mr-2"></i>Conectar MEXC
                    </button>
                    <button id="sync-mexc-trades-detail" class="success flex-1">
                        <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                    </button>
                </div>
                
                <div class="mt-3">
                    <button id="disconnect-mexc-detail" class="w-full px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors">
                        <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                    </button>
                </div>
            </div>

            <!-- Importar CSV -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Importar desde CSV</h3>
                <div class="space-y-4">
                    <div>
                        <label for="mexc-csv-file-input" class="block mb-2 font-medium">Seleccionar archivo CSV:</label>
                        <input type="file" id="mexc-csv-file-input" accept=".csv" class="w-full">
                        <p class="text-xs text-text-secondary mt-1">
                            <strong>Formato requerido:</strong> Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opcional), Divisa, Tarifa/Comisión (opcional), Notas (opcional)
                        </p>
                    </div>
                    
                    <div class="p-3 bg-blue-900 border border-blue-600 rounded-md">
                        <p class="text-sm text-blue-100">
                            <i class="fas fa-lightbulb mr-2"></i>
                            <strong>Ejemplo de CSV válido:</strong>
                        </p>
                        <pre class="text-xs text-blue-200 mt-2 overflow-x-auto">Nombre Cuenta,Fecha,Hora Entrada,Hora Salida,Instrumento,Tipo,Entrada,Salida,Volumen,P&L,Divisa,Tarifa/Comision,Notas
Mi Cuenta MEXC,2024-10-15,09:30,10:45,BTCUSDT,buy,42500.00,43200.00,0.1,70.00,USDT,2.50,Trade exitoso</pre>
                    </div>
                    
                    <button id="mexc-import-csv-btn" class="primary w-full">
                        <i class="fas fa-upload mr-2"></i>Importar CSV de MEXC
                    </button>
                    
                    <div id="mexc-csv-import-status" class="text-sm"></div>
                </div>
            </div>

            <!-- Información adicional -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Información</h3>
                <div class="p-4 bg-blue-900 border border-blue-600 rounded-md">
                    <div class="flex items-start">
                        <i class="fas fa-info-circle text-blue-300 text-xl mr-3 mt-1"></i>
                        <div>
                            <p class="font-semibold text-blue-100">Acerca de MEXC Futures</p>
                            <p class="text-sm text-blue-200 mt-2">MEXC es un exchange de criptomonedas que ofrece trading de futuros perpetuos y contratos con apalancamiento.</p>
                            <p class="text-sm text-blue-200 mt-2"><strong>Importación API:</strong> Integración completa con MEXC Futures API para sincronización automática de trades.</p>
                            <p class="text-sm text-blue-200 mt-2"><strong>Importación CSV:</strong> También soporta importación manual mediante archivos CSV.</p>
                            <p class="text-sm text-blue-200 mt-2"><strong>Plataforma:</strong> MEXC Futures (Perpetual Contracts)</p>
                            <p class="text-sm text-blue-200 mt-2"><strong>Proxy:</strong> Requiere servidor proxy local en puerto 8003 para evitar CORS.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Historial de Importaciones -->
            <div class="metric-card">
                <h3 class="text-lg font-semibold mb-4">Historial de Importaciones</h3>
                <div id="mexc-import-history" class="space-y-2">
                    <p class="text-text-secondary text-center py-4">No hay importaciones realizadas</p>
                </div>
            </div>
        </section>

        <div id="loading" class="loading" style="display: none;"><div class="spinner"></div></div>
        
        <div id="image-modal" class="image-modal"><span class="image-modal-close" id="image-modal-close-btn">&times;</span><span class="image-modal-nav" id="image-modal-prev">&#10094;</span><img class="image-modal-content" id="modal-image-content"><span class="image-modal-nav" id="image-modal-next">&#10095;</span></div>

        <div id="global-calendar-popup" class="absolute z-50 mt-1 p-3 rounded-md shadow-lg hidden" style="border: 1px solid var(--surface-light); width: 280px; background-color: var(--surface);"><div class="flex justify-between items-center mb-2"><button id="popup-cal-prev-month-btn" class="px-2 py-1 hover:bg-surface-light rounded text-sm"><i class="fas fa-chevron-left"></i></button><div id="popup-cal-current-month-year" class="font-semibold text-sm"></div><button id="popup-cal-next-month-btn" class="px-2 py-1 hover:bg-surface-light rounded text-sm"><i class="fas fa-chevron-right"></i></button></div><div class="grid grid-cols-7 gap-1 text-center text-xs mb-1 text-text-secondary"><div>Lu</div><div>Ma</div><div>Mi</div><div>Ju</div><div>Vi</div><div>Sa</div><div>Do</div></div><div id="popup-cal-days-grid" class="grid grid-cols-7 gap-1 text-center"></div><div class="mt-3 space-y-1"><button id="popup-cal-select-week-btn" class="w-full text-xs py-1.5 px-2 bg-surface-light rounded">Semana del Mes Visible</button><button id="popup-cal-select-month-btn" class="w-full text-xs py-1.5 px-2 bg-surface-light rounded">Mes Visible Completo</button><button id="popup-cal-select-semester-btn" class="w-full text-xs py-1.5 px-2 bg-surface-light rounded">Semestre Actual</button><button id="popup-cal-select-year-btn" class="w-full text-xs py-1.5 px-2 bg-surface-light rounded">Año Actual</button><button id="popup-cal-clear-filter-btn" class="w-full text-xs py-1.5 px-2 bg-red-700 hover:bg-red-600 rounded mt-2">Limpiar Filtro de Fecha</button></div></div>

        <div id="day-detail-modal" class="fixed inset-0 hidden items-center justify-center z-[1002] px-4 py-6"><div class="p-5 rounded-lg shadow-xl w-full max-w-3xl text-text relative flex flex-col max-h-[90vh]"><div class="flex justify-between items-center mb-4 pb-3 border-b border-surface-light"><h3 id="day-modal-title" class="text-xl font-semibold">Trades del DD/MM/YYYY</h3><button id="close-day-modal-icon" class="text-2xl text-text-secondary hover:text-text leading-none -mt-1">&times;</button></div><div class="mb-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-x-4 gap-y-3 text-sm"><div>P&L Total: <span id="day-total-pl-header" class="font-semibold"></span></div><div>Trades Totales: <span id="day-total-trades-header" class="font-semibold"></span></div><div>Win Rate: <span id="day-win-rate-header" class="font-semibold"></span></div><div>Ganadores: <span id="day-winners-header" class="font-semibold"></span></div><div>Perdedores: <span id="day-losers-header" class="font-semibold"></span></div><div>Comisiones: <span id="day-fees-header" class="font-semibold text-red"></span></div><div>Volumen: <span id="day-volume-header" class="font-semibold"></span></div><div class="md:col-span-1">Profit Factor: <span id="day-profit-factor-header" class="font-semibold"></span></div><div class="md:col-span-2 border-t border-surface-light pt-2">P&L Neto (después fees): <span id="day-net-pl-header" class="font-bold"></span></div></div><div class="overflow-y-auto flex-grow mb-4 border border-surface-light rounded-md"><table class="w-full text-left text-sm"><thead class="sticky top-0 bg-surface z-10"><tr><th class="py-2 px-3">Hora Entrada</th><th class="py-2 px-3">Símbolo</th><th class="py-2 px-3">Tipo</th><th class="py-2 px-3">P&L Neto</th><th class="py-2 px-3">Hora Salida</th></tr></thead><tbody id="day-modal-table-body" class="divide-y divide-surface"></tbody></table></div><div class="text-right pt-4 border-t border-surface-light"><button id="close-day-modal-btn" class="primary px-4 py-2">Cerrar</button></div></div></div>
    
        <!-- --- NUEVO: Modal para Detalles de Analytics --- -->
        <div id="analytics-detail-modal">
            <div class="analytics-detail-container">
                <div class="flex justify-between items-start mb-6">
                    <h2 id="analytics-detail-title" class="text-3xl font-bold text-primary">Análisis Detallado</h2>
                    <button id="analytics-detail-close-btn" class="text-3xl text-text-secondary hover:text-text leading-none">&times;</button>
                </div>
                
                <!-- Métricas principales -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6 mb-8">
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">P/L Neto</h3><p id="analytics-detail-pl" class="text-3xl font-bold">$0.00</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Win Rate</h3><p id="analytics-detail-winrate" class="text-3xl font-bold">0%</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Profit Factor</h3><p id="analytics-detail-pf" class="text-3xl font-bold">0.00</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Operaciones</h3><p id="analytics-detail-trades" class="text-3xl font-bold">0</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Comisiones</h3><p id="analytics-detail-fees" class="text-3xl font-bold text-red">$0.00</p></div>
                </div>

                <!-- Gráficos y Métricas Avanzadas -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div class="metric-card lg:col-span-1">
                        <h3 class="text-lg font-semibold mb-3">Estadísticas Clave</h3>
                        <dl class="space-y-3 text-sm">
                            <div class="flex justify-between"><dt>Ganancia Promedio:</dt><dd id="analytics-detail-avg-win" class="font-semibold text-green">$0.00</dd></div>
                            <div class="flex justify-between"><dt>Pérdida Promedio:</dt><dd id="analytics-detail-avg-loss" class="font-semibold text-red">$0.00</dd></div>
                            <div class="flex justify-between"><dt>Comisión Promedio:</dt><dd id="analytics-detail-avg-fee" class="font-semibold text-yellow">$0.00</dd></div>
                            <div class="flex justify-between"><dt>Ratio G/P Promedio:</dt><dd id="analytics-detail-w-l-ratio" class="font-semibold">0.00</dd></div>
                            <div class="flex justify-between"><dt>Mayor Ganancia:</dt><dd id="analytics-detail-largest-win" class="font-semibold text-green">$0.00</dd></div>
                            <div class="flex justify-between"><dt>Mayor Pérdida:</dt><dd id="analytics-detail-largest-loss" class="font-semibold text-red">$0.00</dd></div>
                            <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="analytics-detail-drawdown" class="font-semibold text-red">$0.00</dd></div>
                            <div class="flex justify-between border-t border-surface-light pt-2 mt-2"><dt class="font-bold">P/L Neto (después fees):</dt><dd id="analytics-detail-net-pl" class="font-bold text-green">$0.00</dd></div>
                        </dl>
                    </div>
                     <div class="metric-card lg:col-span-2">
                        <h3 class="text-lg font-semibold mb-2">Puntuación de Rendimiento</h3>
                        <div class="chart-container" style="height: 250px;">
                            <canvas id="analytics-detail-radar-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Más Gráficos -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Rendimiento por Instrumento</h3>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="analytics-detail-instrument-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Rendimiento Long vs Short</h3>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="analytics-detail-long-short-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Tabla de Operaciones -->
                <div class="metric-card p-0">
                    <h3 class="text-lg font-semibold p-4">Operaciones del Período</h3>
                    <div class="overflow-y-auto max-h-96">
                        <table class="w-full text-sm">
                            <thead>
                                <tr>
                                    <th>Fecha</th>
                                    <th>Instrumento</th>
                                    <th>Tipo</th>
                                    <th>Entrada</th>
                                    <th>Salida</th>
                                    <th>Volumen</th>
                                    <th>P&L</th>
                                </tr>
                            </thead>
                            <tbody id="analytics-detail-table-body">
                                <!-- Las operaciones se insertarán aquí -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Variables globales para autenticación
        let currentUser = null;
        let isSyncing = false;
        
        const dexieDB = new Dexie('TraderSurvivorDB');
        
        // Versión 7: Esquema original
        dexieDB.version(7).stores({
            accounts: 'id,name,currency,platform',
            operations: 'id,date,accountId,instrument,result,currency', 
            finances: '++id,date',
            generalData: 'key',
            apiKeys: 'id'
        });
        
        // Versión 8: Asegurar que apiKeys existe con el esquema correcto
        dexieDB.version(8).stores({
            accounts: 'id,name,currency,platform',
            operations: 'id,date,accountId,instrument,result,currency', 
            finances: '++id,date',
            generalData: 'key',
            apiKeys: 'id,platform,key,secret'
        });

        const DB = {
            accounts: [],
            operations: [],
            finances: [], 
            settings: { showTooltips: true, defaultCurrency: 'USD' },
            apiKeys: { ctrader: {}, bingx: {}, bitget: {}, mexc: {} }
        };

        let globalDateFilter = { type: 'all', startDate: null, endDate: null, display: 'Sin filtro de fecha' };
        let popupCalendarStateDate = new Date();
        const monthNamesShort = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        let currentEditingOpImages = [];
        let modalImageList = [];
        let modalImageIndex = 0;
        // NUEVO: Estado para el ordenamiento de la tabla de operaciones
        let operationSortState = { column: 'date', order: 'desc' };


        async function loadData() {
            showLoading(true);
            try {
                const [accounts, operations, finances, storedSettings, storedApiKeys] = await Promise.all([
                    dexieDB.accounts.toArray(),
                    dexieDB.operations.toArray(),
                    dexieDB.finances.toArray(), 
                    dexieDB.generalData.get('settings').then(result => result?.value),
                    dexieDB.generalData.get('apiKeys').then(result => result?.value)
                ]);

                DB.accounts = accounts || [];
                DB.operations = operations || [];
                DB.finances = finances || []; 

                if (storedSettings) {
                    DB.settings = { ...{ darkMode: true, showTooltips: true, autoRefresh: false, defaultCurrency: 'USD' }, ...storedSettings };
                } else {
                    await dexieDB.generalData.put({ key: 'settings', value: DB.settings });
                }
                
                // Verificar localStorage primero antes de cargar desde DB
                const localBingXApiKey = localStorage.getItem('bingx-api-key');
                const localBingXSecretKey = localStorage.getItem('bingx-secret-key');
                const localBingXAccountId = localStorage.getItem('bingx-account-id');
                
                if (storedApiKeys) {
                    DB.apiKeys = { 
                        ...{ 
                            ctrader: { key: '', secret: '', accountId: '' }, 
                            bingx: { key: '', secret: '', accountId: '' },
                            bitget: { key: '', secret: '', passphrase: '', accountId: '' }
                        }, 
                        ...storedApiKeys 
                    };
                    
                    // Si hay credenciales en localStorage, priorizarlas sobre las de DB
                    if (localBingXApiKey && localBingXSecretKey) {
                        DB.apiKeys.bingx = {
                            key: localBingXApiKey,
                            secret: localBingXSecretKey,
                            accountId: localBingXAccountId || 'main',
                            mode: 'real'
                        };
                        // Actualizar DB con las credenciales de localStorage
                        await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
                    }
                } else {
                    // Si no hay datos en DB, verificar localStorage
                    if (localBingXApiKey && localBingXSecretKey) {
                        DB.apiKeys.bingx = {
                            key: localBingXApiKey,
                            secret: localBingXSecretKey,
                            accountId: localBingXAccountId || 'main',
                            mode: 'real'
                        };
                    }
                    await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
                }


                let operationsToUpdateInDB = [];
                DB.operations.forEach(op => {
                    let changes = {};
                    let hasChanged = false;

                    if (op.date && op.date.includes('/')) {
                        const parts = op.date.split('/');
                        if (parts.length === 3) {
                            op.date = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                            changes.date = op.date;
                            hasChanged = true;
                        }
                    }
                    if (typeof op.imageData !== 'undefined' && op.imageData !== null) {
                        if (typeof op.imageDatas === 'undefined' || !Array.isArray(op.imageDatas) || op.imageDatas.length === 0) {
                            op.imageDatas = [op.imageData];
                            changes.imageDatas = op.imageDatas;
                            changes.imageData = Dexie.delete; // Eliminar la propiedad antigua
                            hasChanged = true;
                        }
                        delete op.imageData; 
                    } else if (typeof op.imageDatas === 'undefined' || !Array.isArray(op.imageDatas)) {
                         op.imageDatas = []; 
                         changes.imageDatas = [];
                         if (typeof op.imageData !== 'undefined') {
                            changes.imageData = Dexie.delete;
                            delete op.imageData;
                         }
                         hasChanged = true;
                    }

                    if (typeof op.manualPL === 'undefined') {op.manualPL = null; changes.manualPL = null; hasChanged = true;}
                    if (typeof op.entryTime === 'undefined') {op.entryTime = null; changes.entryTime = null; hasChanged = true;}
                    if (typeof op.exitTime === 'undefined') {op.exitTime = null; changes.exitTime = null; hasChanged = true;}
                    // Añadir migración para el nuevo campo 'session'
                    if (typeof op.session === 'undefined') {op.session = null; changes.session = null; hasChanged = true;}
                    
                    if(hasChanged) {
                        operationsToUpdateInDB.push({key: op.id, changes: changes});
                    }
                });

                if (operationsToUpdateInDB.length > 0) {
                    await dexieDB.operations.bulkUpdate(operationsToUpdateInDB);
                }


            } catch (e) {
                console.error('Error loading data from DexieDB:', e);
            } finally {
                showLoading(false);
            }
        }
        


        function updateAccountBalances() {
            DB.accounts.forEach(account => {
                account.balance = account.initialBalance;
                const accountOps = DB.operations.filter(op => op.accountId === account.id);
                accountOps.forEach(operation => {
                    let pl = operation.pl;
                    if (operation.currency !== account.currency) {
                        pl = convertCurrency(pl, operation.currency, account.currency);
                    }
                    account.balance += pl;
                });
                account.balance = Math.round(account.balance * 100) / 100;
            });
        }

        function convertCurrency(amount, fromCurrency, toCurrency) {
            // Mapeo de monedas comunes a sus equivalentes principales
            const currencyMapping = {
                'USDT': 'USD',
                'USDC': 'USD',
                'DAI': 'USD',
                'BUSD': 'USD',
                'TUSD': 'USD'
            };
            
            const rates = { 
                'USD_EUR': 0.92, 
                'EUR_USD': 1.09,
                'USD_USDT': 1.0,
                'USDT_USD': 1.0,
                'USD_USDC': 1.0,
                'USDC_USD': 1.0
            };
            
            // Validar y limpiar parámetros
            if (!fromCurrency || !toCurrency || typeof fromCurrency !== 'string' || typeof toCurrency !== 'string') {
                return amount || 0;
            }
            
            // Normalizar monedas
            const normalizedFrom = currencyMapping[fromCurrency.toUpperCase()] || fromCurrency.toUpperCase();
            const normalizedTo = currencyMapping[toCurrency.toUpperCase()] || toCurrency.toUpperCase();
            
            if (normalizedFrom === normalizedTo) return amount || 0;
            
            const rateKey = `${normalizedFrom}_${normalizedTo}`;
            if (rates[rateKey]) return (amount || 0) * rates[rateKey];
            
            // Solo mostrar warning si las monedas no son equivalentes conocidas
            if (!currencyMapping[fromCurrency] && !currencyMapping[toCurrency]) {
                console.warn(`Tasa de conversión no encontrada para ${fromCurrency} a ${toCurrency}. Usando 1:1.`);
            }
            
            return amount || 0;
        }

        // Función para validar datos de operaciones
        function isValidOperation(op) {
            if (!op) return false;
            if (!op.instrument || typeof op.instrument !== 'string') return false;
            if (!op.currency || typeof op.currency !== 'string') return false;
            if (typeof op.pl !== 'number' || isNaN(op.pl)) return false;
            if (!op.date) return false;
            return true;
        }

        // Función para mostrar notificaciones de sincronización
        function showSyncNotification(message, type = 'success') {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : '#ef4444';
            const icon = type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : 'times-circle';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                z-index: 9999;
                font-size: 14px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                max-width: 350px;
                animation: slideInRight 0.3s ease-out;
            `;
            
            notification.innerHTML = `<i class="fas fa-${icon} mr-2"></i>${message}`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function formatCurrency(amount, baseCurrency = null, displayCurrency = null) {
            const currencyToDisplay = displayCurrency || document.querySelector('input[name="currency"]:checked').value;

            if (amount === 0 || typeof amount === 'undefined' || amount === null) {
                return currencyToDisplay === '%' ? '0.00%' : currencyToDisplay === 'EUR' ? '€0.00' : '$0.00';
            }
            const amountActualCurrency = baseCurrency || DB.settings.defaultCurrency;

            if (currencyToDisplay === '%') {
                const activeTab = document.querySelector('.nav-tab.active')?.dataset.target;
                let accountSelectId;
                if (activeTab === 'dashboard') accountSelectId = 'dashboard-account-select';
                else if (activeTab === 'analytics') accountSelectId = 'analytics-account-select';
                else if (activeTab === 'calendar') accountSelectId = 'calendar-account-select';

                if (!accountSelectId) return (amount > 0 ? '+' : '') + amount.toFixed(2);

                const selectedAccountFilterInput = document.getElementById(accountSelectId);
                const selectedAccountFilter = selectedAccountFilterInput ? selectedAccountFilterInput.value : 'all';

                let initialBalanceInDefault = 0;
                if (selectedAccountFilter === 'all') {
                    initialBalanceInDefault = DB.accounts.reduce((sum, acc) => {
                        let balance = acc.initialBalance;
                        if (acc.currency !== DB.settings.defaultCurrency) {
                            balance = convertCurrency(balance, acc.currency, DB.settings.defaultCurrency);
                        }
                        return sum + balance;
                    }, 0);
                } else {
                    const foundAccount = DB.accounts.find(a => a.id === selectedAccountFilter);
                    if (foundAccount) {
                        initialBalanceInDefault = foundAccount.initialBalance;
                        if (foundAccount.currency !== DB.settings.defaultCurrency) {
                            initialBalanceInDefault = convertCurrency(initialBalanceInDefault, foundAccount.currency, DB.settings.defaultCurrency);
                        }
                    }
                }
                if (initialBalanceInDefault === 0) return '0.00%';

                let amountInDefault = amount;
                if (amountActualCurrency !== DB.settings.defaultCurrency) {
                    amountInDefault = convertCurrency(amount, amountActualCurrency, DB.settings.defaultCurrency);
                }
                const percentage = (amountInDefault / initialBalanceInDefault) * 100;
                return percentage.toFixed(2) + '%';
            }

            let displayAmount = amount;
            if (amountActualCurrency !== currencyToDisplay) {
                displayAmount = convertCurrency(amount, amountActualCurrency, currencyToDisplay);
            }
            const options = { minimumFractionDigits: 2, maximumFractionDigits: 2 };
            if (currencyToDisplay === 'EUR') {
                return '€' + displayAmount.toLocaleString('es-ES', options);
            } else {
                return '$' + displayAmount.toLocaleString('en-US', options);
            }
        }


        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        function formatDate(dateString) {
            if (!dateString) return '';
            try {
                // Crear la fecha como fecha local en lugar de UTC
                const date = dateString.includes('T') ? new Date(dateString) : new Date(dateString + 'T00:00:00');
                if (isNaN(date.getTime())) return dateString;
                
                // Usar métodos locales en lugar de UTC
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            } catch (e) {
                console.warn("Error formatting date:", dateString, e);
                return dateString;
            }
        }

        function formatPlatformName(platformValue) {
            const names = {
                'meta-trader-4': 'Meta Trader 4',
                'meta-trader-5': 'Meta Trader 5',
                'tradelocker': 'TradeLocker',
                'ctrader': 'cTrader',
                'tradingview': 'TradingView',
                'bingx': 'BingX',
                'bitget': 'Bitget',
                'primexbt': 'PrimeXBT',
                'bitunix': 'Bitunix',
                'matchtrader': 'Machtrader',
                'other': 'Otra'
            };
            return names[platformValue] || platformValue;
        }

        function getPlatformLogo(platformValue) {
            const logos = {
                'bingx': { 
                    file: 'bingx-logo.png', 
                    color: '#1E90FF', 
                    initials: 'BX' 
                },
                'bitget': { 
                    file: 'bitget-logo.png', 
                    color: '#00F0FF', 
                    initials: 'BG' 
                },
                'primexbt': { 
                    file: 'primexbt-logo.png', 
                    color: '#0066FF', 
                    initials: 'PX' 
                },
                'bitunix': { 
                    file: 'bitunix-logo.png', 
                    color: '#FF6B00', 
                    initials: 'BU' 
                },
                'mexc': { 
                    file: 'mexc-logo.png', 
                    color: '#00D4AA', 
                    initials: 'MX' 
                },
                'binance': { 
                    file: 'binance-logo.png', 
                    color: '#F3BA2F', 
                    initials: 'BN' 
                },
                'meta-trader-5': { 
                    file: 'metatrader5-logo.png', 
                    color: '#1B5E20', 
                    initials: 'MT5' 
                },
                'meta-trader-4': { 
                    file: 'metatrader4-logo.png', 
                    color: '#1B5E20', 
                    initials: 'MT4' 
                },
                'ctrader': { 
                    file: 'ctrader-logo.png', 
                    color: '#00A8E1', 
                    initials: 'CT' 
                },
                'tradingview': { 
                    file: 'tradingview-logo.png', 
                    color: '#2962FF', 
                    initials: 'TV' 
                },
                'tradelocker': { 
                    file: 'tradelocker-logo.png', 
                    color: '#6C63FF', 
                    initials: 'TL' 
                },
                'matchtrader': { 
                    file: 'matchtrader-logo.png', 
                    color: '#FF4757', 
                    initials: 'MT' 
                },
                'other': { 
                    file: '', 
                    color: '#808080', 
                    initials: '?' 
                }
            };
            
            return logos[platformValue] || { file: '', color: '#808080', initials: '?' };
        }


        function getStartDateForRange(range) {
            const endDate = new Date();
            let startDate = new Date();
            switch (range) {
                case '1W': startDate.setDate(endDate.getDate() - 7); break;
                case '1M': startDate.setMonth(endDate.getMonth() - 1); break;
                case '3M': startDate.setMonth(endDate.getMonth() - 3); break;
                case '6M': startDate.setMonth(endDate.getMonth() - 6); break;
                case '1Y': startDate.setFullYear(endDate.getFullYear() - 1); break;
                case 'ALL': default: return null;
            }
            return getLocalDateString(startDate);
        }

        function applyDateFilterToData(dataArray) {
            if (globalDateFilter.type === 'all' || !globalDateFilter.startDate || !globalDateFilter.endDate) {
                return dataArray;
            }
            return dataArray.filter(item => {
                const itemDate = item.date;
                return itemDate >= globalDateFilter.startDate && itemDate <= globalDateFilter.endDate;
            });
        }


        function initDashboard() {
            updateAccountSelect('dashboard-account-select');
            refreshDashboard();
            document.getElementById('dashboard-account-select').addEventListener('change', function() {
                updateSelectorLogo('dashboard-account-select');
                refreshDashboard();
            });
            document.querySelectorAll('input[name="currency"]').forEach(radio => {
                radio.addEventListener('change', refreshDashboard);
            });
        }

        function refreshDashboard() {
            if (!document.getElementById('dashboard').classList.contains('active')) return;
            const selectedAccount = document.getElementById('dashboard-account-select').value;
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;

            let operationsForMetrics = applyDateFilterToData(DB.operations);

            if (selectedAccount !== 'all') {
                operationsForMetrics = operationsForMetrics.filter(op => op.accountId === selectedAccount);
            }

            const metrics = calculateMetrics(operationsForMetrics, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(operationsForMetrics, selectedAccount);
            const totalPL = metrics.totalWin + metrics.totalLoss;

            const balanceEl = document.getElementById('current-balance');
            balanceEl.textContent = formatCurrency(totalPL, DB.settings.defaultCurrency, displayCurrency);
            balanceEl.className = `text-3xl font-bold ${totalPL >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('win-rate').textContent = metrics.winRate.toFixed(0) + '%';
            document.getElementById('profit-factor').textContent = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : "∞";
            document.getElementById('total-trades').textContent = metrics.totalTrades;
            
            document.getElementById('dashboard-total-win').textContent = formatCurrency(metrics.totalWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('dashboard-total-loss').textContent = formatCurrency(metrics.totalLoss, DB.settings.defaultCurrency, displayCurrency);

            const avgWinEl = document.getElementById('dashboard-avg-win');
            avgWinEl.textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);

            const avgLossEl = document.getElementById('dashboard-avg-loss');
            avgLossEl.textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);

            const avgPlEl = document.getElementById('dashboard-avg-pl');
            avgPlEl.textContent = formatCurrency(advancedMetrics.avgPLPerTrade, DB.settings.defaultCurrency, displayCurrency);
            avgPlEl.className = `text-2xl font-bold ${advancedMetrics.avgPLPerTrade >= 0 ? 'text-white' : 'text-negative'}`;

            const activeRangeButton = document.querySelector('#dashboard .time-range-btn.active');
            const timeRange = activeRangeButton ? activeRangeButton.dataset.range : 'ALL';

            let opsForEvolutionChart = applyDateFilterToData(DB.operations);
            if (selectedAccount !== 'all') {
                opsForEvolutionChart = opsForEvolutionChart.filter(op => op.accountId === selectedAccount);
            }
            updateAccountEvolutionChart(opsForEvolutionChart, selectedAccount, timeRange);

            updateDashboardRadarChart(operationsForMetrics, selectedAccount);
            updateInstrumentPerformanceChart(operationsForMetrics, 'instrument-performance-chart');
            updateDayPerformanceChart(operationsForMetrics, 'day-performance-chart');
            updateTypePerformanceChart(operationsForMetrics, 'type-performance-chart');
        }
        function calculateMetrics(operations, accountId = 'all') {
            let currentBalance = 0;
            let initialBalance = 0;
            let accountCurrency = DB.settings.defaultCurrency;
            let totalWin = 0;
            let totalLoss = 0;
            let winningTrades = 0;
            let losingTrades = 0;
            let breakevenTrades = 0;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    currentBalance = account.balance;
                    initialBalance = account.initialBalance;
                    accountCurrency = account.currency;
                }
            } else {
                DB.accounts.forEach(account => {
                    let accBalance = account.balance;
                    let accInitialBalance = account.initialBalance;
                    if (account.currency !== DB.settings.defaultCurrency) {
                        accBalance = convertCurrency(accBalance, account.currency, DB.settings.defaultCurrency);
                        accInitialBalance = convertCurrency(accInitialBalance, account.currency, DB.settings.defaultCurrency);
                    }
                    currentBalance += accBalance;
                    initialBalance += accInitialBalance;
                });
                accountCurrency = DB.settings.defaultCurrency;
            }

            operations.forEach(op => {
                let plInDefaultCurrency = op.pl;
                let feesInDefaultCurrency = op.fees || 0;
                
                if (op.currency !== DB.settings.defaultCurrency) {
                    plInDefaultCurrency = convertCurrency(plInDefaultCurrency, op.currency, DB.settings.defaultCurrency);
                    feesInDefaultCurrency = convertCurrency(feesInDefaultCurrency, op.currency, DB.settings.defaultCurrency);
                }

                // Restar fees del P&L para obtener el resultado neto
                const netPL = plInDefaultCurrency - feesInDefaultCurrency;

                if (op.result === 'win') {
                    totalWin += netPL;
                    winningTrades++;
                } else if (op.result === 'loss') {
                    totalLoss += netPL;
                    losingTrades++;
                } else if (op.result === 'breakeven') {
                    breakevenTrades++;
                }
            });

            const totalTrades = operations.length;
            const relevantTradesForWinRate = winningTrades + losingTrades;
            const winRate = relevantTradesForWinRate > 0 ? (winningTrades / relevantTradesForWinRate) * 100 : 0;
            const profitFactor = Math.abs(totalLoss) > 0 ? Math.abs(totalWin / totalLoss) : (totalWin > 0 ? Infinity : 0);

            return {
                currentBalance, initialBalance, accountCurrency,
                totalWin,
                totalLoss,
                winningTrades, losingTrades, breakevenTrades, totalTrades,
                winRate, profitFactor
            };
        }

        let accountEvolutionChart = null;
        function updateAccountEvolutionChart(allAccountOps, accountId, timeRange = 'ALL') {
            const ctx = document.getElementById('account-evolution-chart').getContext('2d');
            if (accountEvolutionChart) accountEvolutionChart.destroy();
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;

            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            chartOps = [...chartOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || "00:00:00")) - new Date(b.date + 'T' + (b.entryTime || "00:00:00")));

            let startingBalance = 0;
            let chartTargetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;
            let initialBalanceForPercentCalc = 0;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    startingBalance = account.initialBalance;
                    initialBalanceForPercentCalc = convertCurrency(account.initialBalance, account.currency, chartTargetCurrency);
                    if (account.currency !== chartTargetCurrency) {
                        startingBalance = convertCurrency(startingBalance, account.currency, chartTargetCurrency);
                    }
                    const operationsBeforeChartRange = DB.operations.filter(op =>
                        op.accountId === accountId &&
                        op.date < (chartOps.length > 0 ? chartOps[0].date : getLocalDateString(new Date())) &&
                        (!globalDateFilter.startDate || op.date >= globalDateFilter.startDate)
                    );
                    operationsBeforeChartRange.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== chartTargetCurrency) {
                            pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                        }
                        startingBalance += pl;
                    });
                }
            } else {
                startingBalance = DB.accounts.reduce((sum, acc) => {
                    let accEffectiveInitialBalance = acc.initialBalance;
                    const opsBeforeRangeForThisAccount = DB.operations.filter(op =>
                        op.accountId === acc.id &&
                        op.date < (chartOps.length > 0 ? chartOps[0].date : getLocalDateString(new Date())) &&
                        (!globalDateFilter.startDate || op.date >= globalDateFilter.startDate)
                    );
                    opsBeforeRangeForThisAccount.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== acc.currency) {
                            pl = convertCurrency(pl, op.currency, acc.currency);
                        }
                        accEffectiveInitialBalance += pl;
                    });
                    if (acc.currency !== chartTargetCurrency) {
                        accEffectiveInitialBalance = convertCurrency(accEffectiveInitialBalance, acc.currency, chartTargetCurrency);
                    }
                    return sum + accEffectiveInitialBalance;
                }, 0);

                initialBalanceForPercentCalc = DB.accounts.reduce((sum, acc) => {
                    let iBalance = acc.initialBalance;
                    if (acc.currency !== chartTargetCurrency) {
                        iBalance = convertCurrency(iBalance, acc.currency, chartTargetCurrency);
                    }
                    return sum + iBalance;
                }, 0);
            }

            const labels = ['Inicio'];
            const dataPoints = [startingBalance];
            chartOps.reduce((balance, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newBalance = balance + pl;
                dataPoints.push(newBalance);
                labels.push(formatDate(op.date));
                return newBalance;
            }, startingBalance);

            const finalData = displayCurrency === '%' && initialBalanceForPercentCalc !== 0
                ? dataPoints.map(val => ((val / initialBalanceForPercentCalc) * 100) - 100)
                : dataPoints;

            const yAxisFormatter = displayCurrency === '%'
                ? (val) => (val > 0 ? '+' : '') + val.toFixed(1) + '%'
                : (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency);

            accountEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets: [{ label: 'Balance', data: finalData, borderColor: '#FFFFFF', backgroundColor: 'rgba(255, 255, 255, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0, pointHoverRadius: 5, pointHoverBackgroundColor: '#FFFFFF' }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `Balance: ${yAxisFormatter(c.raw)}` } } }, scales: { x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: yAxisFormatter }, zeroLineColor: '#2a2a2a' } } }
            });
        }

        let dashboardRadarChart = null;
        function updateDashboardRadarChart(operations, accountId, chartId = 'dashboard-radar-chart') {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            // Destruir el gráfico existente basado en el ID del canvas
            if (chartId === 'dashboard-radar-chart' && dashboardRadarChart) {
                dashboardRadarChart.destroy();
            } else if (chartId === 'analytics-detail-radar-chart' && window.analyticsDetailRadarChart) {
                window.analyticsDetailRadarChart.destroy();
            }

            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);

            let maxDrawdownPercentage = 0;
            if (operations.length > 0) {
                const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                let accountInitialBalance = 0;
                let accountCurrency = DB.settings.defaultCurrency;

                if (accountId !== 'all') {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) {
                        accountInitialBalance = account.initialBalance;
                        accountCurrency = account.currency;
                    }
                } else {
                    accountInitialBalance = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency), 0);
                }

                if (accountInitialBalance > 0) {
                    let peakBalance = accountInitialBalance;
                    let maxDrawdownValue = 0;
                    let currentBalance = accountInitialBalance;
                    sortedOps.forEach(op => {
                        let pl = convertCurrency(op.pl, op.currency, accountCurrency);
                        currentBalance += pl;
                        if (currentBalance > peakBalance) peakBalance = currentBalance;
                        const drawdown = peakBalance - currentBalance;
                        if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
                    });
                    maxDrawdownPercentage = (maxDrawdownValue / accountInitialBalance) * 100;
                }
            }


            const winRateScore = basicMetrics.winRate || 0;
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3, 1) * 100; // PF of 3.0 is 100%
            const avgWLRatio = advancedMetrics.avgWin && advancedMetrics.avgLoss ? Math.abs(advancedMetrics.avgWin / advancedMetrics.avgLoss) : 0;
            const avgWLRatioScore = Math.min(avgWLRatio / 3, 1) * 100; // Ratio of 3.0 is 100%
            const drawdownScore = Math.max(0, (1 - Math.min(maxDrawdownPercentage / 20, 1)) * 100); // 20% DD is 0 score

            let consistencyScore = 0;
            if (operations.length > 1) {
                const tradingDays = new Set(operations.map(op => op.date));
                if (tradingDays.size > 0) {
                    const dailyPL = {};
                    operations.forEach(op => {
                        if (!dailyPL[op.date]) dailyPL[op.date] = 0;
                        const plInDefaultCurrency = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                        const feesInDefaultCurrency = convertCurrency(op.fees || 0, op.currency, DB.settings.defaultCurrency);
                        dailyPL[op.date] += plInDefaultCurrency - feesInDefaultCurrency;
                    });
                    const winningDays = Object.values(dailyPL).filter(pl => pl > 0).length;
                    consistencyScore = (winningDays / tradingDays.size) * 100;
                }
            }
            
            const radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                    datasets: [{
                        label: 'Puntuación',
                        data: [winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore],
                        fill: true,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: 'rgba(57, 255, 20, 0.8)',
                        pointBackgroundColor: 'var(--primary)',
                        pointBorderColor: '#0a0a0a',
                        pointHoverBackgroundColor: '#FFFFFF',
                        pointHoverBorderColor: 'var(--primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            angleLines: { color: '#2a2a2a' },
                            grid: { color: '#2a2a2a' },
                            pointLabels: { color: '#FFFFFF', font: { size: 11 } },
                            ticks: { display: false, stepSize: 20 }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // Asignar la nueva instancia de gráfico a la variable correcta
            if (chartId === 'dashboard-radar-chart') {
                dashboardRadarChart = radarChart;
            } else if (chartId === 'analytics-detail-radar-chart') {
                window.analyticsDetailRadarChart = radarChart;
            }
        }

        let instrumentPerformanceChart = null;
        let analyticsInstrumentPerformanceChart = null;
        function updateInstrumentPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (chartId === 'instrument-performance-chart' && instrumentPerformanceChart) instrumentPerformanceChart.destroy();
            if (chartId === 'analytics-instrument-performance-chart' && analyticsInstrumentPerformanceChart) analyticsInstrumentPerformanceChart.destroy();
            if (chartId === 'analytics-detail-instrument-chart' && window.analyticsDetailInstrumentChart) window.analyticsDetailInstrumentChart.destroy();

            const performance = {};
            operations.forEach(op => {
                // Validar que el instrumento existe
                if (!op.instrument || typeof op.instrument !== 'string') {
                    console.warn('Operación con instrumento inválido encontrada:', op);
                    return;
                }
                const instrumentKey = op.instrument.toUpperCase();
                if (!performance[instrumentKey]) performance[instrumentKey] = { total: 0 };
                const plInDefaultCurrency = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                const feesInDefaultCurrency = convertCurrency(op.fees || 0, op.currency, DB.settings.defaultCurrency);
                performance[instrumentKey].total += plInDefaultCurrency - feesInDefaultCurrency;
            });
            const sorted = Object.entries(performance).sort((a, b) => b[1].total - a[1].total).slice(0, 10);
            const chart = new Chart(ctx, { type: 'bar', data: { labels: sorted.map(item => item[0]), datasets: [{ data: sorted.map(item => item[1].total), backgroundColor: sorted.map(item => item[1].total >= 0 ? 'rgba(57, 255, 20, 0.7)' : 'rgba(255, 65, 54, 0.7)') }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }, y: { grid: { display: false }, ticks: { color: '#FFFFFF' } } } } });
            
            if (chartId === 'instrument-performance-chart') instrumentPerformanceChart = chart;
            else if (chartId === 'analytics-instrument-performance-chart') analyticsInstrumentPerformanceChart = chart;
            else if (chartId === 'analytics-detail-instrument-chart') window.analyticsDetailInstrumentChart = chart;

        }

        let dayPerformanceChart = null;
        function updateDayPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (dayPerformanceChart) dayPerformanceChart.destroy();
            const days = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const performance = Array(7).fill(0);
            operations.forEach(op => { 
                if (!isValidOperation(op)) return;
                const day = new Date(op.date + 'T00:00:00').getUTCDay(); 
                const plInDefaultCurrency = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                const feesInDefaultCurrency = convertCurrency(op.fees || 0, op.currency, DB.settings.defaultCurrency);
                performance[day] += plInDefaultCurrency - feesInDefaultCurrency; 
            });
            dayPerformanceChart = new Chart(ctx, { type: 'bar', data: { labels: days, datasets: [{ data: performance, backgroundColor: performance.map(v => v >= 0 ? 'rgba(57, 255, 20, 0.7)' : 'rgba(255, 65, 54, 0.7)') }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { grid: { display: false }, ticks: { color: '#FFFFFF' } }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } } } } });
        }

        let typePerformanceChart = null;
        function updateTypePerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (chartId === 'type-performance-chart' && typePerformanceChart) typePerformanceChart.destroy();
            if (chartId === 'analytics-detail-long-short-chart' && window.analyticsDetailLongShortChart) window.analyticsDetailLongShortChart.destroy();


            const calcPL = (type, result) => operations
                .filter(op => op.type === type && op.result === result)
                .reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);

            const buyWin = calcPL('buy', 'win');
            const buyLoss = calcPL('buy', 'loss');
            const sellWin = calcPL('sell', 'win');
            const sellLoss = calcPL('sell', 'loss');

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Compra (Long)', 'Venta (Short)'],
                    datasets: [
                        {
                            label: 'Ganancias',
                            data: [buyWin, sellWin],
                            backgroundColor: 'rgba(57, 255, 20, 0.7)'
                        },
                        {
                            label: 'Pérdidas',
                            data: [buyLoss, sellLoss],
                            backgroundColor: 'rgba(255, 65, 54, 0.7)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#a0a0a0' } } },
                    scales: {
                        x: { stacked: true, grid: { display: false }, ticks: { color: '#FFFFFF' } },
                        y: { stacked: true, grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }
                    }
                }
            });

            if (chartId === 'type-performance-chart') typePerformanceChart = chart;
            else if (chartId === 'analytics-detail-long-short-chart') window.analyticsDetailLongShortChart = chart;

        }
        
        let financesEvolutionChart = null;
        function updateFinancesEvolutionChart(entries) {
            const ctx = document.getElementById('finances-evolution-chart').getContext('2d');
            if (financesEvolutionChart) financesEvolutionChart.destroy();

            const sortedEntries = [...entries].sort((a, b) => new Date(a.date) - new Date(b.date));
            const chartTargetCurrency = DB.settings.defaultCurrency;

            const labels = ['Inicio'];
            const dataPoints = [0];
            let currentBalance = 0;

            sortedEntries.forEach(entry => {
                let amountInTargetCurrency = entry.amount;
                if (entry.currency !== chartTargetCurrency) {
                    amountInTargetCurrency = convertCurrency(entry.amount, entry.currency, chartTargetCurrency);
                }
                currentBalance += amountInTargetCurrency;
                dataPoints.push(currentBalance);
                labels.push(formatDate(entry.date));
            });

            const yAxisFormatter = (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency);

            financesEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Balance en ${chartTargetCurrency}`,
                        data: dataPoints,
                        borderColor: '#FFFFFF',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => `Balance: ${yAxisFormatter(ctx.raw)}` } } },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#FFFFFF' } },
                        y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: yAxisFormatter } }
                    }
                }
            });
        }
        
        let weeklyTrendChart = null;
        function updateWeeklyTrendChart(weekOperationsData, baseCurrency, initialBalanceForPercent) {
            const ctx = document.getElementById('weekly-trend-chart').getContext('2d'); if (weeklyTrendChart) weeklyTrendChart.destroy();

            const sortedWeeks = Object.values(weekOperationsData).sort((a, b) => parseInt(a.weekNumber) - parseInt(b.weekNumber));
            const labels = sortedWeeks.map(week => 'Sem ' + week.weekNumber);
            const dataPL = sortedWeeks.map(week => week.totalPL);
            const dataTrades = sortedWeeks.map(week => week.count);
            const currencyMode = document.querySelector('input[name="cal-currency"]:checked').value;

            weeklyTrendChart = new Chart(ctx, {
                 type: 'bar', data: { labels: labels, datasets: [{ label: 'P&L', data: dataPL, backgroundColor: dataPL.map(v => v >= 0 ? 'rgba(57, 255, 20, 0.7)' : 'rgba(255, 65, 54, 0.7)'), yAxisID: 'y' }, { label: 'Operaciones', data: dataTrades, type: 'line', fill: false, borderColor: '#a0a0a0', borderWidth: 2, pointRadius: 4, pointBackgroundColor: '#a0a0a0', yAxisID: 'y1' }] },
                 options: { responsive: true, maintainAspectRatio: false, plugins: { legend: {display: false}, tooltip: { enabled: DB.settings.showTooltips, callbacks: { label: (ctx) => { if (ctx.dataset.label === 'P&L') { let fPL; if (currencyMode === '%') { const p = initialBalanceForPercent > 0 ? (ctx.raw / initialBalanceForPercent) * 100 : 0; fPL = p.toFixed(2) + '%'; } else { fPL = formatCurrency(ctx.raw, baseCurrency, currencyMode); } return 'P&L: ' + fPL; } else { return 'Operaciones: ' + ctx.raw; } } } } }, scales: { x: { grid: { display: false }, ticks: { color: '#FFFFFF' } }, y: { position: 'left', grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: (val) => { if (currencyMode === '%') { const p = initialBalanceForPercent > 0 ? (val / initialBalanceForPercent) * 100 : 0; return p.toFixed(1) + '%'; } else { return formatCurrency(val, baseCurrency, currencyMode); } } } }, y1: { position: 'right', grid: { drawOnChartArea: false }, ticks: { color: '#a0a0a0', stepSize: 1 }, min: 0 } } }
            });
        }
        
        let accountDetailChart = null;
        function updateAccountDetailChart(account, allAccountOps, timeRange = 'ALL') {
            const ctx = document.getElementById('account-detail-chart').getContext('2d');
            if (accountDetailChart) accountDetailChart.destroy();
            const chartTargetCurrency = account.currency;

            const startDateString = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
             if (startDateString) {
                 chartOps = allAccountOps.filter(op => op.date >= startDateString);
             }
            chartOps = [...chartOps].sort((a, b) => new Date(a.date + 'T00:00:00Z') - new Date(b.date + 'T00:00:00Z'));

            let startingBalance = account.initialBalance;
            if (startDateString) {
                const opsBeforeRange = DB.operations.filter(op =>
                    op.accountId === account.id && op.date < startDateString
                );
                opsBeforeRange.forEach(op => {
                    let pl = op.pl;
                    if (op.currency !== chartTargetCurrency) {
                        pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                    }
                    startingBalance += pl;
                });
            }

            const labels = ['Inicio'];
            const data = [startingBalance];
            let currentBalance = startingBalance;
            chartOps.forEach(op => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                currentBalance += pl; data.push(currentBalance); labels.push(formatDate(op.date));
            });
            accountDetailChart = new Chart(ctx, {
                type: 'line', data: { labels: labels, datasets: [{ label: 'Balance', data: data, borderColor: '#FFFFFF', backgroundColor: 'rgba(255, 255, 255, 0.1)', borderWidth: 2, fill: true, tension: 0.1, pointRadius: 0 }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { tooltip: { enabled: DB.settings.showTooltips, callbacks: { title: (ctx) => ctx[0].label, label: (ctx) => 'Balance: ' + formatCurrency(ctx.raw, chartTargetCurrency, chartTargetCurrency) } }, legend: { display: false } }, scales: { x: { grid: { display: false }, ticks: { color: '#FFFFFF'} }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) } } } }
            });
        }

        function calculateAdvancedMetrics(operations, accountId = 'all') {
            const metrics = calculateMetrics(operations, accountId);
            let totalPLInDefault = metrics.totalWin + metrics.totalLoss;

            const avgWin = metrics.winningTrades > 0 ? metrics.totalWin / metrics.winningTrades : 0;
            const avgLoss = metrics.losingTrades > 0 ? metrics.totalLoss / metrics.losingTrades : 0;
            const avgPLPerTrade = metrics.totalTrades > 0 ? totalPLInDefault / metrics.totalTrades : 0;

            const lossRateNormalized = (metrics.winningTrades + metrics.losingTrades) > 0 ? metrics.losingTrades / (metrics.winningTrades + metrics.losingTrades) : 0;
            const expectancy = ((metrics.winRate / 100) * avgWin) - (lossRateNormalized * Math.abs(avgLoss));

            let largestWin = 0;
            let largestLoss = 0;
            operations.forEach(op => {
                let plInDefault = op.pl;
                if (op.currency !== DB.settings.defaultCurrency) {
                    plInDefault = convertCurrency(plInDefault, op.currency, DB.settings.defaultCurrency);
                }
                if (op.result === 'win' && plInDefault > largestWin) largestWin = plInDefault;
                if (op.result === 'loss' && plInDefault < largestLoss) largestLoss = plInDefault;
            });

            let longestWinStreak = 0;
            let currentWinStreak = 0;
            let longestLossStreak = 0;
            let currentLossStreak = 0;

            const sortedOpsByDate = [...operations].sort((a,b) => new Date(a.date + 'T00:00:00Z') - new Date(b.date + 'T00:00:00Z'));

            sortedOpsByDate.forEach(op => {
                if (op.result === 'win') {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) longestWinStreak = currentWinStreak;
                } else if (op.result === 'loss') {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) longestLossStreak = currentLossStreak;
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }
            });

            return {
                avgWin, avgLoss, avgPLPerTrade, expectancy,
                largestWin, largestLoss,
                longestWinStreak, longestLossStreak
            };
        }
        
        function calculateExtraAnalytics(operations, accountId = 'all') {
            const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));

            // --- Max Drawdown Calculation ---
            let initialBalanceForDD = 0;
            let currencyForDD = DB.settings.defaultCurrency;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    initialBalanceForDD = account.initialBalance;
                    currencyForDD = account.currency;
                }
            } else {
                initialBalanceForDD = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, currencyForDD), 0);
            }
            
            let peakBalance = initialBalanceForDD;
            let maxDrawdownValue = 0;
            let currentBalance = initialBalanceForDD;
            sortedOps.forEach(op => {
                let pl = convertCurrency(op.pl, op.currency, currencyForDD);
                currentBalance += pl;
                if (currentBalance > peakBalance) peakBalance = currentBalance;
                const drawdown = peakBalance - currentBalance;
                if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
            });
            const maxDrawdownPercentage = initialBalanceForDD > 0 ? (maxDrawdownValue / initialBalanceForDD) * 100 : 0;

            // --- Average Holding Time ---
            let totalDurationMinutes = 0, tradesWithDuration = 0;
            operations.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    try {
                        const startDate = new Date(`1970-01-01T${op.entryTime}`);
                        const endDate = new Date(`1970-01-01T${op.exitTime}`);
                        let duration = (endDate - startDate) / 60000;
                        if (duration < 0) duration += 24 * 60; // Overnight
                        totalDurationMinutes += duration;
                        tradesWithDuration++;
                    } catch (e) { /* ignore */ }
                }
            });
            let avgHoldTimeText = 'N/A';
            if (tradesWithDuration > 0) {
                const avgMinutes = totalDurationMinutes / tradesWithDuration;
                if (avgMinutes < 1) avgHoldTimeText = `${(avgMinutes * 60).toFixed(0)} seg`;
                else if (avgMinutes < 60) avgHoldTimeText = `${avgMinutes.toFixed(0)} min`;
                else avgHoldTimeText = `${Math.floor(avgMinutes / 60)}h ${Math.round(avgMinutes % 60)}m`;
            }

            // --- Standard Deviation of P/L ---
            let stdDevPL = 0;
            if (operations.length > 1) {
                const plsInDefaultCurrency = operations.map(op => convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency));
                const mean = plsInDefaultCurrency.reduce((sum, val) => sum + val, 0) / plsInDefaultCurrency.length;
                const variance = plsInDefaultCurrency.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / plsInDefaultCurrency.length;
                stdDevPL = Math.sqrt(variance);
            }

            // --- Average Win/Loss Ratio ---
            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetricsForRatio = calculateAdvancedMetrics(operations, accountId);
            const avgWLRatio = Math.abs(advancedMetricsForRatio.avgLoss) > 0 ? Math.abs(advancedMetricsForRatio.avgWin / advancedMetricsForRatio.avgLoss) : (advancedMetricsForRatio.avgWin > 0 ? Infinity : 0);

            return {
                maxDrawdownValue, maxDrawdownPercentage, currencyForDD,
                avgHoldTimeText,
                stdDevPL,
                avgWLRatio
            };
        }


        function initAnalytics() {
            updateAccountSelect('analytics-account-select');
            refreshAnalytics();
            document.getElementById('analytics-account-select').addEventListener('change', function() {
                updateSelectorLogo('analytics-account-select');
                refreshAnalytics();
            });
            document.querySelectorAll('input[name="currency"]').forEach(radio => {
                radio.addEventListener('change', refreshAnalytics);
            });
            // NUEVO: Listeners para el modal de detalles
            document.getElementById('analytics-detail-close-btn').addEventListener('click', closeAnalyticsDetailModal);
            document.getElementById('analytics-detail-modal').addEventListener('click', (e) => {
                 if (e.target.id === 'analytics-detail-modal') {
                    closeAnalyticsDetailModal();
                }
            });
        }

        function refreshAnalytics() {
            if (!document.getElementById('analytics').classList.contains('active')) return;
            const selectedAccount = document.getElementById('analytics-account-select').value;
            let operationsForAnalytics = applyDateFilterToData(DB.operations);
            if (selectedAccount !== 'all') {
                operationsForAnalytics = operationsForAnalytics.filter(op => op.accountId === selectedAccount);
            }
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;

            const basicMetrics = calculateMetrics(operationsForAnalytics, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(operationsForAnalytics, selectedAccount);
            const extraMetrics = calculateExtraAnalytics(operationsForAnalytics, selectedAccount);

            // Calcular comisiones totales
            const totalFees = operationsForAnalytics.reduce((sum, op) => {
                const fee = op.fees || 0;
                return sum + convertCurrency(fee, op.currency, DB.settings.defaultCurrency);
            }, 0);
            
            const avgFee = operationsForAnalytics.length > 0 ? totalFees / operationsForAnalytics.length : 0;
            const netPlAfterFees = (basicMetrics.totalWin + basicMetrics.totalLoss) - totalFees;

            const totalPlEl = document.getElementById('analytics-total-pl');
            totalPlEl.textContent = formatCurrency(basicMetrics.totalWin + basicMetrics.totalLoss, DB.settings.defaultCurrency, displayCurrency);
            totalPlEl.className = `text-2xl font-bold ${(basicMetrics.totalWin + basicMetrics.totalLoss) >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('analytics-win-rate').textContent = basicMetrics.winRate.toFixed(0) + '%';
            document.getElementById('analytics-profit-factor').textContent = isFinite(basicMetrics.profitFactor) ? basicMetrics.profitFactor.toFixed(2) : "∞";
            document.getElementById('analytics-total-trades').textContent = basicMetrics.totalTrades;
            
            // Mostrar comisiones
            document.getElementById('analytics-total-fees').textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-avg-fee').textContent = formatCurrency(avgFee, DB.settings.defaultCurrency, displayCurrency);
            
            const feesTotal = document.getElementById('analytics-fees-total');
            feesTotal.textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);
            
            const netPlEl = document.getElementById('analytics-net-pl-after-fees');
            netPlEl.textContent = formatCurrency(netPlAfterFees, DB.settings.defaultCurrency, displayCurrency);
            netPlEl.className = `font-bold ${netPlAfterFees >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('analytics-avg-win').textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-avg-loss').textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);
            
            const avgPlTradeEl = document.getElementById('analytics-avg-pl-trade');
            avgPlTradeEl.textContent = formatCurrency(advancedMetrics.avgPLPerTrade, DB.settings.defaultCurrency, displayCurrency);
            avgPlTradeEl.className = `font-semibold ${advancedMetrics.avgPLPerTrade >= 0 ? 'text-white' : 'text-negative'}`;
            
            const expectancyEl = document.getElementById('analytics-expectancy');
            expectancyEl.textContent = formatCurrency(advancedMetrics.expectancy, DB.settings.defaultCurrency, displayCurrency);
            expectancyEl.className = `font-semibold ${advancedMetrics.expectancy >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('analytics-largest-win').textContent = formatCurrency(advancedMetrics.largestWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-largest-loss').textContent = formatCurrency(advancedMetrics.largestLoss, DB.settings.defaultCurrency, displayCurrency);

            document.getElementById('analytics-longest-win-streak').textContent = advancedMetrics.longestWinStreak;
            document.getElementById('analytics-longest-loss-streak').textContent = advancedMetrics.longestLossStreak;
            document.getElementById('analytics-total-wins-count').textContent = basicMetrics.winningTrades;
            document.getElementById('analytics-total-losses-count').textContent = basicMetrics.losingTrades;
            document.getElementById('analytics-total-breakeven-count').textContent = basicMetrics.breakevenTrades;
            
            // Populate new extra metrics
            document.getElementById('analytics-max-drawdown').textContent = `${formatCurrency(extraMetrics.maxDrawdownValue, extraMetrics.currencyForDD, displayCurrency)} (${extraMetrics.maxDrawdownPercentage.toFixed(1)}%)`;
            const avgWLRatioEl = document.getElementById('analytics-avg-wl-ratio');
            avgWLRatioEl.textContent = isFinite(extraMetrics.avgWLRatio) ? extraMetrics.avgWLRatio.toFixed(2) : "∞";
            avgWLRatioEl.className = `font-semibold ${extraMetrics.avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;
            document.getElementById('analytics-avg-hold-time').textContent = extraMetrics.avgHoldTimeText;
            document.getElementById('analytics-std-dev-pl').textContent = formatCurrency(extraMetrics.stdDevPL, DB.settings.defaultCurrency, displayCurrency);


            populateAnalyticsDailyPerformance(operationsForAnalytics, selectedAccount);
            populateAnalyticsMonthlyPerformance(operationsForAnalytics, selectedAccount);
            updateInstrumentPerformanceChart(operationsForAnalytics, 'analytics-instrument-performance-chart');
            updateHourlyPerformanceChart(operationsForAnalytics, 'analytics-hourly-performance-chart');
        }

        let analyticsHourlyPerformanceChart = null;
        function updateHourlyPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;

            if (analyticsHourlyPerformanceChart) {
                analyticsHourlyPerformanceChart.destroy();
            }

            const hourlyPerformance = Array(24).fill(0);
            operations.forEach(op => {
                if (op.entryTime) {
                    try {
                        const hour = parseInt(op.entryTime.split(':')[0], 10);
                        if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                             hourlyPerformance[hour] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                        }
                    } catch(e) { /* ignore invalid time */ }
                }
            });
            
            const labels = Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}:00`);

            analyticsHourlyPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L por Hora',
                        data: hourlyPerformance,
                        backgroundColor: hourlyPerformance.map(v => v >= 0 ? 'rgba(57, 255, 20, 0.7)' : 'rgba(255, 65, 54, 0.7)')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#FFFFFF', maxRotation: 90, minRotation: 45, autoSkip: true, maxTicksLimit: 12 } },
                        y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }
                    }
                }
            });
        }


        function populateAnalyticsDailyPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-daily-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const daysOfWeek = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const dailyPerformance = daysOfWeek.map(() => ({ pl: 0, trades: 0, wins: 0, losses: 0 }));

            operations.forEach(op => {
                const dayIndex = new Date(op.date + 'T00:00:00Z').getUTCDay();
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                dailyPerformance[dayIndex].pl += plConverted;
                dailyPerformance[dayIndex].trades++;
                if (op.result === 'win') dailyPerformance[dayIndex].wins++;
                if (op.result === 'loss') dailyPerformance[dayIndex].losses++;
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            daysOfWeek.forEach((dayName, index) => {
                const dayData = dailyPerformance[index];
                if (dayData.trades === 0) return; // No mostrar días sin operaciones

                const winRate = (dayData.wins + dayData.losses) > 0 ? (dayData.wins / (dayData.wins + dayData.losses)) * 100 : 0;
                let plDisplay;
                if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((dayData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(dayData.pl, targetCurrency, targetCurrency);
                }
                const plClass = dayData.pl > 0 ? 'text-positive' : (dayData.pl < 0 ? 'text-negative' : 'text-neutral');

                const row = document.createElement('tr');
                row.dataset.dayIndex = index; // Guardar el índice del día
                row.innerHTML = `
                    <td>${dayName}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${dayData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                // NUEVO: Añadir listener para abrir modal
                row.addEventListener('click', () => openAnalyticsDetailModal('dayOfWeek', index, dayName));
                tbody.appendChild(row);
            });
        }

        function populateAnalyticsMonthlyPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-monthly-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const monthlyPerformance = {};

            operations.forEach(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                const monthKey = `${opDate.getUTCFullYear()}-${String(opDate.getUTCMonth() + 1).padStart(2, '0')}`;
                if (!monthlyPerformance[monthKey]) {
                    monthlyPerformance[monthKey] = { pl: 0, trades: 0, wins: 0, losses: 0, year: opDate.getUTCFullYear(), monthIndex: opDate.getUTCMonth() };
                }
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                monthlyPerformance[monthKey].pl += plConverted;
                monthlyPerformance[monthKey].trades++;
                if (op.result === 'win') monthlyPerformance[monthKey].wins++;
                if (op.result === 'loss') monthlyPerformance[monthKey].losses++;
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                 if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            Object.keys(monthlyPerformance).sort().reverse().forEach(monthKey => {
                const monthData = monthlyPerformance[monthKey];
                const winRate = (monthData.wins + monthData.losses) > 0 ? (monthData.wins / (monthData.wins + monthData.losses)) * 100 : 0;
                let plDisplay;
                 if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((monthData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(monthData.pl, targetCurrency, targetCurrency);
                }
                const plClass = monthData.pl > 0 ? 'text-positive' : (monthData.pl < 0 ? 'text-negative' : 'text-neutral');
                const fullMonthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                const monthLabel = `${fullMonthNames[monthData.monthIndex]} ${monthData.year}`;

                const row = document.createElement('tr');
                row.dataset.monthKey = monthKey; // Guardar la clave del mes
                row.innerHTML = `
                    <td>${monthLabel}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${monthData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                // NUEVO: Añadir listener para abrir modal
                row.addEventListener('click', () => openAnalyticsDetailModal('month', monthKey, monthLabel));
                tbody.appendChild(row);
            });
             if (Object.keys(monthlyPerformance).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay datos</td></tr>';
            }
        }
        
        // --- NUEVO: Funciones para el Modal de Detalles de Analytics ---
        function openAnalyticsDetailModal(type, value, titleLabel) {
            const modal = document.getElementById('analytics-detail-modal');
            document.getElementById('analytics-detail-title').textContent = `Análisis de ${titleLabel}`;

            // 1. Filtrar las operaciones
            let periodOperations = [];
            const selectedAccount = document.getElementById('analytics-account-select').value;
            let sourceOps = applyDateFilterToData(DB.operations); // Usar operaciones ya filtradas por fecha global
             if (selectedAccount !== 'all') {
                sourceOps = sourceOps.filter(op => op.accountId === selectedAccount);
            }

            if (type === 'month') {
                const [year, month] = value.split('-');
                periodOperations = sourceOps.filter(op => op.date.startsWith(value));
            } else if (type === 'dayOfWeek') {
                periodOperations = sourceOps.filter(op => new Date(op.date + 'T00:00:00Z').getUTCDay() === value);
            }

            // 2. Calcular Métricas para el período
            const displayCurrency = document.querySelector('input[name="currency"]:checked').value;
            const metrics = calculateMetrics(periodOperations, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(periodOperations, selectedAccount);
            const extraMetrics = calculateExtraAnalytics(periodOperations, selectedAccount);

            const totalPL = metrics.totalWin + metrics.totalLoss;
            
            // Calcular comisiones del período
            const totalFees = periodOperations.reduce((sum, op) => {
                const fee = op.fees || 0;
                return sum + convertCurrency(fee, op.currency, DB.settings.defaultCurrency);
            }, 0);
            const avgFee = periodOperations.length > 0 ? totalFees / periodOperations.length : 0;
            const netPlAfterFees = totalPL - totalFees;

            // 3. Poblar el modal
            const plEl = document.getElementById('analytics-detail-pl');
            plEl.textContent = formatCurrency(totalPL, DB.settings.defaultCurrency, displayCurrency);
            plEl.className = `text-3xl font-bold ${totalPL >= 0 ? 'text-positive' : 'text-negative'}`;
            document.getElementById('analytics-detail-winrate').textContent = `${metrics.winRate.toFixed(1)}%`;
            document.getElementById('analytics-detail-pf').textContent = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : "∞";
            document.getElementById('analytics-detail-trades').textContent = metrics.totalTrades;
            
            // Mostrar comisiones
            document.getElementById('analytics-detail-fees').textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);
            
            const netPlEl = document.getElementById('analytics-detail-net-pl');
            netPlEl.textContent = formatCurrency(netPlAfterFees, DB.settings.defaultCurrency, displayCurrency);
            netPlEl.className = `font-bold ${netPlAfterFees >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('analytics-detail-avg-win').textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-avg-loss').textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-avg-fee').textContent = formatCurrency(avgFee, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-largest-win').textContent = formatCurrency(advancedMetrics.largestWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-largest-loss').textContent = formatCurrency(advancedMetrics.largestLoss, DB.settings.defaultCurrency, displayCurrency);
            
            const wLRatioEl = document.getElementById('analytics-detail-w-l-ratio');
            wLRatioEl.textContent = isFinite(extraMetrics.avgWLRatio) ? extraMetrics.avgWLRatio.toFixed(2) : '∞';
            wLRatioEl.className = `font-semibold ${extraMetrics.avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('analytics-detail-drawdown').textContent = formatCurrency(extraMetrics.maxDrawdownValue, extraMetrics.currencyForDD, displayCurrency);

            // 4. Renderizar Gráficos
            updateDashboardRadarChart(periodOperations, selectedAccount, 'analytics-detail-radar-chart');
            updateInstrumentPerformanceChart(periodOperations, 'analytics-detail-instrument-chart');
            updateTypePerformanceChart(periodOperations, 'analytics-detail-long-short-chart');


            // 5. Poblar tabla de operaciones
            const tableBody = document.getElementById('analytics-detail-table-body');
            tableBody.innerHTML = '';
            periodOperations.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(op => {
                const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
                const precision = getInstrumentPrecision(op.instrument);
                tableBody.innerHTML += `
                    <tr class="cursor-pointer" data-id="${op.id}">
                        <td>${formatDate(op.date)}</td>
                        <td>${op.instrument}</td>
                        <td class="${op.type === 'buy' ? 'text-positive' : 'text-negative'}">${op.type === 'buy' ? 'Long' : 'Short'}</td>
                        <td>${op.entry !== null ? op.entry.toFixed(precision) : '-'}</td>
                        <td>${op.exit !== null ? op.exit.toFixed(precision) : '-'}</td>
                        <td>${op.volume}</td>
                        <td class="${plClass}">${formatCurrency(op.pl, op.currency, op.currency)}</td>
                    </tr>
                `;
            });

            tableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const opId = row.dataset.id;
                    if(opId) {
                        closeAnalyticsDetailModal();
                        showOperationDetailPage(opId);
                    }
                });
            });

            // 6. Mostrar el modal
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Evitar scroll del fondo
        }

        function closeAnalyticsDetailModal() {
            const modal = document.getElementById('analytics-detail-modal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }
        // --- FIN de Funciones para el Modal de Detalles de Analytics ---

        function initFinances() {
            document.getElementById('add-finance-entry-btn').addEventListener('click', () => toggleAddFinanceEntryForm());
            document.getElementById('finance-cancel-btn').addEventListener('click', () => toggleAddFinanceEntryForm());
            document.getElementById('finance-save-btn').addEventListener('click', saveFinanceEntry);
            document.getElementById('finances-table-body').addEventListener('click', handleFinancesTableClick);
            refreshFinancesView();
        }

        function toggleAddFinanceEntryForm(entryToEdit = null) {
            const formContainer = document.getElementById('add-finance-entry-form');
            const isVisible = formContainer.style.display === 'block';

            if (!isVisible) {
                formContainer.style.display = 'block';
                document.getElementById('add-finance-entry-btn').textContent = 'Ocultar Formulario';
                formContainer.querySelector('form').reset();

                if (entryToEdit) {
                    formContainer.querySelector('h3').textContent = 'Editar Movimiento';
                    document.getElementById('finance-date').value = entryToEdit.date;
                    document.getElementById('finance-amount').value = entryToEdit.amount;
                    document.getElementById('finance-currency').value = entryToEdit.currency;
                    document.getElementById('finance-notes').value = entryToEdit.notes;
                    formContainer.dataset.editingId = entryToEdit.id;
                } else {
                    formContainer.querySelector('h3').textContent = 'Nuevo Movimiento Financiero';
                    document.getElementById('finance-date').value = getLocalDateString(new Date());
                    document.getElementById('finance-currency').value = DB.settings.defaultCurrency;
                    delete formContainer.dataset.editingId;
                }
                formContainer.scrollIntoView({ behavior: 'smooth' });
            } else {
                formContainer.style.display = 'none';
                document.getElementById('add-finance-entry-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Añadir Movimiento';
                delete formContainer.dataset.editingId;
            }
        }

        async function saveFinanceEntry() {
            showLoading(true);
            const formContainer = document.getElementById('add-finance-entry-form');
            const editingId = formContainer.dataset.editingId;

            const date = document.getElementById('finance-date').value;
            const amount = parseFloat(document.getElementById('finance-amount').value);
            const currency = document.getElementById('finance-currency').value;
            const notes = document.getElementById('finance-notes').value.trim();

            if (!date || isNaN(amount) || !notes) {
                alert('Por favor, complete todos los campos (Fecha, Monto, Descripción).');
                showLoading(false);
                return;
            }
            
            const entryData = { date, amount, currency, notes };

            try {
                // GUARDAR PRIMERO LOCALMENTE (siempre funciona)
                if (editingId) {
                    await dexieDB.finances.update(parseInt(editingId), entryData);
                    const index = DB.finances.findIndex(f => f.id === parseInt(editingId));
                    if (index !== -1) {
                        DB.finances[index] = { ...DB.finances[index], ...entryData };
                    }
                    console.log('✅ Movimiento financiero actualizado localmente');
                } else {
                    const newId = await dexieDB.finances.add(entryData);
                    entryData.id = newId;
                    DB.finances.push(entryData);
                    console.log('✅ Movimiento financiero guardado localmente');
                }

                // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE (en segundo plano)
                if (currentUser) {
                    saveFinanceToSupabase(entryData).then(() => {
                        console.log('✅ Movimiento financiero guardado exitosamente');
                        showSyncNotification('💾 Movimiento guardado y sincronizado automáticamente', 'success');
                    }).catch((supabaseError) => {
                        console.error('❌ Error de sincronización automática:', supabaseError);
                        addToSyncQueue(entryData, 'finance');
                        showSyncNotification('💾 Movimiento guardado (se sincronizará automáticamente)', 'info');
                    });
                } else {
                    showSyncNotification('💾 Movimiento guardado localmente', 'warning');
                }

                // Actualizar vistas inmediatamente con datos locales
                toggleAddFinanceEntryForm();
                refreshFinancesView();
                
                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Movimiento financiero guardado exitosamente', 'success');
                
            } catch (e) {
                console.error("Error saving finance entry:", e);
                alert("Error al guardar el movimiento financiero.");
            } finally {
                showLoading(false);
            }
        }
        
        async function handleFinancesTableClick(event) {
            const button = event.target.closest('button');
            if (!button) return;

            const entryId = parseInt(button.dataset.id);
            if (isNaN(entryId)) return;

            if (button.classList.contains('edit-finance-btn')) {
                const entry = DB.finances.find(f => f.id === entryId);
                if (entry) toggleAddFinanceEntryForm(entry);
            } else if (button.classList.contains('delete-finance-btn')) {
                if (confirm('¿Estás seguro de que deseas eliminar este movimiento?')) {
                    showLoading(true);
                    try {
                        const entry = DB.finances.find(f => f.id === entryId);
                        await dexieDB.finances.delete(entryId);
                        
                        // Eliminar de Supabase si tiene supabase_id
                        if (entry && entry.supabase_id) {
                            await deleteFinanceFromSupabase(entry.supabase_id);
                        }
                        
                        DB.finances = DB.finances.filter(f => f.id !== entryId);
                        refreshFinancesView();
                    } catch (e) {
                        console.error("Error deleting finance entry:", e);
                        alert("Error al eliminar el movimiento.");
                    } finally {
                        showLoading(false);
                    }
                }
            }
        }
        
        function refreshFinancesView() {
            if (!document.getElementById('finances').classList.contains('active')) return;
            
            const filteredFinances = applyDateFilterToData(DB.finances);
            const filteredOperations = applyDateFilterToData(DB.operations);

            updateFinancePageSummary(filteredFinances, filteredOperations);
            renderFinancesTable(filteredFinances);
            updateFinancesEvolutionChart(filteredFinances);
        }

        function updateFinancePageSummary(financeEntries, tradeOperations) {
            const targetCurrency = DB.settings.defaultCurrency;
            
            let totalIncome = 0;
            let totalExpenses = 0;
            financeEntries.forEach(entry => {
                let amount = convertCurrency(entry.amount, entry.currency, targetCurrency);
                if (amount > 0) totalIncome += amount;
                else totalExpenses += amount;
            });
            const netBalance = totalIncome + totalExpenses;
            const tradingMetrics = calculateMetrics(tradeOperations, 'all');

            const tradingPLEl = document.getElementById('finance-trading-pl');
            tradingPLEl.textContent = formatCurrency(tradingMetrics.totalWin + tradingMetrics.totalLoss, targetCurrency, targetCurrency);
            tradingPLEl.className = `text-xl font-bold ${(tradingMetrics.totalWin + tradingMetrics.totalLoss) >= 0 ? 'text-positive' : 'text-negative'}`;

            document.getElementById('finance-win-rate').textContent = `${tradingMetrics.winRate.toFixed(1)}%`;
            
            document.getElementById('finance-total-income').textContent = formatCurrency(totalIncome, targetCurrency, targetCurrency);
            document.getElementById('finance-total-expenses').textContent = formatCurrency(totalExpenses, targetCurrency, targetCurrency);
            const netBalanceEl = document.getElementById('finance-net-balance');
            netBalanceEl.textContent = formatCurrency(netBalance, targetCurrency, targetCurrency);
            netBalanceEl.className = `text-xl font-bold ${netBalance >= 0 ? 'text-green' : 'text-negative'}`;
        }


        function renderFinancesTable(entries) {
            const tableBody = document.getElementById('finances-table-body');
            tableBody.innerHTML = '';
            
            const sortedEntries = [...entries].sort((a, b) => new Date(b.date) - new Date(a.date));

            if (sortedEntries.length === 0) {
                 tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-text-secondary py-4">No hay movimientos en el período seleccionado.</td></tr>';
                 return;
            }

            sortedEntries.forEach(entry => {
                const amountClass = entry.amount >= 0 ? 'text-positive' : 'text-negative';
                const row = `
                    <tr>
                        <td>${formatDate(entry.date)}</td>
                        <td>${entry.notes}</td>
                        <td class="${amountClass} font-semibold">${formatCurrency(entry.amount, entry.currency, entry.currency)}</td>
                        <td>${entry.currency}</td>
                        <td class="flex items-center justify-center space-x-2">
                            <button class="text-white edit-finance-btn" data-id="${entry.id}" title="Editar"><i class="fas fa-edit"></i></button>
                            <button class="text-red delete-finance-btn" data-id="${entry.id}" title="Eliminar"><i class="fas fa-trash"></i></button>
                        </td>
                    </tr>
                `;
                tableBody.innerHTML += row;
            });
        }

        let currentCalendarDate = new Date();
        
        function initCalendar() {
            updateAccountSelect('calendar-account-select');
            updateCalendar();
            document.getElementById('prev-month').addEventListener('click', () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1); updateCalendar(); });
            document.getElementById('next-month').addEventListener('click', () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1); updateCalendar(); });
            document.getElementById('calendar-account-select').addEventListener('change', function() {
                updateSelectorLogo('calendar-account-select');
                updateCalendar();
            });
            document.querySelectorAll('input[name="cal-currency"]').forEach(radio => { radio.addEventListener('change', updateCalendar); });
        }



        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        }

        updateCalendar = function () {
            if (!document.getElementById('calendar').classList.contains('active')) return;
            const selectedAccount = document.getElementById('calendar-account-select').value;
            const currencyMode = document.querySelector('input[name="cal-currency"]:checked').value;
            const year = currentCalendarDate.getFullYear(); const month = currentCalendarDate.getMonth();

            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));

            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            document.getElementById('current-month').textContent = `${monthNames[month]} ${year}`;

            let monthOperations = DB.operations.filter(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                return opDate.getUTCMonth() === month && opDate.getUTCFullYear() === year && (selectedAccount === 'all' || op.accountId === selectedAccount);
            });

            const dailyData = {}; const weeklyData = {};
            let baseCurrencyForCalc = DB.settings.defaultCurrency;
            let initialBalanceForPercent = 0;

            if (selectedAccount !== 'all') {
                const account = DB.accounts.find(a => a.id === selectedAccount);
                if (account) {
                    baseCurrencyForCalc = account.currency;
                    initialBalanceForPercent = account.initialBalance;
                }
            } else {
                initialBalanceForPercent = DB.accounts.reduce((sum, acc) => {
                    return sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency);
                }, 0);
                baseCurrencyForCalc = DB.settings.defaultCurrency;
            }

            monthOperations.forEach(op => {
                const date = new Date(op.date + 'T00:00:00Z');
                const day = date.getUTCDate();
                const weekNumber = getWeekNumber(date);
                if (!dailyData[day]) dailyData[day] = { operations: [], totalPL: 0, count: 0 };
                if (!weeklyData[weekNumber]) weeklyData[weekNumber] = { operations: [], totalPL: 0, count: 0, weekNumber: weekNumber };

                let pl = op.pl;
                if (op.currency !== baseCurrencyForCalc) {
                    pl = convertCurrency(pl, op.currency, baseCurrencyForCalc);
                }
                dailyData[day].operations.push(op); dailyData[day].totalPL += pl; dailyData[day].count++;
                weeklyData[weekNumber].operations.push(op); weeklyData[weekNumber].totalPL += pl; weeklyData[weekNumber].count++;
            });

            const grid = document.getElementById('calendar-grid'); grid.innerHTML = '';
            const daysInMonth = lastDayOfMonth.getUTCDate();
            const firstDayOfWeekIndex = firstDayOfMonth.getUTCDay();

            for (let i = 0; i < firstDayOfWeekIndex; i++) {
                grid.innerHTML += `<div class="calendar-day empty"></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(Date.UTC(year, month, day));
                const dayOfWeekIndex = currentDate.getUTCDay();
                const dayData = dailyData[day];
                let cellHTML = `<div class="calendar-day `;

                if (dayData) {
                    const isProfit = dayData.totalPL > 0; const isLoss = dayData.totalPL < 0;
                    cellHTML += isProfit ? 'profit' : (isLoss ? 'loss' : '');
                    cellHTML += `" data-day="${day}">`;
                    cellHTML += `<div class="day-number">${day}</div>`;
                    let formattedPL;
                    if (currencyMode === '%') {
                        const percentage = initialBalanceForPercent > 0 ? (dayData.totalPL / initialBalanceForPercent) * 100 : 0;
                        formattedPL = percentage.toFixed(2) + '%';
                    } else {
                        formattedPL = formatCurrency(dayData.totalPL, baseCurrencyForCalc, currencyMode);
                    }
                    cellHTML += `<div class="day-profit ${isProfit ? 'positive' : (isLoss ? 'negative' : '')}">${formattedPL}</div>`;
                    cellHTML += `<div class="day-trades">${dayData.count} op.</div>`;
                } else {
                    cellHTML += `" data-day="${day}">`;
                    cellHTML += `<div class="day-number text-text-secondary">${day}</div>`;
                }
                cellHTML += `</div>`;
                grid.innerHTML += cellHTML;

                if (dayOfWeekIndex === 6) {
                    const weekNumber = getWeekNumber(currentDate);
                    const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                    const isWeekProfit = weekData.totalPL > 0; const isWeekLoss = weekData.totalPL < 0;
                    let formattedWeekPL;
                    if (currencyMode === '%') {
                        const percentage = initialBalanceForPercent > 0 ? (weekData.totalPL / initialBalanceForPercent) * 100 : 0;
                        formattedWeekPL = percentage.toFixed(2) + '%';
                    } else {
                        formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, currencyMode);
                    }
                    grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                          <div class="font-bold text-sm">Sem ${weekData.weekNumber}</div>
                                          <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                          <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                       </div>`;
                }
            }

            if (lastDayOfMonth.getUTCDay() !== 6) {
                for (let i = lastDayOfMonth.getUTCDay() + 1; i <= 6; i++) {
                    grid.innerHTML += `<div class="calendar-day empty"></div>`;
                }
                const weekNumber = getWeekNumber(lastDayOfMonth);
                const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                const isWeekProfit = weekData.totalPL > 0; const isWeekLoss = weekData.totalPL < 0;
                
                let formattedWeekPL;
                if (currencyMode === '%') {
                    const percentage = initialBalanceForPercent > 0 ? (weekData.totalPL / initialBalanceForPercent) * 100 : 0;
                    formattedWeekPL = percentage.toFixed(2) + '%';
                } else {
                    formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, currencyMode);
                }
                grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                      <div class="font-bold text-sm">Sem ${weekData.weekNumber}</div>
                                      <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                      <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                   </div>`;
            }

            grid.querySelectorAll('.calendar-day:not(.empty)').forEach(cell => {
                const dayHasData = dailyData[parseInt(cell.dataset.day)];
                if (dayHasData) {
                    cell.onclick = () => {
                        const day = parseInt(cell.dataset.day, 10); if (isNaN(day)) return;
                        const dateKeyYYYYMMDD = getLocalDateString(new Date(year, month, day));
                        const opsForDay = DB.operations.filter(op => op.date === dateKeyYYYYMMDD && (selectedAccount === 'all' || op.accountId === selectedAccount));
                        let totalPLForDayInModalCurrency = opsForDay.reduce((sum, op) => {
                            let plConverted = op.pl;
                            if (op.currency !== baseCurrencyForCalc) {
                                plConverted = convertCurrency(op.pl, op.currency, baseCurrencyForCalc);
                            }
                            return sum + plConverted;
                        }, 0);
                        openDayDetailModal(dateKeyYYYYMMDD, opsForDay, totalPLForDayInModalCurrency, baseCurrencyForCalc);
                    };
                }
            });

            updateMonthSummary(monthOperations, baseCurrencyForCalc);
            updateWeeklyTrendChart(weeklyData, baseCurrencyForCalc, initialBalanceForPercent);
        };


        function updateMonthSummary(operations, baseCurrency) {
            let totalPL = 0; let tradingDays = 0; let winDays = 0; let loseDays = 0; const dailyPL = {};
            const currencyMode = document.querySelector('input[name="cal-currency"]:checked').value;

            operations.forEach(op => {
                const date = op.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                let pl = op.pl;
                if (op.currency !== baseCurrency) pl = convertCurrency(pl, op.currency, baseCurrency);
                dailyPL[date] += pl;
                totalPL += pl;
            });
            Object.values(dailyPL).forEach(dayPL => { tradingDays++; if (dayPL > 0) winDays++; else if (dayPL < 0) loseDays++; });

            let initialBalanceForPercent = 0;
            const selectedAccount = document.getElementById('calendar-account-select').value;
            if (currencyMode === '%') {
                if (selectedAccount !== 'all') {
                    const account = DB.accounts.find(a => a.id === selectedAccount);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, baseCurrency);
                } else {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, baseCurrency), 0);
                }
            }

            let plDisplay;
            if (currencyMode === '%') {
                plDisplay = initialBalanceForPercent > 0 ? ((totalPL / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                plDisplay = formatCurrency(totalPL, baseCurrency, currencyMode);
            }
            const monthlyPlEl = document.getElementById('monthly-pl');
            monthlyPlEl.textContent = plDisplay;
            monthlyPlEl.className = `text-2xl font-bold ${totalPL >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('monthly-trading-days').textContent = tradingDays;
            document.getElementById('monthly-winning-days').textContent = winDays;
            document.getElementById('monthly-losing-days').textContent = loseDays;
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        // Función global para guardar operaciones
        async function saveOperation() {
            console.log('🔍 INICIO: saveOperation ejecutándose...');
            showLoading(true);
            
            const formContainer = document.getElementById('add-operation-form');
            const editingId = formContainer.dataset.editingId;

            const date = document.getElementById('op-date').value;
            const accountId = document.getElementById('op-account').value;
            const instrument = document.getElementById('op-instrument').value.toUpperCase().trim();
            const type = document.getElementById('op-type').value;
            const entry = parseFloat(document.getElementById('op-entry').value);
            const exit = parseFloat(document.getElementById('op-exit').value);
            const entryTime = document.getElementById('op-entry-time').value;
            const exitTime = document.getElementById('op-exit-time').value;
            const volume = parseFloat(document.getElementById('op-volume').value);
            const currency = document.getElementById('op-currency').value;
            const notes = document.getElementById('op-notes').value.trim();
            const session = document.getElementById('op-session').value.trim();
            const manualPLValue = document.getElementById('op-manual-pl').value;
            const fees = parseFloat(document.getElementById('op-fees').value) || 0;

            const isWinSelected = document.getElementById('op-win-btn').dataset.selected === 'true';
            const isLossSelected = document.getElementById('op-loss-btn').dataset.selected === 'true';

            let result;
            let finalPL;
            let manualPLInputVal = null;

            if (!date || !accountId || !instrument || isNaN(volume) || volume <= 0) {
                alert('Por favor, complete todos los campos obligatorios (Fecha, Cuenta, Instrumento, Volumen > 0).');
                showLoading(false); return;
            }

            if (manualPLValue.trim() !== "") {
                manualPLInputVal = parseFloat(manualPLValue);
                if (isNaN(manualPLInputVal)) {
                    alert('P&L Manual no es un número válido.');
                    showLoading(false); return;
                }
                finalPL = manualPLInputVal;
                if (manualPLInputVal > 0) result = 'win';
                else if (manualPLInputVal < 0) result = 'loss';
                else result = 'breakeven';
            } else {
                if (isNaN(entry) || isNaN(exit)) {
                    alert('Por favor, ingrese precios de Entrada y Salida válidos, o ingrese un P&L Manual.');
                    showLoading(false); return;
                }
                if (entry !== exit && !isWinSelected && !isLossSelected) {
                    alert('Por favor, seleccione si la operación fue Ganancia o Pérdida, o ingrese un P&L Manual.');
                    showLoading(false); return;
                }

                if (entry === exit) {
                    result = 'breakeven';
                    finalPL = 0;
                } else {
                    result = isWinSelected ? 'win' : 'loss';
                    if (type === 'buy') finalPL = (exit - entry) * volume;
                    else finalPL = (entry - exit) * volume;

                    if ((result === 'win' && finalPL <= 0) || (result === 'loss' && finalPL >= 0)) {
                        if (!confirm(`El P&L calculado (${finalPL.toFixed(2)} ${currency}) no coincide con el resultado ('${result}') seleccionado. Si continúa, se guardará con el resultado '${result}' y el P&L calculado. ¿Desea continuar?`)) {
                            showLoading(false); return;
                        }
                    }
                }
            }
            finalPL = parseFloat(finalPL.toFixed(5));

            let operationData = {
                id: editingId || generateId(),
                date, accountId, instrument, type,
                entry: isNaN(entry) ? null : entry,
                exit: isNaN(exit) ? null : exit,
                entryTime, exitTime,
                volume,
                result, pl: finalPL, 
                fees: fees,
                currency, notes,
                imageDatas: [...currentEditingOpImages],
                manualPL: manualPLInputVal,
                session: session
            };

            try {
                // GUARDAR PRIMERO LOCALMENTE (siempre funciona)
                if (editingId) {
                    await dexieDB.operations.update(editingId, operationData);
                    const index = DB.operations.findIndex(op => op.id === editingId);
                    if (index !== -1) {
                        DB.operations[index] = { ...DB.operations[index], ...operationData };
                    }
                    console.log('✅ Operación actualizada localmente');
                } else {
                    await dexieDB.operations.add(operationData);
                    DB.operations.push(operationData);
                    console.log('✅ Operación guardada localmente');
                }

                console.log('🔍 LLEGANDO A SINCRONIZACIÓN...');
                // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                console.log('🔍 currentUser:', currentUser);
                console.log('🔍 ¿Usuario existe?', !!currentUser);
                if (currentUser) {
                    console.log('🔍 Iniciando guardado en Supabase...');
                    // Intentar guardar automáticamente sin bloquear la UI
                    saveOperationToSupabase(operationData).then(() => {
                        console.log('✅ Operación sincronizada automáticamente');
                        showSyncNotification('💾 Operación guardada exitosamente', 'success');
                    }).catch((supabaseError) => {
                        console.error('❌ Error de sincronización automática:', supabaseError);
                        // Guardar en cola de pendientes para reintento posterior
                        addToSyncQueue(operationData, 'operation');
                        showSyncNotification('💾 Operación guardada exitosamente', 'success');
                    });
                } else {
                    // Usuario no autenticado - solo local
                    console.log('⚠️ NO HAY USUARIO - no se guarda en Supabase');
                    showSyncNotification('💾 Operación guardada', 'success');
                    console.log('⚠️ Usuario no autenticado - datos guardados solo localmente');
                }

                // Actualizar vistas inmediatamente con datos locales
                updateAccountBalances();
                toggleAddOperationForm();
                refreshAllViews();
                
                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Operación guardada exitosamente', 'success');
                
            } catch (e) {
                console.error("Error saving operation:", e);
                alert("Error al guardar la operación.");
            } finally {
                showLoading(false);
            }
        }

        function initOperations() {
            updateAccountSelect('op-account');
            updateAccountSelect('filter-account');
            
            document.getElementById('add-operation-btn').addEventListener('click', () => toggleAddOperationForm());
            document.getElementById('op-cancel').addEventListener('click', () => toggleAddOperationForm());
            document.getElementById('op-save').addEventListener('click', saveOperation);
            document.getElementById('filter-account').addEventListener('change', function() {
                updateSelectorLogo('filter-account');
                refreshOperationsTable();
            });
            document.getElementById('filter-instrument').addEventListener('input', refreshOperationsTable);

            // NUEVO: Listener para ordenar la tabla
            document.querySelector('#operations-table-render thead').addEventListener('click', (event) => {
                const header = event.target.closest('th');
                if (!header || !header.dataset.sort) return;

                const column = header.dataset.sort;
                if (operationSortState.column === column) {
                    operationSortState.order = operationSortState.order === 'asc' ? 'desc' : 'asc';
                } else {
                    operationSortState.column = column;
                    operationSortState.order = 'desc';
                }
                refreshOperationsTable();
            });

            const winBtn = document.getElementById('op-win-btn');
            const lossBtn = document.getElementById('op-loss-btn');
            winBtn.addEventListener('click', function () {
                winBtn.classList.add('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.remove('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'true'; lossBtn.dataset.selected = 'false';
            });
            lossBtn.addEventListener('click', function () {
                lossBtn.classList.add('bg-red'); winBtn.classList.remove('bg-green');
                lossBtn.classList.remove('bg-surface-light'); winBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'true';
            });

            const priceInputs = ['op-entry', 'op-exit', 'op-volume', 'op-type', 'op-manual-pl'];
            priceInputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', autoSelectWinLoss);
                    element.addEventListener('change', autoSelectWinLoss);
                }
            });

            document.getElementById('op-manual-pl').addEventListener('input', function () {
                if (this.value.trim() !== "") {
                    const manualPLValue = parseFloat(this.value);
                    if (!isNaN(manualPLValue)) {
                        if (manualPLValue > 0) document.getElementById('op-win-btn').click();
                        else if (manualPLValue < 0) document.getElementById('op-loss-btn').click();
                        else {
                            const winBtn = document.getElementById('op-win-btn');
                            const lossBtn = document.getElementById('op-loss-btn');
                            winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                            winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                            winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                        }
                    }
                } else {
                    autoSelectWinLoss();
                }
            });

            document.getElementById('op-image').addEventListener('change', handleOpImageSelection);
            document.getElementById('operations-table-render').addEventListener('click', handleOperationsTableClick);
            refreshOperationsTable();
        }


        function handleOpImageSelection(event) {
            const files = event.target.files;
            const MAX_IMAGES = 5;

            for (let i = 0; i < files.length; i++) {
                if (currentEditingOpImages.length >= MAX_IMAGES) {
                    alert(`Puedes adjuntar un máximo de ${MAX_IMAGES} imágenes.`);
                    break;
                }
                const file = files[i];
                if (!['image/png', 'image/jpeg', 'image/jpg'].includes(file.type)) {
                    alert('Formato de imagen no válido. Por favor, selecciona PNG, JPG o JPEG.');
                    continue;
                }
                const maxSizeMB = 2;
                if (file.size > maxSizeMB * 1024 * 1024) {
                    alert(`La imagen "${file.name}" es demasiado grande (Máx: ${maxSizeMB}MB).`);
                    continue;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    if (currentEditingOpImages.length < MAX_IMAGES) {
                        currentEditingOpImages.push(e.target.result);
                        renderOpImagePreviews();
                    }
                }
                reader.onerror = function () { alert(`Error al leer la imagen "${file.name}".`); }
                reader.readAsDataURL(file);
            }
            event.target.value = null;
        }

        function renderOpImagePreviews() {
            const container = document.getElementById('op-image-previews-container');
            container.innerHTML = '';
            currentEditingOpImages.forEach((imageDataUrl, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'op-image-preview-item h-20 w-full';
                previewItem.innerHTML = `
                    <img src="${imageDataUrl}" alt="Preview ${index + 1}" class="object-cover h-full w-full">
                    <button type="button" class="op-image-remove-btn" data-index="${index}">&times;</button>
                `;
                container.appendChild(previewItem);
            });

            container.querySelectorAll('.op-image-remove-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const indexToRemove = parseInt(this.dataset.index);
                    currentEditingOpImages.splice(indexToRemove, 1);
                    renderOpImagePreviews();
                });
            });
        }


        function autoSelectWinLoss() {
            const entryPrice = parseFloat(document.getElementById('op-entry').value);
            const exitPrice = parseFloat(document.getElementById('op-exit').value);
            const type = document.getElementById('op-type').value;
            const manualPL = document.getElementById('op-manual-pl').value;

            if (manualPL.trim() !== "") return;

            const winBtn = document.getElementById('op-win-btn');
            const lossBtn = document.getElementById('op-loss-btn');

            if (isNaN(entryPrice) || isNaN(exitPrice) || entryPrice === 0 || exitPrice === 0) {
                winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                return;
            }

            let isWin = false;
            if (type === 'buy' && exitPrice > entryPrice) isWin = true;
            else if (type === 'sell' && entryPrice > exitPrice) isWin = true;

            if (entryPrice === exitPrice) {
                winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                return;
            }

            if (isWin) winBtn.click();
            else lossBtn.click();
        }

        function toggleAddOperationForm(operationToEdit = null) {
            const formContainer = document.getElementById('add-operation-form');
            const isVisible = formContainer.style.display === 'block';
            const imageInput = document.getElementById('op-image');
            const manualPLInput = document.getElementById('op-manual-pl');
            currentEditingOpImages = [];

            if (!isVisible) {
                formContainer.style.display = 'block';
                document.getElementById('add-operation-btn').textContent = 'Ocultar Formulario';
                document.getElementById('operation-details-form').reset();

                if (operationToEdit) {
                    formContainer.querySelector('h3').textContent = 'Editar Operación';
                    document.getElementById('op-date').value = operationToEdit.date;
                    document.getElementById('op-account').value = operationToEdit.accountId;
                    document.getElementById('op-instrument').value = operationToEdit.instrument;
                    document.getElementById('op-type').value = operationToEdit.type;
                    document.getElementById('op-entry').value = operationToEdit.entry;
                    document.getElementById('op-exit').value = operationToEdit.exit;
                    document.getElementById('op-entry-time').value = operationToEdit.entryTime || '';
                    document.getElementById('op-exit-time').value = operationToEdit.exitTime || '';
                    document.getElementById('op-volume').value = operationToEdit.volume;
                    document.getElementById('op-currency').value = operationToEdit.currency;
                    document.getElementById('op-notes').value = operationToEdit.notes;
                    document.getElementById('op-session').value = operationToEdit.session || ''; // Cargar campo Sesión
                    manualPLInput.value = operationToEdit.manualPL !== null && typeof operationToEdit.manualPL !== 'undefined' ? operationToEdit.manualPL : '';

                    if (operationToEdit.imageDatas && Array.isArray(operationToEdit.imageDatas)) {
                        currentEditingOpImages = [...operationToEdit.imageDatas];
                    }
                    renderOpImagePreviews();
                    imageInput.value = '';

                    if (operationToEdit.result === 'win') document.getElementById('op-win-btn').click();
                    else if (operationToEdit.result === 'loss') document.getElementById('op-loss-btn').click();
                    else {
                        const winBtn = document.getElementById('op-win-btn'); const lossBtn = document.getElementById('op-loss-btn');
                        winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                        winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                        winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                    }
                    formContainer.dataset.editingId = operationToEdit.id;
                } else {
                    formContainer.querySelector('h3').textContent = 'Nueva Operación';
                    document.getElementById('op-date').value = getLocalDateString(new Date());
                    document.getElementById('op-account').value = DB.accounts.length > 0 ? DB.accounts[0].id : '';
                    document.getElementById('op-currency').value = DB.settings.defaultCurrency;
                    document.getElementById('op-session').value = ''; // Limpiar campo Sesión
                    renderOpImagePreviews();
                    imageInput.value = '';
                    manualPLInput.value = '';
                    const winBtn = document.getElementById('op-win-btn'); const lossBtn = document.getElementById('op-loss-btn');
                    winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                    winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                    winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                    delete formContainer.dataset.editingId;
                }
                autoSelectWinLoss();
                formContainer.scrollIntoView({ behavior: 'smooth' });
            } else {
                formContainer.style.display = 'none';
                document.getElementById('add-operation-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Añadir Operación';
                delete formContainer.dataset.editingId;
                currentEditingOpImages = [];
                renderOpImagePreviews();
                imageInput.value = '';
                manualPLInput.value = '';
                document.getElementById('operation-details-form').reset();
            }
        }

        // ============================================
        // FUNCIONES DE MÉTRICAS DE OPERACIONES
        // ============================================
        
        function updateOperationsMetrics() {
            try {
                // Validar que DB.operations esté inicializado
                if (!DB || !DB.operations) {
                    console.log('DB.operations no está inicializado aún');
                    return;
                }
                
                // Obtener operaciones filtradas actual
                let operations = [...DB.operations];
                
                // Aplicar filtros actuales
                const accountFilter = document.getElementById('filter-account')?.value;
                const instrumentFilter = document.getElementById('filter-instrument')?.value?.toLowerCase();
                
                if (accountFilter && accountFilter !== 'all') {
                    operations = operations.filter(op => op.accountId === accountFilter);
                }
                
                if (instrumentFilter) {
                    operations = operations.filter(op => 
                        op.instrument && op.instrument.toLowerCase().includes(instrumentFilter)
                    );
                }
                
                // Aplicar filtro de fecha global
                if (globalDateFilter && globalDateFilter.type !== 'all' && globalDateFilter.startDate && globalDateFilter.endDate) {
                    operations = operations.filter(op => {
                        return op.date >= globalDateFilter.startDate && op.date <= globalDateFilter.endDate;
                    });
                }
                
                // Calcular métricas
                const metrics = calculateOperationsMetrics(operations);
                
                // Actualizar UI
                updateMetricsUI(metrics);
                
                // Actualizar gráfico de P&L acumulado
                updateCumulativePLChart(operations);
                
            } catch (error) {
                console.error('Error actualizando métricas:', error);
            }
        }
        
        function calculateOperationsMetrics(operations) {
            const metrics = {
                totalOperations: operations.length,
                cumulativePL: 0,
                roi: 0,
                grossWin: 0,
                grossLoss: 0,
                profitFactor: 0,
                wins: 0,
                losses: 0,
                winRate: 0
            };
            
            if (operations.length === 0) return metrics;
            
            operations.forEach(op => {
                const pl = op.manualPL || op.pl || 0;
                metrics.cumulativePL += pl;
                
                if (pl > 0) {
                    metrics.grossWin += pl;
                    metrics.wins++;
                } else if (pl < 0) {
                    metrics.grossLoss += Math.abs(pl);
                    metrics.losses++;
                }
            });
            
            // Calcular Profit Factor
            if (metrics.grossLoss > 0) {
                metrics.profitFactor = metrics.grossWin / metrics.grossLoss;
            } else if (metrics.grossWin > 0) {
                metrics.profitFactor = 999; // Infinito (solo ganancias)
            }
            
            // Calcular Win Rate
            const totalTrades = metrics.wins + metrics.losses;
            if (totalTrades > 0) {
                metrics.winRate = (metrics.wins / totalTrades) * 100;
            }
            
            // Calcular ROI (necesitamos capital inicial de la cuenta)
            // Por ahora lo dejamos en 0, se puede calcular después con datos de cuenta
            
            return metrics;
        }
        
        function updateMetricsUI(metrics) {
            // Net Cumulative P&L
            const cumulativePLEl = document.getElementById('ops-cumulative-pl');
            if (cumulativePLEl) {
                cumulativePLEl.textContent = formatCurrency(metrics.cumulativePL);
                cumulativePLEl.className = metrics.cumulativePL >= 0 ? 
                    'text-3xl font-bold text-success' : 
                    'text-3xl font-bold text-danger';
            }
            
            // ROI
            const roiEl = document.getElementById('ops-roi');
            if (roiEl) {
                roiEl.textContent = metrics.roi.toFixed(2) + '%';
                roiEl.className = metrics.roi >= 0 ? 
                    'text-sm font-semibold text-success' : 
                    'text-sm font-semibold text-danger';
            }
            
            // Profit Factor
            const pfEl = document.getElementById('ops-profit-factor');
            if (pfEl) {
                pfEl.textContent = metrics.profitFactor.toFixed(2);
                // Color según valor: <1 rojo, 1-2 amarillo, >2 verde
                let pfClass = 'text-3xl font-bold ';
                if (metrics.profitFactor < 1) pfClass += 'text-danger';
                else if (metrics.profitFactor < 2) pfClass += 'text-warning';
                else pfClass += 'text-success';
                pfEl.className = pfClass;
            }
            
            // Profit Factor Gauge
            const pfGaugeEl = document.getElementById('ops-pf-gauge');
            if (pfGaugeEl) {
                // Escala: 0 = 0%, 1 = 33%, 2 = 66%, 3+ = 100%
                let percentage = 0;
                if (metrics.profitFactor >= 3) percentage = 100;
                else if (metrics.profitFactor >= 2) percentage = 66 + (metrics.profitFactor - 2) * 34;
                else if (metrics.profitFactor >= 1) percentage = 33 + (metrics.profitFactor - 1) * 33;
                else percentage = metrics.profitFactor * 33;
                
                pfGaugeEl.style.width = Math.min(percentage, 100) + '%';
            }
            
            // Gross Win
            const grossWinEl = document.getElementById('ops-gross-win');
            if (grossWinEl) {
                grossWinEl.textContent = formatCurrency(metrics.grossWin);
            }
            
            // Win Rate
            const winRateEl = document.getElementById('ops-win-rate');
            if (winRateEl) {
                winRateEl.textContent = metrics.winRate.toFixed(1) + '%';
            }
            
            // Win Circle (donut chart)
            const winCircleEl = document.getElementById('ops-win-circle');
            if (winCircleEl) {
                const dashArray = `${metrics.winRate}, 100`;
                winCircleEl.setAttribute('stroke-dasharray', dashArray);
                
                // Color según win rate: <40% rojo, 40-60% amarillo, >60% verde
                let strokeColor = '#ef4444'; // rojo
                if (metrics.winRate >= 60) strokeColor = '#22c55e'; // verde
                else if (metrics.winRate >= 40) strokeColor = '#eab308'; // amarillo
                
                winCircleEl.setAttribute('stroke', strokeColor);
            }
            
            // Win text en el centro del donut
            const winTextEl = document.getElementById('ops-win-text');
            if (winTextEl) {
                winTextEl.textContent = metrics.winRate.toFixed(0) + '%';
            }
            
            // Total Wins y Losses
            const totalWinsEl = document.getElementById('ops-total-wins');
            if (totalWinsEl) totalWinsEl.textContent = metrics.wins;
            
            const totalLossesEl = document.getElementById('ops-total-losses');
            if (totalLossesEl) totalLossesEl.textContent = metrics.losses;
        }
        
        let operationsMetricsChart = null;
        
        function updateCumulativePLChart(operations) {
            const chartCanvas = document.getElementById('ops-cumulative-chart');
            if (!chartCanvas) {
                console.log('Canvas ops-cumulative-chart no encontrado');
                return;
            }
            
            // Verificar si Chart.js está disponible
            if (typeof Chart === 'undefined') {
                console.error('Chart.js no está cargado');
                return;
            }
            
            // Ordenar operaciones por fecha
            const sortedOps = [...operations].sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );
            
            // Calcular P&L acumulado
            let cumulative = 0;
            const chartData = sortedOps.map(op => {
                cumulative += op.manualPL || op.pl || 0;
                return {
                    date: op.date,
                    cumulative: cumulative
                };
            });
            
            // Si no hay datos, mostrar gráfico vacío
            if (chartData.length === 0) {
                chartData.push({ date: new Date().toISOString().split('T')[0], cumulative: 0 });
            }
            
            // Destruir gráfico anterior si existe
            if (operationsMetricsChart) {
                operationsMetricsChart.destroy();
            }
            
            // Crear nuevo gráfico
            const ctx = chartCanvas.getContext('2d');
            operationsMetricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.map(d => d.date),
                    datasets: [{
                        label: 'P&L Acumulado',
                        data: chartData.map(d => d.cumulative),
                        borderColor: cumulative >= 0 ? '#10b981' : '#ef4444',
                        backgroundColor: cumulative >= 0 ? 
                            'rgba(16, 185, 129, 0.1)' : 
                            'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return formatCurrency(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function refreshAllViews() {
            const activeTabElement = document.querySelector('.nav-tab.active');
            if (!activeTabElement) return;
            const activeTabId = activeTabElement.dataset.target;

            // Asegurarse de que la sección de detalles de operación se oculte si se cambia de pestaña
            if (activeTabId !== 'operation-detail-page') {
                document.getElementById('operation-detail-page').classList.remove('active');
            }

            if (activeTabId === 'dashboard') refreshDashboard();
            else if (activeTabId === 'analytics') refreshAnalytics();
            else if (activeTabId === 'finances') refreshFinancesView();
            else if (activeTabId === 'calendar') updateCalendar();
            else if (activeTabId === 'operations') refreshOperationsTable();
            else if (activeTabId === 'accounts') refreshAccountsView();
            // operation-detail-page no se refresca automáticamente desde aquí, solo cuando se invoca directamente

            if (document.getElementById('selected-account-details')?.style.display === 'block' && document.getElementById('selected-account-details').dataset.accountId) {
                showAccountDetails(document.getElementById('selected-account-details').dataset.accountId);
            }
        }


        async function handleOperationsTableClick(event) {
            const target = event.target;
            const buttonElement = target.closest('button');
            if (!buttonElement) {
                return;
            }
            const operationId = buttonElement.dataset.id;
            if (!operationId) return;

            if (buttonElement.classList.contains('delete-op-btn')) {
                if (confirm('¿Estás seguro de que deseas eliminar esta operación?')) {
                    showLoading(true);
                    try {
                        await dexieDB.operations.delete(operationId);
                        // Eliminar de Supabase
                        await deleteOperationFromSupabase(operationId);
                        DB.operations = DB.operations.filter(op => op.id !== operationId);
                        updateAccountBalances();
                        refreshAllViews();
                    } catch (e) {
                        console.error("Error deleting operation:", e); alert("Error al eliminar la operación.");
                    } finally { showLoading(false); }
                }
            } else if (buttonElement.classList.contains('edit-op-btn')) {
                const operationToEdit = DB.operations.find(op => op.id === operationId);
                if (operationToEdit) toggleAddOperationForm(operationToEdit);
            }
        }

        async function refreshOperationsTable() {
            const operationsSection = document.getElementById('operations');
            if (!operationsSection || !operationsSection.classList.contains('active')) {
                return;
            }

            const tableBody = document.getElementById('operations-table');
            const tableHeaders = document.querySelectorAll('#operations-table-render th[data-sort]');
            if (!tableBody) {
                console.error("Operations table body not found during refresh.");
                return;
            }

            const accountFilter = document.getElementById('filter-account').value;
            const instrumentFilter = document.getElementById('filter-instrument').value.toLowerCase().trim();
            tableBody.innerHTML = '';

            let filteredOperations = applyDateFilterToData(DB.operations);

            filteredOperations = filteredOperations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            
            // NUEVO: Lógica de ordenamiento
            const sortColumn = operationSortState.column;
            const sortOrder = operationSortState.order;
            
            filteredOperations.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                // Manejo especial para la columna 'cuenta' que usa 'accountId'
                if (sortColumn === 'accountId') {
                    valA = DB.accounts.find(acc => acc.id === valA)?.name || '';
                    valB = DB.accounts.find(acc => acc.id === valB)?.name || '';
                }

                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                
                if (valA < valB) return sortOrder === 'asc' ? -1 : 1;
                if (valA > valB) return sortOrder === 'asc' ? 1 : -1;
                return 0;
            });


            tableHeaders.forEach(th => {
                th.classList.remove('sorted', 'asc', 'desc');
                if (th.dataset.sort === sortColumn) {
                    th.classList.add('sorted', sortOrder);
                }
            });


            filteredOperations.forEach(op => {
                const account = DB.accounts.find(acc => acc.id === op.accountId);
                const accountName = account ? account.name : 'Desconocida';
                const plClass = op.pl > 0 ? 'text-positive' : op.pl < 0 ? 'text-negative' : 'text-neutral';
                let resultText, resultClass;
                if (op.result === 'win') { resultText = 'Ganancia'; resultClass = 'text-positive'; }
                else if (op.result === 'loss') { resultText = 'Pérdida'; resultClass = 'text-negative'; }
                else { resultText = 'Neutral'; resultClass = 'text-neutral'; }

                const precision = getInstrumentPrecision(op.instrument);
                const entryDisplay = op.entry !== null ? op.entry.toFixed(precision) : '-';
                const exitDisplay = op.exit !== null ? op.exit.toFixed(precision) : '-';

                const row = tableBody.insertRow();
                row.dataset.id = op.id; // Añade el ID de la operación a la fila
                row.classList.add('cursor-pointer'); // Añade una clase para indicar que es clicable (cambio de cursor)

                row.innerHTML = `
                    <td title="${formatDate(op.date)}">${formatDate(op.date)}</td>
                    <td>${op.entryTime || '-'}</td>
                    <td>${op.exitTime || '-'}</td>
                    <td title="${accountName}">${accountName}</td>
                    <td title="${op.instrument}">${op.instrument}</td>
                    <td>${op.type === 'buy' ? 'Compra' : 'Venta'}</td>
                    <td>${entryDisplay}</td>
                    <td>${exitDisplay}</td>
                    <td>${op.volume}</td>
                    <td class="${resultClass}">${resultText}</td>
                    <td class="${plClass}">${formatCurrency(op.pl, op.currency, op.currency)}</td>
                    <td>${op.fees ? formatCurrency(op.fees, op.currency, op.currency) : '-'}</td>
                    <td>${op.currency}</td>
                    <td title="${op.session || 'No especificado'}">${op.session || '-'}</td>
                    <td class="text-center space-x-2">
                        <button class="text-white edit-op-btn" data-id="${op.id}" title="Editar"><i class="fas fa-edit"></i></button>
                        <button class="text-red delete-op-btn" data-id="${op.id}" title="Eliminar"><i class="fas fa-trash"></i></button>
                    </td>`;
            });

            // Añade un nuevo event listener para las filas después de que se renderizan
            tableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', (event) => {
                    // Verifica si el clic fue en un botón de acción (editar/eliminar)
                    if (event.target.closest('.edit-op-btn') || event.target.closest('.delete-op-btn')) {
                        // Deja que el manejador existente `handleOperationsTableClick` lo procese
                        return;
                    }
                    // Si no fue en un botón de acción, asume que es un clic para ver detalles
                    const operationId = row.dataset.id;
                    if (operationId) {
                        showOperationDetailPage(operationId);
                    }
                });
            });
            
            // Actualizar métricas de operaciones
            updateOperationsMetrics();
        }


        function getInstrumentPrecision(instrument) {
            if (!instrument) return 5;
            const instUpper = instrument.toUpperCase();
            if (instUpper.includes('BTC') || instUpper.includes('ETH') || instUpper.includes('XAU') || instUpper.includes('XAG') || instUpper.endsWith('USDT')) return 2;
            if (instUpper.includes('JPY')) return 3;
            if (instUpper.includes('DE40') || instUpper.includes('US30') || instUpper.includes('SPX500') || instUpper.includes('NAS100')) return 1;
            return 5;
        }

        function openImageModal(imageList, startIndex = 0) {
            if (!imageList || imageList.length === 0) return;

            modalImageList = imageList;
            modalImageIndex = startIndex;

            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-image-content');

            modalImg.src = modalImageList[modalImageIndex];
            modal.style.display = "flex";

            updateModalNavigation();
        }

        function closeImageModal() {
            const modal = document.getElementById('image-modal');
            if (modal) {
                modal.style.display = "none";
                document.getElementById('modal-image-content').src = "";
                modalImageList = [];
                modalImageIndex = 0;
            }
        }

        function updateModalNavigation() {
            const prevBtn = document.getElementById('image-modal-prev');
            const nextBtn = document.getElementById('image-modal-next');

            prevBtn.style.display = (modalImageIndex > 0) ? 'block' : 'none';
            nextBtn.style.display = (modalImageIndex < modalImageList.length - 1) ? 'block' : 'none';
        }

        function initImageModal() {
            document.getElementById('image-modal-close-btn').addEventListener('click', closeImageModal);

            document.getElementById('image-modal-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                if (modalImageIndex > 0) {
                    modalImageIndex--;
                    document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                    updateModalNavigation();
                }
            });

            document.getElementById('image-modal-next').addEventListener('click', (e) => {
                e.stopPropagation();
                if (modalImageIndex < modalImageList.length - 1) {
                    modalImageIndex++;
                    document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                    updateModalNavigation();
                }
            });
        }

        function initAccounts() {
            refreshAccountsView();
            document.getElementById('add-account-btn').addEventListener('click', () => toggleAddAccountForm());
            document.getElementById('acc-cancel').addEventListener('click', () => toggleAddAccountForm());
            document.getElementById('acc-save').addEventListener('click', saveAccount);
        }
        function toggleAddAccountForm(accountToEdit = null) {
            const form = document.getElementById('add-account-form'); const isVisible = form.style.display === 'block';
            if (!isVisible) {
                form.style.display = 'block'; document.getElementById('add-account-btn').textContent = 'Ocultar Formulario';
                if (accountToEdit) { form.querySelector('h3').textContent = 'Editar Cuenta'; document.getElementById('acc-name').value = accountToEdit.name; document.getElementById('acc-balance').value = accountToEdit.initialBalance; document.getElementById('acc-currency').value = accountToEdit.currency; document.getElementById('acc-platform').value = accountToEdit.platform; form.dataset.editingId = accountToEdit.id; }
                else { form.querySelector('h3').textContent = 'Nueva Cuenta'; document.getElementById('acc-name').value = ''; document.getElementById('acc-balance').value = ''; document.getElementById('acc-currency').value = DB.settings.defaultCurrency; document.getElementById('acc-platform').value = 'meta-trader-4'; delete form.dataset.editingId; }
                form.scrollIntoView({ behavior: 'smooth' });
            } else { form.style.display = 'none'; document.getElementById('add-account-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Agregar Cuenta'; delete form.dataset.editingId; }
        }
        async function saveAccount() {
            showLoading(true);
            const form = document.getElementById('add-account-form');
            const editingId = form.dataset.editingId;
            const name = document.getElementById('acc-name').value.trim();
            const initialBalance = parseFloat(document.getElementById('acc-balance').value);
            const currency = document.getElementById('acc-currency').value;
            const platform = document.getElementById('acc-platform').value;
            if (!name || isNaN(initialBalance) || initialBalance < 0) { alert('Nombre y balance inicial válido requerido.'); showLoading(false); return; }

            let accountData;
            try {
                if (editingId) {
                    const existingAccount = DB.accounts.find(acc => acc.id === editingId);
                    accountData = { ...existingAccount, name, initialBalance, currency, platform };
                    accountData.balance = initialBalance;
                    const accountOps = DB.operations.filter(op => op.accountId === editingId);
                    accountOps.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== accountData.currency) pl = convertCurrency(pl, op.currency, accountData.currency);
                        accountData.balance += pl;
                    });
                    accountData.balance = Math.round(accountData.balance * 100) / 100;
                    await dexieDB.accounts.update(editingId, accountData);
                    const index = DB.accounts.findIndex(acc => acc.id === editingId);
                    if (index !== -1) DB.accounts[index] = accountData;
                    
                    console.log('✅ Cuenta actualizada localmente');
                    
                    // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                    if (currentUser) {
                        saveAccountToSupabase(accountData).then(() => {
                            console.log('✅ Cuenta sincronizada automáticamente');
                            showSyncNotification('💾 Cuenta actualizada exitosamente', 'success');
                        }).catch((supabaseError) => {
                            console.error('❌ Error de sincronización automática:', supabaseError);
                            addToSyncQueue(accountData, 'account');
                            showSyncNotification('💾 Cuenta actualizada exitosamente', 'success');
                        });
                    } else {
                        showSyncNotification('💾 Cuenta actualizada', 'success');
                    }
                    
                } else {
                    accountData = { id: generateId(), name, initialBalance, balance: initialBalance, currency, platform };
                    console.log('🏦 Creating new account:', accountData);
                    
                    await dexieDB.accounts.add(accountData);
                    console.log('✅ Account added to local DB');
                    
                    DB.accounts.push(accountData);
                    console.log('✅ Account added to memory');
                    
                    // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                    if (currentUser) {
                        saveAccountToSupabase(accountData).then(() => {
                            console.log('✅ Cuenta sincronizada automáticamente');
                            showSyncNotification('💾 Cuenta creada exitosamente', 'success');
                        }).catch((supabaseError) => {
                            console.error('❌ Error de sincronización automática:', supabaseError);
                            addToSyncQueue(accountData, 'account');
                            showSyncNotification('💾 Cuenta creada exitosamente', 'success');
                        });
                    } else {
                        showSyncNotification('💾 Cuenta creada', 'success');
                    }
                }
                
                // Actualizar vistas inmediatamente con datos locales
                toggleAddAccountForm();
                updateAccountBalances();
                ['dashboard-account-select', 'analytics-account-select', 'calendar-account-select', 'op-account', 'filter-account', 'bingx-account'].forEach(updateAccountSelect);
                refreshAllViews();
                
                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Cuenta guardada exitosamente', 'success');

            } catch (e) {
                console.error("Error saving account:", e); alert("Error al guardar la cuenta.");
            } finally { showLoading(false); }
        }

        async function refreshAccountsView() {
            if (!document.getElementById('accounts').classList.contains('active')) return;
            const container = document.getElementById('accounts-container');
            if (!container) return;
            container.innerHTML = '';
            DB.accounts.forEach(account => {
                const card = document.createElement('div'); card.classList.add('account-card'); card.dataset.id = account.id;
                const accountOps = DB.operations.filter(op => op.accountId === account.id);
                const winningOps = accountOps.filter(op => op.result === 'win').length;
                const losingOps = accountOps.filter(op => op.result === 'loss').length;
                const winRate = (winningOps + losingOps) > 0 ? (winningOps / (winningOps + losingOps)) * 100 : 0;
                const pl = account.balance - account.initialBalance;
                const plPercentage = account.initialBalance !== 0 ? (pl / account.initialBalance) * 100 : 0;
                
                // Obtener logo de la plataforma
                const platformLogo = getPlatformLogo(account.platform);
                const logoHTML = platformLogo.file 
                    ? `<img src="${platformLogo.file}" alt="${formatPlatformName(account.platform)}" class="w-8 h-8 object-contain" onerror="this.parentElement.innerHTML='<div class=\\'w-8 h-8 bg-[${platformLogo.color}] rounded-lg flex items-center justify-center text-white font-bold text-xs\\'>${platformLogo.initials}</div>'">`
                    : `<div class="w-8 h-8 bg-[${platformLogo.color}] rounded-lg flex items-center justify-center text-white font-bold text-xs">${platformLogo.initials}</div>`;
                
                card.innerHTML = ` 
                    <div class="flex justify-between items-start mb-4">
                        <div class="flex items-center gap-3">
                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: ${platformLogo.color};">
                                ${logoHTML}
                            </div>
                            <h4 class="text-lg font-semibold">${account.name}</h4>
                        </div>
                        <span class="text-xs bg-surface-light px-2 py-1 rounded text-text-secondary">${formatPlatformName(account.platform)}</span>
                    </div>
                    <div class="mb-4">
                        <p class="text-sm text-text-secondary">Balance</p>
                        <p class="text-2xl font-semibold">${formatCurrency(account.balance, account.currency, account.currency)}</p>
                    </div>
                    <div class="grid grid-cols-2 gap-4 mb-3">
                        <div>
                            <p class="text-sm text-text-secondary">P&L</p>
                            <p class="text-lg font-semibold ${pl > 0 ? 'text-positive' : (pl < 0 ? 'text-negative' : '')}">${formatCurrency(pl, account.currency, account.currency)} (${plPercentage.toFixed(1)}%)</p>
                        </div>
                        <div>
                            <p class="text-sm text-text-secondary">Win Rate</p>
                            <p class="text-lg font-semibold text-green">${winRate.toFixed(0)}%</p>
                        </div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button class="view-account-btn text-sm" data-id="${account.id}">
                            <i class="fas fa-chart-line mr-1"></i> Detalles
                        </button>
                        <div class="space-x-2">
                            <button class="edit-account-btn text-sm text-white" data-id="${account.id}" title="Editar Cuenta">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="delete-account-btn text-sm text-red" data-id="${account.id}" title="Eliminar Cuenta">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
            container.addEventListener('click', async function (event) {
                const targetButton = event.target.closest('button');
                if (!targetButton) return;

                const accountId = targetButton.dataset.id;
                const account = DB.accounts.find(acc => acc.id === accountId);

                if (targetButton.classList.contains('view-account-btn')) {
                    showAccountDetails(accountId);
                } else if (targetButton.classList.contains('edit-account-btn')) {
                    if (account) toggleAddAccountForm(account);
                } else if (targetButton.classList.contains('delete-account-btn')) {
                    const opsCount = DB.operations.filter(op => op.accountId === accountId).length;
                    if (confirm(`¿Eliminar cuenta "${account?.name || accountId}" y TODAS sus ${opsCount} operaciones? Esta acción es irreversible.`)) {
                        showLoading(true);
                        try {
                            await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, async () => {
                                await dexieDB.accounts.delete(accountId);
                                const opsToDelete = DB.operations.filter(op => op.accountId === accountId).map(op => op.id);
                                if (opsToDelete.length > 0) await dexieDB.operations.bulkDelete(opsToDelete);
                            });
                            
                            // Eliminar de Supabase
                            await deleteAccountFromSupabase(accountId);
                            // También eliminar todas las operaciones de esta cuenta de Supabase
                            const opsToDelete = DB.operations.filter(op => op.accountId === accountId);
                            for (const op of opsToDelete) {
                                await deleteOperationFromSupabase(op.id);
                            }
                            
                            DB.accounts = DB.accounts.filter(a => a.id !== accountId);
                            DB.operations = DB.operations.filter(op => op.accountId !== accountId);

                            updateAccountBalances();
                            ['dashboard-account-select', 'analytics-account-select', 'calendar-account-select', 'op-account', 'filter-account', 'bingx-account'].forEach(updateAccountSelect);

                            const detailsSection = document.getElementById('selected-account-details');
                            if (detailsSection.style.display === 'block' && detailsSection.dataset.accountId === accountId) {
                                detailsSection.style.display = 'none'; detailsSection.removeAttribute('data-accountId');
                            }
                            refreshAllViews();
                        }
                        catch (e) {
                            console.error("Error deleting account:", e); alert("Error al eliminar la cuenta.");
                        } finally { showLoading(false); }
                    }
                }
            });
        }
        
        let accountDetailRadarChart = null;
        function updateAccountDetailRadarChart(operations, accountId) {
            const ctx = document.getElementById('account-detail-radar-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountDetailRadarChart) accountDetailRadarChart.destroy();

            // This function is essentially the same as updateDashboardRadarChart,
            // but targets the account detail canvas.
            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);

            let maxDrawdownPercentage = 0;
            const account = DB.accounts.find(a => a.id === accountId);
            if (operations.length > 0 && account) {
                const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                let accountInitialBalance = account.initialBalance;
                
                if (accountInitialBalance > 0) {
                    let peakBalance = accountInitialBalance;
                    let maxDrawdownValue = 0;
                    let currentBalance = accountInitialBalance;
                    sortedOps.forEach(op => {
                        let pl = convertCurrency(op.pl, op.currency, account.currency);
                        currentBalance += pl;
                        if (currentBalance > peakBalance) peakBalance = currentBalance;
                        const drawdown = peakBalance - currentBalance;
                        if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
                    });
                    maxDrawdownPercentage = (maxDrawdownValue / accountInitialBalance) * 100;
                }
            }

            const winRateScore = basicMetrics.winRate || 0;
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3, 1) * 100;
            const avgWLRatio = advancedMetrics.avgWin && advancedMetrics.avgLoss ? Math.abs(convertCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, account.currency) / convertCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, account.currency)) : 0;
            const avgWLRatioScore = Math.min(avgWLRatio / 3, 1) * 100;
            const drawdownScore = Math.max(0, (1 - Math.min(maxDrawdownPercentage / 20, 1)) * 100);

            let consistencyScore = 0;
            if (operations.length > 1) {
                const tradingDays = new Set(operations.map(op => op.date));
                if (tradingDays.size > 0) {
                    const dailyPL = {};
                    operations.forEach(op => {
                        if (!dailyPL[op.date]) dailyPL[op.date] = 0;
                        dailyPL[op.date] += convertCurrency(op.pl, op.currency, account.currency);
                    });
                    const winningDays = Object.values(dailyPL).filter(pl => pl > 0).length;
                    consistencyScore = (winningDays / tradingDays.size) * 100;
                }
            }

            accountDetailRadarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                    datasets: [{
                        label: 'Puntuación',
                        data: [winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore],
                        fill: true,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: 'rgba(57, 255, 20, 0.8)',
                        pointBackgroundColor: 'var(--primary)',
                        pointBorderColor: '#0a0a0a',
                        pointHoverBackgroundColor: '#FFFFFF',
                        pointHoverBorderColor: 'var(--primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            angleLines: { color: '#2a2a2a' },
                            grid: { color: '#2a2a2a' },
                            pointLabels: { color: '#FFFFFF', font: { size: 10 } },
                            ticks: { display: false, stepSize: 25 }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }


        function showAccountDetails(accountId) {
            const account = DB.accounts.find(acc => acc.id === accountId); if (!account) return;
            document.querySelectorAll('.account-card').forEach(card => card.classList.toggle('selected', card.dataset.id === accountId));
            const detailsSection = document.getElementById('selected-account-details');
            if (!detailsSection) return;
            detailsSection.style.display = 'block'; detailsSection.dataset.accountId = accountId;

            document.getElementById('account-detail-name').textContent = `Detalles de ${account.name}`;

            const operations = DB.operations.filter(op => op.accountId === accountId);
            const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));

            let totalWin = 0, totalLoss = 0, winCount = 0, lossCount = 0;
            let avgWin = 0, avgLoss = 0;

            operations.forEach(op => {
                let pl = op.pl;
                if (op.currency !== account.currency) pl = convertCurrency(pl, op.currency, account.currency);
                if (op.result === 'win') { totalWin += pl; winCount++; }
                else if (op.result === 'loss') { totalLoss += pl; lossCount++; }
            });

            if (winCount > 0) avgWin = totalWin / winCount;
            if (lossCount > 0) avgLoss = totalLoss / lossCount;

            const totalPL = totalWin + totalLoss;
            const winRate = (winCount + lossCount) > 0 ? (winCount / (winCount + lossCount)) * 100 : 0;
            const profitFactor = Math.abs(totalLoss) > 0 ? Math.abs(totalWin / totalLoss) : (totalWin > 0 ? Infinity : 0);
            const avgWLRatio = Math.abs(avgLoss) > 0 ? Math.abs(avgWin / avgLoss) : (avgWin > 0 ? Infinity : 0);

            let peakBalance = account.initialBalance;
            let maxDrawdownValue = 0;
            let currentBalance = account.initialBalance;
            sortedOps.forEach(op => {
                let pl = op.pl;
                if (op.currency !== account.currency) pl = convertCurrency(pl, op.currency, account.currency);
                currentBalance += pl;
                if (currentBalance > peakBalance) peakBalance = currentBalance;
                const drawdown = peakBalance - currentBalance;
                if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
            });
            const maxDrawdownPercentage = account.initialBalance > 0 ? (maxDrawdownValue / account.initialBalance) * 100 : 0;

            let totalDurationMinutes = 0, tradesWithDuration = 0;
            operations.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    try {
                        const startDate = new Date(`1970-01-01T${op.entryTime}`);
                        const endDate = new Date(`1970-01-01T${op.exitTime}`);
                        let duration = (endDate - startDate) / 60000;
                        if (duration < 0) duration += 24 * 60; // Overnight
                        totalDurationMinutes += duration;
                        tradesWithDuration++;
                    } catch (e) { console.warn("Invalid time format for holding time calc", e); }
                }
            });
            let avgHoldTimeText = 'N/A';
            if (tradesWithDuration > 0) {
                const avgMinutes = totalDurationMinutes / tradesWithDuration;
                if (avgMinutes < 1) avgHoldTimeText = `${(avgMinutes * 60).toFixed(0)} seg`;
                else if (avgMinutes < 60) avgHoldTimeText = `${avgMinutes.toFixed(0)} min`;
                else avgHoldTimeText = `${Math.floor(avgMinutes / 60)}h ${Math.round(avgMinutes % 60)}m`;
            }

            let longestWinStreak = 0, currentWinStreak = 0, longestLossStreak = 0, currentLossStreak = 0;
            sortedOps.forEach(op => {
                if (op.result === 'win') { currentWinStreak++; currentLossStreak = 0; longestWinStreak = Math.max(longestWinStreak, currentWinStreak); }
                else if (op.result === 'loss') { currentLossStreak++; currentWinStreak = 0; longestLossStreak = Math.max(longestLossStreak, currentLossStreak); }
                else { currentWinStreak = 0; currentLossStreak = 0; }
            });

            const analyzeTradeType = (trades) => {
                const wins = trades.filter(t => t.result === 'win').length;
                const losses = trades.filter(t => t.result === 'loss').length;
                const totalPL = trades.reduce((sum, t) => sum + (t.currency !== account.currency ? convertCurrency(t.pl, t.currency, account.currency) : t.pl), 0);
                const winRate = (wins + losses) > 0 ? (wins / (wins + losses)) * 100 : 0;
                return { count: trades.length, totalPL, winRate };
            };
            const longStats = analyzeTradeType(operations.filter(op => op.type === 'buy'));
            const shortStats = analyzeTradeType(operations.filter(op => op.type === 'sell'));

            const plEl = document.getElementById('account-detail-pl');
            plEl.textContent = formatCurrency(totalPL, account.currency, account.currency);
            plEl.className = `text-2xl font-bold ${totalPL >= 0 ? 'text-positive' : 'text-negative'}`;
            document.getElementById('account-detail-winrate').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('account-detail-winrate').className = "text-2xl font-bold text-green";
            document.getElementById('account-detail-trades').textContent = operations.length;
            const pfEl = document.getElementById('account-detail-pf');
            pfEl.textContent = isFinite(profitFactor) ? profitFactor.toFixed(2) : "∞";
            pfEl.className = `text-2xl font-bold ${profitFactor >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('account-detail-drawdown').textContent = `${formatCurrency(maxDrawdownValue, account.currency, account.currency)} (${maxDrawdownPercentage.toFixed(1)}%)`;
            const avgWLRatioEl = document.getElementById('account-detail-avg-w-l-ratio');
            avgWLRatioEl.textContent = isFinite(avgWLRatio) ? avgWLRatio.toFixed(2) : "∞";
            avgWLRatioEl.className = `font-semibold ${avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('account-detail-win-streak').textContent = longestWinStreak;
            document.getElementById('account-detail-loss-streak').textContent = longestLossStreak;
            document.getElementById('account-detail-hold-time').textContent = avgHoldTimeText;

            const lsBody = document.getElementById('account-long-short-analysis');
            lsBody.innerHTML = `
                <tr>
                    <td>Compras</td><td>${longStats.count}</td>
                    <td class="${longStats.totalPL >= 0 ? 'text-positive' : 'text-negative'}">${formatCurrency(longStats.totalPL, account.currency, account.currency)}</td>
                    <td class="text-green">${longStats.winRate.toFixed(1)}%</td>
                </tr>
                <tr>
                    <td>Ventas</td><td>${shortStats.count}</td>
                    <td class="${shortStats.totalPL >= 0 ? 'text-positive' : 'text-negative'}">${formatCurrency(shortStats.totalPL, account.currency, account.currency)}</td>
                    <td class="text-green">${shortStats.winRate.toFixed(1)}%</td>
                </tr>`;

            const accountDetailTimeRangeContainer = document.getElementById('account-detail-time-range');
            accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
            const allButtonAccountDetail = Array.from(accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn')).find(btn => btn.dataset.range === 'ALL');
            if (allButtonAccountDetail) allButtonAccountDetail.classList.add('active');

            updateAccountDetailChart(account, operations, 'ALL');
            updateAccountDetailRadarChart(operations, accountId); // <-- Nueva llamada
            updateBestWorstTrades(account, sortedOps);
            detailsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function updateBestWorstTrades(account, sortedOperations) {
            const bestTradesBody = document.getElementById('best-trades');
            const worstTradesBody = document.getElementById('worst-trades');
            if (!bestTradesBody || !worstTradesBody) return;
            bestTradesBody.innerHTML = ''; worstTradesBody.innerHTML = '';

            const best5 = [...sortedOperations].sort((a, b) => b.pl - a.pl).filter(op => op.pl > 0).slice(0, 5);
            const worst5 = [...sortedOperations].sort((a, b) => a.pl - b.pl).filter(op => op.pl < 0).slice(0, 5);

            const populateTable = (tbody, ops) => {
                if (ops.length === 0) { tbody.innerHTML = '<tr><td colspan="3" class="text-center text-text-secondary py-4">No hay operaciones</td></tr>'; return; }
                ops.forEach(op => {
                    const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
                    const row = tbody.insertRow(); // Insertar la fila
                    row.dataset.id = op.id; // Añadir data-id a la fila
                    row.classList.add('cursor-pointer'); // Añadir clase para hacerla clicable

                    row.innerHTML = `
                        <td>${formatDate(op.date)}</td>
                        <td>${op.instrument}</td>
                        <td class="${plClass}">${formatCurrency(op.pl, op.currency, op.currency)}</td>`;
                });
            };
            populateTable(bestTradesBody, best5);
            populateTable(worstTradesBody, worst5);

            // Añadir event listeners a las tablas de mejores y peores operaciones
            bestTradesBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const operationId = row.dataset.id;
                    if (operationId) showOperationDetailPage(operationId);
                });
            });
            worstTradesBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const operationId = row.dataset.id;
                    if (operationId) showOperationDetailPage(operationId);
                });
            });
        }

        async function processCSVFile(file, statusDiv) {
            // Formato CSV soportado:
            // Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), 
            // Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), 
            // Divisa, Tarifa/Comision (opc), Notas (opc), Sesion (opc)
            showLoading(true);
            const csvText = await file.text();
            const parsedData = parseCSV(csvText);

            if (!parsedData.headers || parsedData.rows.length === 0) {
                throw new Error("CSV vacío o formato de cabecera incorrecto.");
            }

            const headerMap = {};
            parsedData.headers.forEach((header, index) => {
                const normalizedHeader = header.toLowerCase().trim().replace(/\s+/g, ' ');
                headerMap[normalizedHeader] = index;
                console.log(`📋 Header detectado: "${header}" -> normalizado: "${normalizedHeader}" (index: ${index})`);
            });
            
            console.log('📋 Mapa completo de headers:', headerMap);

            const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
            for (const reqHeader of requiredHeaders) {
                if (!(reqHeader in headerMap)) {
                    throw new Error(`Cabecera requerida no encontrada en CSV: '${reqHeader}'.`);
                }
            }

            let importedOpsCount = 0;
            let skippedOpsCount = 0;
            const newOperations = [];

            for (const row of parsedData.rows) {
                const accountNameFromCsv = row[headerMap['nombre cuenta']];
                if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
                    skippedOpsCount++;
                    continue;
                }

                const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

                if (!account) {
                    console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
                    skippedOpsCount++;
                    continue;
                }

                const dateStr = row[headerMap['fecha']];
                let opDate;
                
                // Limpiar y validar la fecha
                const cleanDateStr = dateStr.trim();
                
                if (cleanDateStr.includes('-')) {
                    // Formato YYYY-MM-DD
                    const parts = cleanDateStr.split('-');
                    if (parts.length === 3 && parts[0].length === 4) {
                        const year = parts[0];
                        const month = parts[1].padStart(2, '0');
                        const day = parts[2].padStart(2, '0');
                        opDate = `${year}-${month}-${day}`;
                    }
                } else if (cleanDateStr.includes('/')) {
                    // Formato DD/MM/YYYY
                    const parts = cleanDateStr.split('/');
                    if (parts.length === 3) {
                        const day = parts[0].padStart(2, '0');
                        const month = parts[1].padStart(2, '0');
                        const year = parts[2];
                        opDate = `${year}-${month}-${day}`;
                    }
                }
                
                // Validar que la fecha sea válida
                if (!opDate) {
                    console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
                    skippedOpsCount++;
                    continue;
                }
                
                const testDate = new Date(opDate + "T12:00:00");
                if (isNaN(testDate.getTime())) {
                    console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
                    skippedOpsCount++;
                    continue;
                }

                const instrument = row[headerMap['instrumento']].toUpperCase().trim();
                const type = row[headerMap['tipo']].toLowerCase().trim();
                const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
                const exitStr = String(row[headerMap['salida']]).replace(',', '.');
                const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

                const entryTime = row[headerMap['hora entrada']] || null;
                const exitTime = row[headerMap['hora salida']] || null;
                const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : null;

                const entry = parseFloat(entryStr);
                const exit = parseFloat(exitStr);
                const volume = parseFloat(volumeStr);

                const currency = row[headerMap['divisa']].toUpperCase().trim();
                const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';
                
                // Procesar tarifa/comisiones (aceptar todas las variantes posibles)
                let fees = 0;
                const possibleFeeHeaders = [
                    'tarifa/comision',
                    'tarifa/comisión', 
                    'tarifa',
                    'comision',
                    'comisión',
                    'fee',
                    'fees',
                    'commission'
                ];
                
                console.log('🔍 Buscando columna de fees...');
                let feesIdx = undefined;
                for (const feeHeader of possibleFeeHeaders) {
                    if (headerMap[feeHeader] !== undefined) {
                        feesIdx = headerMap[feeHeader];
                        console.log(`✅ Encontrada columna de fees: "${feeHeader}" en index ${feesIdx}`);
                        break;
                    }
                }
                
                if (feesIdx !== undefined && row[feesIdx] && String(row[feesIdx]).trim() !== "") {
                    const feeValue = String(row[feesIdx]).trim().replace(',', '.');
                    console.log(`💰 Valor de fee leído: "${row[feesIdx]}" -> procesado: "${feeValue}"`);
                    if (feeValue !== "" && !isNaN(parseFloat(feeValue))) {
                        fees = Math.abs(parseFloat(feeValue));
                        console.log(`✅ Fee final asignado: ${fees}`);
                    } else {
                        console.log(`⚠️ Valor de fee no es un número válido`);
                    }
                } else {
                    console.log(`❌ No se encontró valor de fee o columna no detectada. feesIdx: ${feesIdx}`);
                }

                let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
                    ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                    : null;
                let result;

                if (isNaN(volume) || volume <= 0) {
                    skippedOpsCount++;
                    continue;
                }

                if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
                    skippedOpsCount++;
                    continue;
                }

                if (pl !== null && !isNaN(pl)) {
                    result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
                } else {
                    if (isNaN(entry) || isNaN(exit)) {
                        skippedOpsCount++;
                        continue;
                    }
                    if (type === 'buy')
                     pl = (exit - entry) * volume;
                    else pl = (entry - exit) * volume;
                    result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
                }
                pl = parseFloat(pl.toFixed(5));

                newOperations.push({
                    id: generateId(), date: opDate, accountId: account.id, instrument, type,
                    entry: isNaN(entry) ? null : entry,
                    exit: isNaN(exit) ? null : exit,
                    entryTime, exitTime,
                    volume, result, pl, currency, notes, imageDatas: [],
                    fees: fees || 0,
                    manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                        ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                        : null,
                    session: session
                });
                importedOpsCount++;
            }

            if (newOperations.length > 0) {
                await dexieDB.operations.bulkAdd(newOperations);
                DB.operations.push(...newOperations);

                // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE PARA OPERACIONES IMPORTADAS
                console.log('🔍 Iniciando sincronización de operaciones importadas...');
                if (currentUser) {
                    console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                    let successCount = 0;
                    let errorCount = 0;
                    
                    for (const operation of newOperations) {
                        try {
                            await saveOperationToSupabase(operation);
                            successCount++;
                            console.log('✅ Operación sincronizada:', operation.id);
                        } catch (error) {
                            console.error('❌ Error sincronizando operación:', operation.id, error);
                            addToSyncQueue(operation, 'operation');
                            errorCount++;
                        }
                    }
                    
                    console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                    if (successCount > 0) {
                        showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                    }
                    if (errorCount > 0) {
                        showSyncNotification(`⚠️ ${errorCount} operaciones en cola para sincronizar`, 'info');
                    }
                } else {
                    console.log('⚠️ No hay usuario autenticado - operaciones guardadas solo localmente');
                    showSyncNotification('💾 Operaciones importadas (solo local)', 'warning');
                }

                updateAccountBalances();
                refreshAllViews();
            }
            
            if (statusDiv) {
                statusDiv.textContent = `Importación completada: ${importedOpsCount} operaciones añadidas, ${skippedOpsCount} omitidas.`;
                statusDiv.className = 'mt-2 text-sm text-positive';
            }
            
            showLoading(false);
        }

        function initCsvImport() {
            const importBtn = document.getElementById('import-csv-btn');
            const fileInput = document.getElementById('csv-file-input');
            const statusDiv = document.getElementById('csv-import-status');

            importBtn.addEventListener('click', async () => {
                if (!fileInput.files || fileInput.files.length === 0) {
                    statusDiv.textContent = 'Por favor, selecciona un archivo CSV.';
                    statusDiv.className = 'mt-2 text-sm text-red';
                    return;
                }
                
                const file = fileInput.files[0];
                statusDiv.textContent = 'Importando...';
                statusDiv.className = 'mt-2 text-sm text-yellow';
                
                try {
                    await processCSVFile(file, statusDiv);
                    fileInput.value = '';
                } catch (error) {
                    console.error("Error importando CSV:", error);
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.className = 'mt-2 text-sm text-negative';
                }
            });
        }

        function parseCSV(csvText) {
            const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (lines.length === 0) return { headers: [], rows: [] };

            const splitLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && (i === 0 || line[i - 1] !== '\\')) { 
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result.map(v => v.replace(/^"|"$/g, ''));
            };

            const headers = splitLine(lines[0]);
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;
                const values = splitLine(line);
                if (values.length >= headers.length) { 
                    rows.push(values);
                } else {
                    console.warn(`Línea CSV con número incorrecto de columnas: "${line}". Esperadas ${headers.length}, obtenidas ${values.length}.`);
                }
            }
            return { headers, rows };
        }


        
        // Función para actualizar el estado de autenticación en la configuración
        function updateAuthStatus() {
            const loggedOutSection = document.getElementById('auth-status-logged-out');
            const loggedInSection = document.getElementById('auth-status-logged-in');
            const currentUserEmailSpan = document.getElementById('current-user-email');
            
            if (currentUser) {
                // Usuario autenticado
                if (loggedOutSection) loggedOutSection.style.display = 'none';
                if (loggedInSection) loggedInSection.style.display = 'block';
                if (currentUserEmailSpan) currentUserEmailSpan.textContent = currentUser.email;
            } else {
                // Usuario no autenticado
                if (loggedOutSection) loggedOutSection.style.display = 'block';
                if (loggedInSection) loggedInSection.style.display = 'none';
            }
        }

        async function initConfig() {
            // Solo actualizar elementos de BingX si existen
            const bingxAccount = document.getElementById('bingx-account');
            if (bingxAccount) {
                updateAccountSelect('bingx-account');
                const bingxApiKey = document.getElementById('bingx-api-key');
                const bingxApiSecret = document.getElementById('bingx-api-secret');
                if (bingxApiKey) bingxApiKey.value = DB.apiKeys.bingx.key ? '********' : '';
                if (bingxApiSecret) bingxApiSecret.value = DB.apiKeys.bingx.secret ? '********' : '';
                bingxAccount.value = DB.apiKeys.bingx.accountId || '';
            }
            updateAccountSelect('bingx-account-detail');
            
            // Solo actualizar elementos que existen
            const showTooltips = document.getElementById('show-tooltips');
            if (showTooltips) {
                showTooltips.checked = DB.settings.showTooltips;
            }

            // Actualizar estado de autenticación
            updateAuthStatus();

            initCsvImport();

            // Event listeners para autenticación
            document.getElementById('show-auth-modal-btn').addEventListener('click', () => {
                document.getElementById('authModal').style.display = 'flex';
                document.getElementById('mainApp').classList.add('app-hidden');
            });
            
            document.getElementById('logout-btn-config').addEventListener('click', async () => {
                if (confirm('¿Está seguro de que desea cerrar sesión? Sus datos locales se mantendrán, pero no se sincronizarán con Supabase.')) {
                    await handleLogout();
                }
            });

            const showTooltipsEl = document.getElementById('show-tooltips');
            if (showTooltipsEl) {
                showTooltipsEl.addEventListener('change', async (e) => {
                    DB.settings.showTooltips = e.target.checked;
                    try {
                        await dexieDB.generalData.put({ key: 'settings', value: DB.settings }); alert('Configuración de tooltips guardada.');
                    } catch (err) { console.error("Error saving tooltip settings:", err); alert("Error al guardar configuración."); }
                });
            }
            
            // Solo agregar listener si el elemento existe
            const bingxConnectEl = document.getElementById('bingx-connect');
            if (bingxConnectEl) {
                bingxConnectEl.addEventListener('click', () => alert('Funcionalidad API no implementada.'));
            }
            


            document.getElementById('export-data').addEventListener('click', async () => {
                showLoading(true);
                try {
                    const exportableDB = {
                        accounts: await dexieDB.accounts.toArray(),
                        operations: await dexieDB.operations.toArray(),
                        finances: await dexieDB.finances.toArray(),
                        settings: (await dexieDB.generalData.get('settings'))?.value || DB.settings,
                        apiKeys: (await dexieDB.generalData.get('apiKeys'))?.value || DB.apiKeys
                    };
                    const dataStr = JSON.stringify(exportableDB, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a'); link.href = url; const date = getLocalDateString(new Date()); link.download = `trader_survivor_backup_${date}.json`;
                    document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                    alert('Datos exportados correctamente.');
                } catch (e) {
                    console.error('Error exporting data:', e); alert('Error al exportar.');
                } finally { showLoading(false); }
            });

            const importInput = document.getElementById('import-data');
            importInput.addEventListener('change', (event) => {
                const file = event.target.files[0]; if (!file) return;
                if (!confirm('Importar datos reemplazará TODOS los datos actuales. ¿Seguro?')) { importInput.value = ''; return; }
                const reader = new FileReader();
                reader.onload = async (e) => {
                    showLoading(true);
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (importedData.accounts && importedData.operations && importedData.settings) {
                            await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, dexieDB.finances, dexieDB.generalData, async () => {
                                await dexieDB.accounts.clear();
                                await dexieDB.operations.clear();
                                await dexieDB.finances.clear();
                                await dexieDB.generalData.clear();
                                await dexieDB.accounts.bulkPut(importedData.accounts || []);
                                await dexieDB.operations.bulkPut(importedData.operations || []);
                                await dexieDB.finances.bulkPut(importedData.finances || []);
                                await dexieDB.generalData.put({ key: 'settings', value: importedData.settings || DB.settings });
                                await dexieDB.generalData.put({ key: 'apiKeys', value: importedData.apiKeys || DB.apiKeys });
                            });
                            alert('Datos importados. Recargando aplicación...'); location.reload();
                        } else { alert('Error: Archivo con estructura no esperada.'); }
                    } catch (err) {
                        console.error('Error importing file:', err); alert('Error al procesar el archivo.');
                    } finally { importInput.value = ''; showLoading(false); }
                };
                reader.onerror = () => { alert('Error al leer el archivo.'); importInput.value = ''; };
                reader.readAsText(file);
            });

            document.getElementById('clear-data').addEventListener('click', async () => {
                if (confirm('¡ATENCIÓN! Esto eliminará TODOS tus datos de forma permanente y la plataforma quedará vacía. ¿Estás seguro?')) {
                    showLoading(true);
                    try {
                        await Promise.all([
                            dexieDB.accounts.clear(),
                            dexieDB.operations.clear(),
                            dexieDB.finances.clear(),
                            dexieDB.generalData.clear()
                        ]);
                        DB.accounts = [];
                        DB.operations = [];
                        DB.finances = [];
                        DB.settings = { darkMode: true, showTooltips: true, autoRefresh: false, defaultCurrency: 'USD' };
                        DB.apiKeys = { ctrader: { key: '', secret: '', accountId: '' }, bingx: { key: '', secret: '', accountId: '' } };
                        await dexieDB.generalData.put({ key: 'settings', value: DB.settings });
                        await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });

                        alert('Todos los datos han sido eliminados. Recargando aplicación...');
                        location.reload();
                    } catch (e) {
                        console.error("Error clearing DexieDB:", e);
                        alert("Error al borrar los datos de la base de datos local.");
                    } finally {
                        showLoading(false);
                    }
                }
            });
        }

        function updateAccountSelect(selectId) {
            const selectElement = document.getElementById(selectId); 
            if (!selectElement) return;
            
            const currentValue = selectElement.value; 
            selectElement.innerHTML = '';
            
            // Opción "Todas las cuentas" para algunos selectores
            if (['dashboard-account-select', 'analytics-account-select', 'calendar-account-select', 'filter-account'].includes(selectId)) {
                const allOption = document.createElement('option'); 
                allOption.value = 'all'; 
                allOption.textContent = 'Todas las cuentas'; 
                selectElement.appendChild(allOption);
            }
            
            // Opción placeholder para BingX
            if (['bingx-account'].includes(selectId)) {
                const placeholderOption = document.createElement('option'); 
                placeholderOption.value = ''; 
                placeholderOption.textContent = 'Seleccionar cuenta...'; 
                selectElement.appendChild(placeholderOption);
            }
            
            // Agregar cuentas sin mostrar divisa
            DB.accounts.forEach(account => { 
                const option = document.createElement('option'); 
                option.value = account.id;
                option.textContent = account.name;
                option.setAttribute('data-platform', account.platform);
                selectElement.appendChild(option); 
            });

            // Restaurar valor seleccionado
            if (Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
                selectElement.value = currentValue;
            } else if (selectId === 'op-account' && DB.accounts.length > 0) {
                selectElement.value = DB.accounts[0].id;
            } else if (!['bingx-account'].includes(selectId) && selectElement.options.length > 0 && selectElement.options[0].value === 'all') {
                selectElement.value = 'all';
            } else if (selectElement.options.length > 0) {
                selectElement.value = selectElement.options[0].value;
            }
            
            // Actualizar logo del selector
            updateSelectorLogo(selectId);
        }
        
        // Función para actualizar el logo del selector según la cuenta seleccionada
        function updateSelectorLogo(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;
            
            const selectedAccountId = selectElement.value;
            
            // Mapeo de selectores a sus contenedores de logo
            const logoMapping = {
                'dashboard-account-select': { container: 'dashboard-account-logo', img: 'dashboard-account-logo-img' },
                'analytics-account-select': { container: 'analytics-account-logo', img: 'analytics-account-logo-img' },
                'calendar-account-select': { container: 'calendar-account-logo', img: 'calendar-account-logo-img' },
                'filter-account': { container: 'filter-account-logo', img: 'filter-account-logo-img' }
            };
            
            const logoInfo = logoMapping[selectId];
            if (!logoInfo) return;
            
            const logoContainer = document.getElementById(logoInfo.container);
            const logoImg = document.getElementById(logoInfo.img);
            
            if (!logoContainer || !logoImg) return;
            
            // Si es "all" o no hay selección, ocultar logo
            if (selectedAccountId === 'all' || !selectedAccountId) {
                logoContainer.style.display = 'none';
                return;
            }
            
            // Buscar la cuenta seleccionada
            const account = DB.accounts.find(acc => acc.id === selectedAccountId);
            if (!account) {
                logoContainer.style.display = 'none';
                return;
            }
            
            // Obtener información del logo
            const platformLogo = getPlatformLogo(account.platform);
            
            // Configurar el logo SIN fondo de color
            logoContainer.style.backgroundColor = 'transparent';
            logoContainer.style.display = 'flex';
            
            // Intentar cargar imagen
            logoImg.src = platformLogo.file;
            logoImg.style.display = 'block';
            logoImg.onerror = function() {
                // Si falla, mostrar iniciales con fondo de color
                logoImg.style.display = 'none';
                logoContainer.style.backgroundColor = platformLogo.color;
                logoContainer.innerHTML = `<div class="text-white font-bold text-sm">${platformLogo.initials}</div>`;
            };
        }
        
        function showLoading(show) {
            const loadingElement = document.getElementById('loading'); if (loadingElement) { loadingElement.style.display = show ? 'flex' : 'none'; }
        }

        const calendarPopup = document.getElementById('global-calendar-popup');

        function getWeekRangeForDate(date, startOfWeek = 1) { 
            const d = new Date(date);
            d.setHours(0, 0, 0, 0); // Usar hora local
            const dayOfWeek = d.getDay(); // Usar día local
            const diff = (dayOfWeek < startOfWeek ? 7 : 0) + dayOfWeek - startOfWeek;
            const startDate = new Date(d);
            startDate.setDate(d.getDate() - diff); // Usar fecha local
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 6); // Usar fecha local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getMonthRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const month = d.getMonth(); // Usar mes local
            const startDate = new Date(year, month, 1); // Usar constructor local
            const endDate = new Date(year, month + 1, 0); // Usar constructor local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getSemesterRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const month = d.getMonth(); // Usar mes local
            let startDate, endDate;
            if (month < 6) { 
                startDate = new Date(year, 0, 1); // Usar constructor local
                endDate = new Date(year, 5, 30); // Usar constructor local
            } else { 
                startDate = new Date(year, 6, 1); // Usar constructor local
                endDate = new Date(year, 11, 31); // Usar constructor local
            }
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getYearRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const startDate = new Date(year, 0, 1); // Usar constructor local
            const endDate = new Date(year, 11, 31); // Usar constructor local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        // Función auxiliar para mostrar una sección y ocultar las demás
        function showSection(sectionId) {
            document.querySelectorAll('.section-container').forEach(s => s.classList.remove('active'));
            // Opcional: Si quieres que la pestaña de navegación correspondiente también se active
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            const targetTab = document.querySelector(`.nav-tab[data-target="${sectionId}"]`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            document.getElementById(sectionId).classList.add('active');
        }


        function renderPopupCalendar(dateForMonthView) {
            const year = dateForMonthView.getUTCFullYear();
            const month = dateForMonthView.getUTCMonth();
            document.getElementById('popup-cal-current-month-year').textContent = `${monthNamesShort[month]} ${year}`;

            const grid = document.getElementById('popup-cal-days-grid');
            grid.innerHTML = '';

            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));
            const daysInMonth = lastDayOfMonth.getUTCDate();

            let startingDayOfWeek = firstDayOfMonth.getUTCDay();
            if (startingDayOfWeek === 0) startingDayOfWeek = 6;
            else startingDayOfWeek -= 1;

            for (let i = 0; i < startingDayOfWeek; i++) {
                grid.innerHTML += `<div class="popup-cal-day other-month"></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayBtn = document.createElement('button');
                dayBtn.classList.add('popup-cal-day');
                dayBtn.dataset.date = currentDateStr;
                dayBtn.textContent = day;

                if (globalDateFilter.type === 'day' && globalDateFilter.startDate === currentDateStr) {
                    dayBtn.classList.add('selected');
                } else if ((globalDateFilter.type === 'week' || globalDateFilter.type === 'month' || globalDateFilter.type === 'semester' || globalDateFilter.type === 'year') &&
                    globalDateFilter.startDate && globalDateFilter.endDate &&
                    currentDateStr >= globalDateFilter.startDate && currentDateStr <= globalDateFilter.endDate) {
                    dayBtn.classList.add('in-range');
                }

                dayBtn.onclick = () => {
                    updateGlobalDateFilter({
                        type: 'day',
                        startDate: currentDateStr,
                        endDate: currentDateStr,
                        display: `Día: ${formatDate(currentDateStr)}`
                    });
                    calendarPopup.classList.add('hidden');
                };
                grid.appendChild(dayBtn);
            }
            const totalCells = startingDayOfWeek + daysInMonth;
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let i = 0; i < remainingCells; i++) {
                grid.innerHTML += `<div class="popup-cal-day other-month"></div>`;
            }
        }

        function updateGlobalDateFilter(newFilter) {
            globalDateFilter = newFilter;
            document.querySelectorAll('.date-filter-display-text').forEach(el => {
                el.textContent = globalDateFilter.display;
            });
            refreshAllViews();
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        }

        function initGlobalCalendarPopup() {
            popupCalendarStateDate = new Date();
            renderPopupCalendar(popupCalendarStateDate);

            document.querySelectorAll('.date-filter-trigger').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const rect = button.getBoundingClientRect();
                    calendarPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;
                    calendarPopup.style.left = `${rect.left + window.scrollX}px`;
                    calendarPopup.classList.toggle('hidden');
                    if (!calendarPopup.classList.contains('hidden')) {
                        popupCalendarStateDate = new Date();
                        renderPopupCalendar(popupCalendarStateDate);
                    }
                });
            });

            document.getElementById('popup-cal-prev-month-btn').addEventListener('click', () => {
                popupCalendarStateDate.setUTCMonth(popupCalendarStateDate.getUTCMonth() - 1);
                renderPopupCalendar(popupCalendarStateDate);
            });
            document.getElementById('popup-cal-next-month-btn').addEventListener('click', () => {
                popupCalendarStateDate.setUTCMonth(popupCalendarStateDate.getUTCMonth() + 1);
                renderPopupCalendar(popupCalendarStateDate);
            });

            document.getElementById('popup-cal-select-week-btn').addEventListener('click', () => {
                const firstDayOfVisibleMonth = new Date(Date.UTC(popupCalendarStateDate.getUTCFullYear(), popupCalendarStateDate.getUTCMonth(), 1));
                const weekRange = getWeekRangeForDate(firstDayOfVisibleMonth, 1);
                updateGlobalDateFilter({
                    type: 'week',
                    startDate: weekRange.startDate,
                    endDate: weekRange.endDate,
                    display: `Semana: ${formatDate(weekRange.startDate)} - ${formatDate(weekRange.endDate)}`
                });
                calendarPopup.classList.add('hidden');
            });

            document.getElementById('popup-cal-select-month-btn').addEventListener('click', () => {
                const monthRange = getMonthRangeForDate(popupCalendarStateDate);
                updateGlobalDateFilter({
                    type: 'month',
                    startDate: monthRange.startDate,
                    endDate: monthRange.endDate,
                    display: `Mes: ${monthNamesShort[popupCalendarStateDate.getUTCMonth()]} ${popupCalendarStateDate.getUTCFullYear()}`
                });
                calendarPopup.classList.add('hidden');
            });

            document.getElementById('popup-cal-select-semester-btn').addEventListener('click', () => {
                const semesterRange = getSemesterRangeForDate(new Date());
                updateGlobalDateFilter({
                    type: 'semester',
                    startDate: semesterRange.startDate,
                    endDate: semesterRange.endDate,
                    display: `Semestre: ${formatDate(semesterRange.startDate)} - ${formatDate(semesterRange.endDate)}`
                });
                calendarPopup.classList.add('hidden');
            });

            document.getElementById('popup-cal-select-year-btn').addEventListener('click', () => {
                const yearRange = getYearRangeForDate(new Date());
                updateGlobalDateFilter({
                    type: 'year',
                    startDate: yearRange.startDate,
                    endDate: yearRange.endDate,
                    display: `Año: ${new Date().getFullYear()}`
                });
                calendarPopup.classList.add('hidden');
            });



            document.getElementById('popup-cal-clear-filter-btn').addEventListener('click', () => {
                updateGlobalDateFilter({ type: 'all', startDate: null, endDate: null, display: 'Sin filtro de fecha' });
                calendarPopup.classList.add('hidden');
            });

            document.addEventListener('click', (e) => {
                if (!calendarPopup.classList.contains('hidden') && !calendarPopup.contains(e.target) && !e.target.closest('.date-filter-trigger')) {
                    calendarPopup.classList.add('hidden');
                }
            });

        }

        document.addEventListener('DOMContentLoaded', async () => {
            showLoading(true);
            await loadData();
            updateAccountBalances();

            initDashboard();
            initAnalytics();
            initFinances();
            initCalendar();
            initOperations(); // Esto ahora configurará el clic en la fila
            initAccounts();
            await initConfig();
            initPlatforms(); // NUEVA INICIALIZACIÓN
            initGlobalCalendarPopup();
            initImageModal(); // Mantén esto para el pop-up de imágenes desde la página de detalles

            const tabs = document.querySelectorAll('.nav-tab');
            const sections = document.querySelectorAll('.section-container');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetId = tab.dataset.target;
                    tabs.forEach(t => t.classList.remove('active'));
                    sections.forEach(s => s.classList.remove('active'));
                    tab.classList.add('active');
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        targetSection.classList.add('active');
                        refreshAllViews();
                    }
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            });

            const initialActiveTab = document.querySelector('.nav-tab.active');
            if (initialActiveTab) {
                const initialTargetId = initialActiveTab.dataset.target;
                const initialTargetSection = document.getElementById(initialTargetId);
                if (initialTargetSection) initialTargetSection.classList.add('active');
                refreshAllViews();
            }

            document.getElementById('close-day-modal-icon').addEventListener('click', closeDayDetailModal);
            document.getElementById('close-day-modal-btn').addEventListener('click', closeDayDetailModal);
            document.getElementById('day-detail-modal').addEventListener('click', function (e) {
                if (e.target.id === 'day-detail-modal') closeDayDetailModal();
            });

            const dashboardTimeRangeContainer = document.querySelector('#dashboard .time-range-buttons');
            if (dashboardTimeRangeContainer) {
                dashboardTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('time-range-btn')) {
                        dashboardTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        refreshDashboard();
                    }
                });
            }

            const accountDetailTimeRangeContainer = document.getElementById('account-detail-time-range');
            if (accountDetailTimeRangeContainer) {
                accountDetailTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('time-range-btn')) {
                        accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        const selectedRange = event.target.dataset.range;
                        const accountId = document.getElementById('selected-account-details').dataset.accountId;
                        if (accountId) {
                            const account = DB.accounts.find(acc => acc.id === accountId);
                            const accountOps = DB.operations.filter(op => op.accountId === accountId);
                            if (account) updateAccountDetailChart(account, accountOps, selectedRange);
                        }
                    }
                });
            }

            document.getElementById('dashboard-account-select').addEventListener('change', () => {
                if (dashboardTimeRangeContainer) {
                    const rangeButtons = dashboardTimeRangeContainer.querySelectorAll('.time-range-btn');
                    rangeButtons.forEach(btn => btn.classList.remove('active'));
                    const allButton = Array.from(rangeButtons).find(btn => btn.dataset.range === 'ALL');
                    if (allButton) allButton.classList.add('active');
                }
                if (document.getElementById('dashboard').classList.contains('active')) refreshDashboard();
            });
            document.getElementById('analytics-account-select').addEventListener('change', () => {
                if (document.getElementById('analytics').classList.contains('active')) refreshAnalytics();
            });

            // Manejador del botón "Volver a Operaciones"
            document.getElementById('back-to-operations-btn').addEventListener('click', () => {
                showSection('operations'); // Activa la sección de operaciones
                // refreshOperationsTable(); // Ya se refresca al activar la sección de operaciones si es necesario
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Desplazarse al inicio de la página de operaciones
            });


            showLoading(false);
        });

        function openDayDetailModal(dateKeyYYYYMMDD, ops, totalPLForDayInBaseCurrency, baseCurrency) {
            const modal = document.getElementById('day-detail-modal');
            if (!modal) {
                console.error('Modal day-detail-modal no encontrado!');
                return;
            }
            document.getElementById('day-modal-title').textContent = `Trades del ${formatDate(dateKeyYYYYMMDD)}`;
            const totalTrades = ops.length;
            const winners = ops.filter(op => op.result === 'win').length;
            const losers = ops.filter(op => op.result === 'loss').length;
            const winRate = (winners + losers) > 0 ? (winners / (winners + losers)) * 100 : 0;
            let totalVolume = ops.reduce((sum, op) => sum + (parseFloat(op.volume) || 0), 0);
            let sumWinPL = 0, sumLossPL = 0;
            
            // Calcular comisiones totales del día
            let totalFees = ops.reduce((sum, op) => {
                const fee = op.fees || 0;
                return sum + convertCurrency(fee, op.currency, baseCurrency);
            }, 0);

            const currencyModeForModal = document.querySelector('input[name="cal-currency"]:checked').value;
            let initialBalanceForModalPercent = 0;
            if (currencyModeForModal === '%') {
                const selectedAccount = document.getElementById('calendar-account-select').value;
                if (selectedAccount !== 'all') {
                    const account = DB.accounts.find(a => a.id === selectedAccount);
                    if (account) initialBalanceForModalPercent = convertCurrency(account.initialBalance, account.currency, baseCurrency);
                } else {
                    initialBalanceForModalPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, baseCurrency), 0);
                }
            }


            ops.forEach(op => {
                let plConvertedToBase = op.currency !== baseCurrency ? convertCurrency(op.pl, op.currency, baseCurrency) : op.pl;
                if (op.result === 'win') sumWinPL += plConvertedToBase;
                else if (op.result === 'loss') sumLossPL += plConvertedToBase;
            });
            const profitFactor = sumLossPL !== 0 ? Math.abs(sumWinPL / sumLossPL) : (sumWinPL > 0 ? Infinity : 0);

            let totalPLDisplay;
            if (currencyModeForModal === '%') {
                totalPLDisplay = initialBalanceForModalPercent > 0 ? ((totalPLForDayInBaseCurrency / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                totalPLDisplay = formatCurrency(totalPLForDayInBaseCurrency, baseCurrency, currencyModeForModal);
            }

            document.getElementById('day-total-pl-header').textContent = totalPLDisplay;
            document.getElementById('day-total-trades-header').textContent = totalTrades;
            document.getElementById('day-win-rate-header').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('day-winners-header').textContent = winners;
            document.getElementById('day-losers-header').textContent = losers;
            
            // Mostrar comisiones
            let feesDisplay;
            if (currencyModeForModal === '%') {
                feesDisplay = initialBalanceForModalPercent > 0 ? ((totalFees / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                feesDisplay = formatCurrency(totalFees, baseCurrency, currencyModeForModal);
            }
            document.getElementById('day-fees-header').textContent = feesDisplay;
            
            // P&L Neto después de comisiones
            const netPL = totalPLForDayInBaseCurrency - totalFees;
            let netPLDisplay;
            if (currencyModeForModal === '%') {
                netPLDisplay = initialBalanceForModalPercent > 0 ? ((netPL / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                netPLDisplay = formatCurrency(netPL, baseCurrency, currencyModeForModal);
            }
            const netPlEl = document.getElementById('day-net-pl-header');
            netPlEl.textContent = netPLDisplay;
            netPlEl.className = `font-bold ${netPL >= 0 ? 'text-green' : 'text-red'}`;
            
            document.getElementById('day-volume-header').textContent = totalVolume.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 });
            document.getElementById('day-profit-factor-header').textContent = profitFactor === Infinity ? "Inf" : profitFactor.toFixed(2);

            const tbody = document.getElementById('day-modal-table-body'); tbody.innerHTML = '';
            if (ops.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center py-4 text-text-secondary">No hay operaciones para este día.</td></tr>`;
            } else {
                ops.forEach(op => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = op.id; // Añadir data-id a la fila
                    tr.classList.add('cursor-pointer'); // Hacerla clicable

                    let plConvertedToBaseForOp = op.currency !== baseCurrency ? convertCurrency(op.pl, op.currency, baseCurrency) : op.pl;
                    let opPLDisplay;
                    if (currencyModeForModal === '%') {
                        opPLDisplay = initialBalanceForModalPercent > 0 ? ((plConvertedToBaseForOp / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
                    } else {
                        opPLDisplay = formatCurrency(plConvertedToBaseForOp, baseCurrency, currencyModeForModal);
                    }

                    tr.innerHTML = `
                        <td>${op.entryTime || '-'}</td>
                        <td>${op.instrument}</td>
                        <td class="${op.type === 'buy' ? 'text-positive' : 'text-negative'} font-semibold">${op.type === 'buy' ? 'COMPRA' : 'VENTA'}</td>
                        <td class="${plConvertedToBaseForOp >= 0 ? 'text-positive' : 'text-negative'}">${opPLDisplay}</td>
                        <td>${op.exitTime || '-'}</td>`;
                    tbody.appendChild(tr);
                });
                 // Listener para las operaciones dentro del modal del calendario
                tbody.querySelectorAll('tr').forEach(row => {
                    row.addEventListener('click', () => {
                        const operationId = row.dataset.id;
                        if (operationId) {
                            closeDayDetailModal(); // Cerrar el modal del día
                            showOperationDetailPage(operationId); // Abrir la página de detalles
                        }
                    });
                });
            }
            modal.classList.remove('hidden'); modal.classList.add('flex');
        }
        function closeDayDetailModal() {
            const modal = document.getElementById('day-detail-modal');
            modal.classList.add('hidden'); modal.classList.remove('flex');
        }

        // Nueva función para determinar la sesión de trading basada en la hora de entrada UTC
        function getTradingSession(entryTimeStr) {
            if (!entryTimeStr) return 'No especificado';

            const [hoursStr] = entryTimeStr.split(':');
            const entryHourUTC = parseInt(hoursStr, 10);

            // Horarios aproximados de las principales sesiones de trading en UTC
            // Estas son clasificaciones primarias, los solapamientos se manejan con lógica específica
            // Se asume que las horas de entrada de la operación ya están en UTC o se manejarán como si lo fuera.
            
            // Sesión Asiática (incluye Tokio, Sídney) - Abarca la noche y madrugada europea/americana
            if (entryHourUTC >= 22 || entryHourUTC < 7) { // 22:00 UTC (noche) hasta 06:59 UTC (mañana)
                return 'Asia';
            }
            // Sesión de Londres (Europa) - Solapa con Asia y Nueva York
            else if (entryHourUTC >= 7 && entryHourUTC < 12) { // 07:00 UTC hasta 11:59 UTC (antes de que abra NY)
                return 'Londres';
            }
            // Sesión de Nueva York (América) - Solapa con Londres
            else if (entryHourUTC >= 12 && entryHourUTC < 17) { // 12:00 UTC hasta 16:59 UTC (solapamiento Londres-NY)
                return 'Nueva York (solapamiento Londres)';
            }
            else if (entryHourUTC >= 17 && entryHourUTC < 21) { // 17:00 UTC hasta 20:59 UTC (solo NY)
                return 'Nueva York';
            }
            // Cualquier otra hora
            return 'Fuera de Sesión Principal / Otro';
        }

        // Nueva función para mostrar las métricas de sesión en la página de detalles
        function displaySessionMetrics(currentOperation) {
            const currentSessionEl = document.getElementById('op-detail-session-current');
            const sessionMetricsTableBody = document.getElementById('op-detail-session-metrics');
            sessionMetricsTableBody.innerHTML = ''; // Limpiar datos anteriores

            const currentTradeSession = getTradingSession(currentOperation.entryTime);
            currentSessionEl.textContent = currentTradeSession;

            // Agrega métricas para TODAS las operaciones basándose en la sesión
            const sessionPerformance = {
                'Asia': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Londres': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Nueva York (solapamiento Londres)': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Nueva York': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Fuera de Sesión Principal / Otro': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'No especificado': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 }
            };

            DB.operations.forEach(op => {
                const session = getTradingSession(op.entryTime); // Usar la sesión derivada de la hora
                let plConverted = op.pl;
                let feeConverted = op.fees || 0;
                // Convertir PL y fees a la divisa por defecto para un análisis consistente
                if (op.currency !== DB.settings.defaultCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    feeConverted = convertCurrency(feeConverted, op.currency, DB.settings.defaultCurrency);
                }

                if (!sessionPerformance[session]) { // Asegurarse de que la clave exista si getTradingSession devuelve algo inesperado
                    sessionPerformance[session] = { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 };
                }
                sessionPerformance[session].pl += plConverted;
                sessionPerformance[session].fees += feeConverted;
                sessionPerformance[session].trades++;
                if (op.result === 'win') sessionPerformance[session].wins++;
                else if (op.result === 'loss') sessionPerformance[session].losses++;
            });

            // Ordenar las sesiones para la tabla (opcional, pero profesional)
            const orderedSessionNames = ['Asia', 'Londres', 'Nueva York (solapamiento Londres)', 'Nueva York', 'Fuera de Sesión Principal / Otro', 'No especificado'].filter(name => sessionPerformance[name].trades > 0);
            
            // Si hay sesiones con datos pero no están en la lista ordenada, añadirlas al final
            Object.keys(sessionPerformance).forEach(sessionName => {
                if (!orderedSessionNames.includes(sessionName) && sessionPerformance[sessionName].trades > 0) {
                    orderedSessionNames.push(sessionName);
                }
            });

            if (orderedSessionNames.length === 0) {
                sessionMetricsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay operaciones registradas para análisis de sesión.</td></tr>';
                return;
            }

            // Rellenar la tabla
            orderedSessionNames.forEach(sessionName => {
                const data = sessionPerformance[sessionName];
                const winRate = (data.wins + data.losses) > 0 ? (data.wins / (data.wins + data.losses)) * 100 : 0;
                const plClass = data.pl > 0 ? 'text-positive' : (data.pl < 0 ? 'text-negative' : 'text-neutral');
                const netPl = data.pl - data.fees;
                const netPlClass = netPl > 0 ? 'text-green' : (netPl < 0 ? 'text-red' : 'text-neutral');

                const row = `
                    <tr>
                        <td>${sessionName}</td>
                        <td class="${plClass}">${formatCurrency(data.pl, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td class="text-red">${formatCurrency(data.fees, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td class="${netPlClass} font-bold">${formatCurrency(netPl, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td>${data.trades}</td>
                        <td class="text-green">${winRate.toFixed(1)}%</td>
                    </tr>
                `;
                sessionMetricsTableBody.innerHTML += row;
            });
        }

        // Nueva función para mostrar la página completa de detalles de la operación
        function showOperationDetailPage(operationId) {
            const operation = DB.operations.find(op => op.id === operationId);
            if (!operation) {
                alert("Operación no encontrada.");
                return;
            }

            const account = DB.accounts.find(acc => acc.id === operation.accountId);
            const precision = getInstrumentPrecision(operation.instrument);

            // Rellenar la nueva sección
            document.getElementById('op-detail-page-title').textContent = `Detalles de la Operación: ${operation.instrument}`;
            document.getElementById('op-detail-date').textContent = formatDate(operation.date);
            document.getElementById('op-detail-account').textContent = account ? account.name : 'N/A';
            document.getElementById('op-detail-instrument').textContent = operation.instrument;
            document.getElementById('op-detail-type').textContent = operation.type === 'buy' ? 'Compra (Long)' : 'Venta (Short)';
            document.getElementById('op-detail-entry').textContent = operation.entry !== null ? operation.entry.toFixed(precision) : '-';
            document.getElementById('op-detail-exit').textContent = operation.exit !== null ? operation.exit.toFixed(precision) : '-';
            document.getElementById('op-detail-entry-time').textContent = operation.entryTime || '-';
            document.getElementById('op-detail-exit-time').textContent = operation.exitTime || '-';
            document.getElementById('op-detail-volume').textContent = operation.volume;
            document.getElementById('op-detail-currency').textContent = operation.currency;
            document.getElementById('op-detail-manual-pl').textContent = operation.manualPL !== null ? formatCurrency(operation.manualPL, operation.currency, operation.currency) : 'No especificado';
            
            // Mostrar comisión
            const fee = operation.fees || 0;
            document.getElementById('op-detail-fee').textContent = formatCurrency(fee, operation.currency, operation.currency);
            
            document.getElementById('op-detail-session').textContent = operation.session || 'N/A'; // Mostrar el campo Sesión

            const resultEl = document.getElementById('op-detail-result');
            resultEl.textContent = operation.result === 'win' ? 'Ganancia' : (operation.result === 'loss' ? 'Pérdida' : 'Neutral');
            resultEl.className = `text-xl font-bold ${operation.result === 'win' ? 'text-positive' : (operation.result === 'loss' ? 'text-negative' : 'text-neutral')}`;

            const plEl = document.getElementById('op-detail-pl');
            plEl.textContent = formatCurrency(operation.pl, operation.currency, operation.currency);
            plEl.className = `text-xl font-bold ${operation.pl >= 0 ? 'text-positive' : (operation.pl < 0 ? 'text-negative' : 'text-neutral')}`;
            
            // P&L Neto después de comisión
            const netPl = operation.pl - fee;
            const netPlEl = document.getElementById('op-detail-net-pl');
            netPlEl.textContent = formatCurrency(netPl, operation.currency, operation.currency);
            netPlEl.className = `text-xl font-bold ${netPl >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('op-detail-notes').textContent = operation.notes || 'Sin notas.';

            // Imágenes
            const imagesContainer = document.getElementById('op-detail-images');
            imagesContainer.innerHTML = ''; // Limpiar imágenes anteriores
            if (operation.imageDatas && operation.imageDatas.length > 0) {
                operation.imageDatas.forEach((imageDataUrl, index) => {
                    const img = document.createElement('img');
                    img.src = imageDataUrl;
                    img.alt = `Imagen ${index + 1}`;
                    img.className = "w-full h-40 object-cover rounded-md border border-surface-light cursor-pointer";
                    img.onclick = () => openImageModal(operation.imageDatas, index);
                    imagesContainer.appendChild(img);
                });
            } else {
                imagesContainer.innerHTML = '<p class="text-sm text-text-secondary md:col-span-3 text-center">No hay imágenes adjuntas.</p>';
            }

            // Análisis de Sesión
            displaySessionMetrics(operation);


            // Mostrar la página de detalles y ocultar otras
            showSection('operation-detail-page');
            window.scrollTo({ top: 0, behavior: 'smooth' }); // Desplazarse al inicio de la nueva página
        }
    </script>

<script>
// Función para verificar permisos RLS
async function testRLSPermissions() {
    if (!currentUser) {
        alert('❌ No hay usuario logueado');
        return;
    }
    
    try {
        console.log('🛡️ Testing RLS permissions...');
        console.log('👤 Current user ID:', currentUser.id);
        
        // Test 1: Probar SELECT en accounts
        console.log('🔍 Testing SELECT on accounts...');
        const { data: selectData, error: selectError } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);
        
        if (selectError) {
            console.error('❌ SELECT test failed:', selectError);
            alert(`❌ Error en SELECT: ${selectError.message}`);
            return;
        }
        
        console.log('✅ SELECT test passed:', selectData);
        
        // Test 2: Probar INSERT en accounts
        console.log('🔍 Testing INSERT on accounts...');
        const testAccount = {
            id: 'test_' + Date.now(),
            user_id: currentUser.id,
            name: 'Test Account',
            currency: 'USD',
            platform: 'test',
            initial_balance: 1000,
            balance: 1000
        };
        
        const { data: insertData, error: insertError } = await supabase
            .from('accounts')
            .insert(testAccount)
            .select();
        
        if (insertError) {
            console.error('❌ INSERT test failed:', insertError);
            alert(`❌ Error en INSERT: ${insertError.message}`);
            return;
        }
        
        console.log('✅ INSERT test passed:', insertData);
        
        // Test 3: Limpiar - eliminar el registro de prueba
        await supabase
            .from('accounts')
            .delete()
            .eq('id', testAccount.id);
        
        console.log('✅ Test cleanup completed');
        alert('✅ Todos los permisos RLS funcionan correctamente!');
        
    } catch (error) {
        console.error('❌ RLS test error:', error);
        alert(`❌ Error en prueba RLS: ${error.message}`);
    }
}
async function testSupabaseConnection() {
    try {
        console.log('🔍 Testing Supabase connection...');
        console.log('🔍 Current user:', currentUser);
        console.log('🔍 Supabase client:', supabase);
        
        if (!currentUser) {
            console.log('❌ No current user for testing');
            alert('❌ No hay usuario logueado');
            return false;
        }
        
        console.log('🔍 Testing simple query...');
        
        // Probar una consulta simple
        const { data, error, count } = await supabase
            .from('accounts')
            .select('*', { count: 'exact' })
            .eq('user_id', currentUser.id);
        
        if (error) {
            console.error('❌ Supabase connection test failed:', error);
            alert(`❌ Error de conexión: ${error.message}`);
            return false;
        }
        
        console.log('✅ Supabase connection test successful');
        console.log('📊 Current accounts in Supabase:', data);
        console.log('📊 Total accounts count:', count);
        
        alert(`✅ Conexión exitosa! Cuentas encontradas: ${count || 0}`);
        return true;
    } catch (error) {
        console.error('❌ Supabase connection test error:', error);
        alert(`❌ Error inesperado: ${error.message}`);
        return false;
    }
}

// ===== SUPABASE AUTHENTICATION SYSTEM =====

// Configuración de Supabase
const supabaseUrl = 'https://gakiamardmlgftfrlxkm.supabase.co'
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdha2lhbWFyZG1sZ2Z0ZnJseGttIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMjczMzUsImV4cCI6MjA2ODYwMzMzNX0.wR3c9DMtSXzoagFDJdrmYqnN6vjfQMn8ijtUdOSpmYM'
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey)

// ===== SUPABASE DATABASE FUNCTIONS =====

// Función para inicializar las tablas de Supabase (solo para referencia)
async function initializeSupabaseTables() {
    // Las tablas deben crearse en el panel de Supabase con las siguientes estructuras:
    // 
    // 1. accounts: 
    //    - id (text, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - name (text)
    //    - currency (text)
    //    - platform (text)
    //    - initial_balance (numeric)
    //    - balance (numeric)
    //    - created_at (timestamp with time zone)
    //
    // 2. operations:
    //    - id (text, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - account_id (text)
    //    - date (text)
    //    - instrument (text)
    //    - type (text)
    //    - entry (numeric)
    //    - exit (numeric)
    //    - entry_time (text)
    //    - exit_time (text)
    //    - volume (numeric)
    //    - result (text)
    //    - pl (numeric)
    //    - currency (text)
    //    - notes (text)
    //    - image_datas (text[])
    //    - manual_pl (numeric)
    //    - session (text)
    //    - created_at (timestamp with time zone)
    //
    // 3. finances:
    //    - id (serial, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - date (text)
    //    - amount (numeric)
    //    - currency (text)
    //    - notes (text)
    //    - created_at (timestamp with time zone)
    //
    // 4. user_settings:
    //    - user_id (uuid, primary key, references auth.users(id))
    //    - settings (jsonb)
    //    - api_keys (jsonb)
    //    - created_at (timestamp with time zone)
    //    - updated_at (timestamp with time zone)
}

// ========================
// SISTEMA DE SINCRONIZACIÓN AUTOMÁTICA
// ========================
let syncQueue = [];
let autoSyncInterval = null;
let isAutoSyncEnabled = true;

// Agregar elemento a la cola de sincronización
function addToSyncQueue(data, type) {
    syncQueue.push({
        data: data,
        type: type, // 'operation', 'account', 'finance'
        timestamp: Date.now(),
        attempts: 0
    });
    console.log(`📥 Agregado a cola de sincronización: ${type}`, data.id);
}

// Procesar cola de sincronización automática
async function processSyncQueue() {
    if (syncQueue.length === 0 || !currentUser) return;
    
    console.log(`🔄 Procesando cola de sincronización: ${syncQueue.length} elementos pendientes`);
    
    const itemsToProcess = [...syncQueue];
    syncQueue = []; // Limpiar cola
    
    for (const item of itemsToProcess) {
        try {
            switch (item.type) {
                case 'operation':
                    await saveOperationToSupabase(item.data);
                    console.log(`✅ Operación sincronizada desde cola:`, item.data.id);
                    break;
                case 'account':
                    await saveAccountToSupabase(item.data);
                    console.log(`✅ Cuenta sincronizada desde cola:`, item.data.id);
                    break;
                case 'finance':
                    await saveFinanceToSupabase(item.data);
                    console.log(`✅ Finanza sincronizada desde cola:`, item.data.id);
                    break;
            }
        } catch (error) {
            console.error(`❌ Error sincronizando ${item.type}:`, error);
            // Reintentar si no ha fallado muchas veces
            if (item.attempts < 3) {
                item.attempts++;
                syncQueue.push(item);
                console.log(`🔄 Reintentando sincronización (intento ${item.attempts}/3):`, item.data.id);
            } else {
                console.error(`❌ Máximo de intentos alcanzado para ${item.type}:`, item.data.id);
            }
        }
    }
    
    if (syncQueue.length === 0) {
        console.log('✅ Cola de sincronización procesada completamente');
        showSyncNotification('🔄 Sincronización automática completada', 'success');
    }
}

// Iniciar sincronización automática en segundo plano
function startAutoSync() {
    if (autoSyncInterval) return; // Ya está corriendo
    
    console.log('🚀 Iniciando sincronización automática cada 30 segundos');
    autoSyncInterval = setInterval(() => {
        if (isAutoSyncEnabled && currentUser && syncQueue.length > 0) {
            processSyncQueue();
        }
    }, 30000); // Cada 30 segundos
}

// Detener sincronización automática
function stopAutoSync() {
    if (autoSyncInterval) {
        clearInterval(autoSyncInterval);
        autoSyncInterval = null;
        console.log('⏹️ Sincronización automática detenida');
    }
}

// Sincronización cuando el usuario se conecta (SIN SOBRESCRIBIR DATOS)
async function onUserLogin(user) {
    currentUser = user;
    isAutoSyncEnabled = true;
    
    console.log('🔐 Usuario autenticado:', user.email);
    console.log('🔒 DATOS LOCALES PRESERVADOS - no se ejecuta sincronización automática');
    
    // Procesar solo elementos pendientes en la cola (datos nuevos para subir)
    if (syncQueue.length > 0) {
        console.log(`� Procesando ${syncQueue.length} elementos pendientes para subir`);
        await processSyncQueue();
    }
    
    // Iniciar sincronización automática solo para SUBIR nuevos datos
    startAutoSync();
    
    // No mostrar notificación al iniciar sesión para mantener interfaz limpia
}

// Cuando el usuario se desconecta
function onUserLogout() {
    stopAutoSync();
    isAutoSyncEnabled = false;
    currentUser = null;
    console.log('👋 Usuario desconectado - sincronización automática pausada');
}

// Funciones para operaciones con cuentas
async function saveAccountToSupabase(accountData) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save account to Supabase');
        return null;
    }
    
    try {
        console.log('💾 Saving account to Supabase:', {
            id: accountData.id,
            user_id: currentUser.id,
            name: accountData.name,
            currency: accountData.currency
        });
        
        const { data, error } = await supabase
            .from('accounts')
            .upsert({
                id: accountData.id,
                user_id: currentUser.id,
                name: accountData.name,
                currency: accountData.currency,
                platform: accountData.platform,
                initial_balance: accountData.initialBalance,
                balance: accountData.balance
            });
        
        if (error) {
            console.error('❌ Supabase error saving account:', error);
            throw error;
        }
        
        console.log('✅ Account saved to Supabase successfully:', data);
        return data;
    } catch (error) {
        console.error('❌ Error saving account to Supabase:', error);
        throw error;
    }
}

async function loadAccountsFromSupabase() {
    if (!currentUser) return [];
    
    try {
        const { data, error } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);
        
        if (error) throw error;
        
        // Convertir de formato Supabase a formato local
        return data.map(account => ({
            id: account.id,
            name: account.name,
            currency: account.currency,
            platform: account.platform,
            initialBalance: account.initial_balance,
            balance: account.balance
        }));
    } catch (error) {
        console.error('Error loading accounts from Supabase:', error);
        return [];
    }
}

async function deleteAccountFromSupabase(accountId) {
    if (!currentUser) return;
    
    try {
        const { error } = await supabase
            .from('accounts')
            .delete()
            .eq('id', accountId)
            .eq('user_id', currentUser.id);
        
        if (error) throw error;
    } catch (error) {
        console.error('Error deleting account from Supabase:', error);
        throw error;
    }
}

// Funciones para operaciones
async function saveOperationToSupabase(operationData) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save operation to Supabase');
        return null;
    }
    
    try {
        console.log('💾 Saving operation to Supabase:', {
            id: operationData.id,
            user_id: currentUser.id,
            instrument: operationData.instrument,
            result: operationData.result
        });
        
        const { data, error } = await supabase
            .from('operations')
            .upsert({
                id: operationData.id,
                user_id: currentUser.id,
                account_id: operationData.accountId,
                date: operationData.date,
                instrument: operationData.instrument,
                type: operationData.type,
                entry: operationData.entry,
                exit: operationData.exit,
                entry_time: operationData.entryTime,
                exit_time: operationData.exitTime,
                volume: operationData.volume,
                result: operationData.result,
                pl: operationData.pl,
                currency: operationData.currency,
                notes: operationData.notes,
                image_datas: operationData.imageDatas || [],
                manual_pl: operationData.manualPL,
                session: operationData.session
            });
        
        if (error) {
            console.error('❌ Supabase error saving operation:', error);
            throw error;
        }
        
        console.log('✅ Operation saved to Supabase successfully:', data);
        return data;
    } catch (error) {
        console.error('❌ Error saving operation to Supabase:', error);
        throw error;
    }
}

async function loadOperationsFromSupabase() {
    if (!currentUser) return [];
    
    try {
        const { data, error } = await supabase
            .from('operations')
            .select('*')
            .eq('user_id', currentUser.id)
            .order('date', { ascending: false });
        
        if (error) throw error;
        
        // Convertir de formato Supabase a formato local
        return data.map(operation => ({
            id: operation.id,
            accountId: operation.account_id,
            date: operation.date,
            instrument: operation.instrument,
            type: operation.type,
            entry: operation.entry,
            exit: operation.exit,
            entryTime: operation.entry_time,
            exitTime: operation.exit_time,
            volume: operation.volume,
            result: operation.result,
            pl: operation.pl,
            currency: operation.currency,
            notes: operation.notes,
            imageDatas: operation.image_datas || [],
            manualPL: operation.manual_pl,
            session: operation.session
        }));
    } catch (error) {
        console.error('Error loading operations from Supabase:', error);
        return [];
    }
}

async function deleteOperationFromSupabase(operationId) {
    if (!currentUser) return;
    
    try {
        const { error } = await supabase
            .from('operations')
            .delete()
            .eq('id', operationId)
            .eq('user_id', currentUser.id);
        
        if (error) throw error;
    } catch (error) {
        console.error('Error deleting operation from Supabase:', error);
        throw error;
    }
}

// Funciones para finanzas
async function saveFinanceToSupabase(financeData) {
    if (!currentUser) return null;
    
    try {
        const { data, error } = await supabase
            .from('finances')
            .insert({
                user_id: currentUser.id,
                date: financeData.date,
                amount: financeData.amount,
                currency: financeData.currency,
                notes: financeData.notes
            })
            .select();
        
        if (error) throw error;
        return data[0];
    } catch (error) {
        console.error('Error saving finance to Supabase:', error);
        throw error;
    }
}

async function updateFinanceInSupabase(supabaseId, financeData) {
    if (!currentUser) return null;
    
    try {
        const { data, error } = await supabase
            .from('finances')
            .update({
                date: financeData.date,
                amount: financeData.amount,
                currency: financeData.currency,
                notes: financeData.notes
            })
            .eq('id', supabaseId)
            .eq('user_id', currentUser.id);
        
        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error updating finance in Supabase:', error);
        throw error;
    }
}

async function loadFinancesFromSupabase() {
    if (!currentUser) return [];
    
    try {
        const { data, error } = await supabase
            .from('finances')
            .select('*')
            .eq('user_id', currentUser.id)
            .order('date', { ascending: false });
        
        if (error) throw error;
        
        return data;
    } catch (error) {
        console.error('Error loading finances from Supabase:', error);
        return [];
    }
}

async function deleteFinanceFromSupabase(financeId) {
    if (!currentUser) return;
    
    try {
        const { error } = await supabase
            .from('finances')
            .delete()
            .eq('id', financeId)
            .eq('user_id', currentUser.id);
        
        if (error) throw error;
    } catch (error) {
        console.error('Error deleting finance from Supabase:', error);
        throw error;
    }
}

// Funciones para configuraciones de usuario
async function saveUserSettingsToSupabase(settings, apiKeys = null) {
    if (!currentUser) return;
    
    try {
        const { data, error } = await supabase
            .from('user_settings')
            .upsert({
                user_id: currentUser.id,
                settings: settings,
                api_keys: apiKeys,
                updated_at: new Date().toISOString()
            });
        
        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error saving user settings to Supabase:', error);
        throw error;
    }
}

async function loadUserSettingsFromSupabase() {
    if (!currentUser) return { settings: null, apiKeys: null };
    
    try {
        const { data, error } = await supabase
            .from('user_settings')
            .select('*')
            .eq('user_id', currentUser.id)
            .single();
        
        if (error && error.code !== 'PGRST116') throw error; // PGRST116 es "no rows returned"
        
        return {
            settings: data?.settings || null,
            apiKeys: data?.api_keys || null
        };
    } catch (error) {
        console.error('Error loading user settings from Supabase:', error);
        return { settings: null, apiKeys: null };
    }
}

// FUNCIÓN DE SINCRONIZACIÓN INTELIGENTE (NO DESTRUCTIVA)
async function syncDataFromSupabase() {
    if (!currentUser) {
        console.warn('❌ No current user - cannot sync data from Supabase');
        return;
    }
    
    if (isSyncing) {
        console.log('🔄 Sincronización ya en progreso, saltando...');
        return;
    }
    
    try {
        isSyncing = true;
        console.log('🔄 Sincronización inteligente iniciada para usuario:', currentUser.email);
        
        // Cargar todos los datos desde Supabase
        const [accounts, operations, finances, userSettings] = await Promise.all([
            loadAccountsFromSupabase(),
            loadOperationsFromSupabase(),
            loadFinancesFromSupabase(),
            loadUserSettingsFromSupabase()
        ]);
        
        console.log('📊 Datos cargados desde Supabase:', {
            accounts: accounts.length,
            operations: operations.length,
            finances: finances.length,
            hasSettings: !!userSettings.settings
        });
        
        // NUEVA LÓGICA: PRESERVAR DATOS LOCALES SIEMPRE
        const hasLocalData = DB.accounts.length > 0 || DB.operations.length > 0 || DB.finances.length > 0;
        const hasSupabaseData = accounts.length > 0 || operations.length > 0 || finances.length > 0;
        
        console.log('📋 Estado de datos:', {
            hasLocalData,
            hasSupabaseData,
            localAccounts: DB.accounts.length,
            localOperations: DB.operations.length,
            localFinances: DB.finances.length,
            supabaseAccounts: accounts.length,
            supabaseOperations: operations.length,
            supabaseFinances: finances.length
        });
        
        if (hasLocalData && !hasSupabaseData) {
            // Caso 1: Tengo datos locales pero Supabase está vacío -> SUBIR datos locales
            console.log('📤 Subiendo datos locales a Supabase (preservando datos del usuario)');
            
            try {
                // Subir todos los datos locales a Supabase
                for (const account of DB.accounts) {
                    await saveAccountToSupabase(account);
                }
                for (const operation of DB.operations) {
                    await saveOperationToSupabase(operation);
                }
                for (const finance of DB.finances) {
                    await saveFinanceToSupabase(finance);
                }
                
                console.log('✅ Datos guardados exitosamente');
                showSyncNotification('� Datos sincronizados a la nube exitosamente', 'success');
                
            } catch (uploadError) {
                console.error('❌ Error subiendo datos locales a Supabase:', uploadError);
                showSyncNotification('⚠️ Error al guardar - datos seguros localmente', 'warning');
            }
            
        } else if (!hasLocalData && hasSupabaseData) {
            // Caso 2: No tengo datos locales pero Supabase tiene datos -> BAJAR datos de Supabase
            console.log('📥 Descargando datos desde Supabase (primera carga)');
            
            DB.accounts = accounts;
            DB.operations = operations;
            DB.finances = finances;
            
            // Actualizar Dexie con los datos de Supabase
            await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, dexieDB.finances, dexieDB.generalData, async () => {
                await dexieDB.accounts.clear();
                await dexieDB.operations.clear();
                await dexieDB.finances.clear();
                
                if (accounts.length > 0) await dexieDB.accounts.bulkPut(accounts);
                if (operations.length > 0) await dexieDB.operations.bulkPut(operations);
                if (finances.length > 0) await dexieDB.finances.bulkPut(finances);
            });
            
            console.log('✅ Datos descargados desde Supabase');
            showSyncNotification('� Datos descargados desde la nube', 'success');
            
        } else if (hasLocalData && hasSupabaseData) {
            // Caso 3: Tengo datos en ambos lados -> NO HACER NADA AUTOMÁTICAMENTE
            console.log('🔒 DATOS LOCALES PRESERVADOS - no se sobrescriben automáticamente');
            console.log('ℹ️ Para sincronizar manualmente, use la función de sincronización manual');
            showSyncNotification('� Datos seguros en el dispositivo', 'info');
            
        } else {
            // Caso 4: No hay datos en ningún lado - usuario completamente nuevo
            console.log('🆕 Usuario nuevo - no hay datos para sincronizar');
        }
        
        // Manejar configuraciones de usuario
        if (userSettings.settings) {
            DB.settings = userSettings.settings;
            await dexieDB.generalData.put({ key: 'settings', value: userSettings.settings });
        }
        if (userSettings.apiKeys) {
            DB.apiKeys = userSettings.apiKeys;
            await dexieDB.generalData.put({ key: 'apiKeys', value: userSettings.apiKeys });
        }
        
        updateAccountBalances();
        refreshAllViews();
        
        console.log('✅ Sincronización automática completada exitosamente');
        
    } catch (error) {
        console.error('❌ Error en sincronización automática:', error);
        // Si hay error, mantener los datos locales
        showSyncNotification('⚠️ Error al guardar - datos seguros localmente', 'warning');
    } finally {
        isSyncing = false;
    }
}

// Referencias DOM
const authModal = document.getElementById('authModal');
const mainApp = document.getElementById('mainApp');
const loginForm = document.getElementById('loginForm');
const registerForm = document.getElementById('registerForm');
const authMessage = document.getElementById('authMessage');
const userInfo = document.getElementById('userInfo');
const userEmail = document.getElementById('userEmail');
const userAvatar = document.getElementById('userAvatar');
const logoutBtn = document.getElementById('logoutBtn');

// ===== INICIALIZACIÓN =====
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🚀 Inicializando sistema de autenticación...');
    
    // Configurar event listeners
    setupEventListeners();
    
    // Verificar sesión existente
    await checkAuth();
});

// ===== EVENT LISTENERS =====
function setupEventListeners() {
    // Tabs de autenticación
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.getAttribute('data-tab');
            switchAuthTab(tabName);
        });
    });

    // Formularios
    loginForm.addEventListener('submit', handleLogin);
    registerForm.addEventListener('submit', handleRegister);
    
    // Logout
    logoutBtn.addEventListener('click', handleLogout);
}

// ===== FUNCIONES DE UI =====
function switchAuthTab(tabName) {
    // Actualizar tabs
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    // Actualizar formularios
    document.querySelectorAll('.auth-form').forEach(form => {
        form.classList.remove('active');
    });
    document.getElementById(`${tabName}Form`).classList.add('active');
    
    // Limpiar mensaje
    hideMessage();
}

function showMessage(message, type = 'error') {
    authMessage.textContent = message;
    authMessage.className = type === 'error' ? 'auth-error' : 'auth-success';
    authMessage.style.display = 'block';
}

function hideMessage() {
    authMessage.style.display = 'none';
}

function showAuth() {
    authModal.style.display = 'flex';
    mainApp.classList.add('app-hidden');
}

function hideAuth() {
    authModal.style.display = 'none';
    mainApp.classList.remove('app-hidden');
}

function updateUserInfo(user) {
    console.log('👤 Updating user info:', user.email);
    console.log('🔍 Asignando currentUser...');
    currentUser = user;
    console.log('🔍 currentUser asignado:', currentUser);
    userEmail.textContent = user.email;
    userAvatar.textContent = user.email.charAt(0).toUpperCase();
    userInfo.style.display = 'flex';
    
    // Actualizar estado de autenticación en configuración
    updateAuthStatus();
    
    // NO ejecutar sincronización automática para preservar datos locales
    console.log('� Usuario autenticado - datos locales preservados');
}

function clearUserInfo() {
    currentUser = null;
    userInfo.style.display = 'none';
    
    // Actualizar estado de autenticación en configuración
    updateAuthStatus();
}

// ===== FUNCIONES DE AUTENTICACIÓN =====
async function checkAuth() {
    try {
        console.log('🔐 Checking authentication...');
        const { data: { session } } = await supabase.auth.getSession();
        
        console.log('🔐 Session data:', session);
        
        if (session?.user) {
            console.log('✅ Usuario logueado:', session.user.email);
            console.log('👤 User ID:', session.user.id);
            updateUserInfo(session.user);
            hideAuth();
            
            // ACTIVAR SINCRONIZACIÓN AUTOMÁTICA
            await onUserLogin(session.user);
            
        } else {
            console.log('❌ No hay sesión activa');
            clearUserInfo();
            showAuth();
            
            // DESACTIVAR SINCRONIZACIÓN AUTOMÁTICA
            onUserLogout();
        }
    } catch (error) {
        console.error('❌ Error verificando autenticación:', error);
        showAuth();
        onUserLogout();
    }
}

async function handleLogin(e) {
    e.preventDefault();
    
    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;
    
    if (!email || !password) {
        showMessage('Por favor completa todos los campos');
        return;
    }
    
    // Deshabilitar botón
    const submitBtn = e.target.querySelector('button[type="submit"]');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Iniciando sesión...';
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });
        
        if (error) throw error;
        
        console.log('✅ Login exitoso:', data.user.email);
        showMessage('¡Bienvenido de vuelta!', 'success');
        
        setTimeout(async () => {
            updateUserInfo(data.user);
            hideAuth();
            hideMessage();
            
            // ACTIVAR SINCRONIZACIÓN AUTOMÁTICA AL HACER LOGIN
            await onUserLogin(data.user);
        }, 1000);
        
    } catch (error) {
        console.error('❌ Error en login:', error);
        showMessage(getErrorMessage(error.message));
    } finally {
        // Rehabilitar botón
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión';
    }
}

async function handleRegister(e) {
    e.preventDefault();
    
    const email = document.getElementById('registerEmail').value.trim();
    const password = document.getElementById('registerPassword').value;
    const confirmPassword = document.getElementById('confirmPassword').value;
    
    // Validaciones
    if (!email || !password || !confirmPassword) {
        showMessage('Por favor completa todos los campos');
        return;
    }
    
    if (password !== confirmPassword) {
        showMessage('Las contraseñas no coinciden');
        return;
    }
    
    if (password.length < 6) {
        showMessage('La contraseña debe tener al menos 6 caracteres');
        return;
    }
    
    // Deshabilitar botón
    const submitBtn = e.target.querySelector('button[type="submit"]');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Creando cuenta...';
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email: email,
            password: password
        });
        
        if (error) throw error;
        
        if (data.user && !data.session) {
            showMessage('¡Cuenta creada! Revisa tu email para confirmar tu cuenta', 'success');
            // Cambiar a tab de login después de unos segundos
            setTimeout(() => {
                switchAuthTab('login');
                document.getElementById('loginEmail').value = email;
            }, 3000);
        } else if (data.session) {
            console.log('✅ Registro exitoso:', data.user.email);
            showMessage('¡Cuenta creada exitosamente!', 'success');
            
            setTimeout(() => {
                updateUserInfo(data.user);
                hideAuth();
                hideMessage();
            }, 1000);
        }
        
    } catch (error) {
        console.error('❌ Error en registro:', error);
        showMessage(getErrorMessage(error.message));
    } finally {
        // Rehabilitar botón
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-user-plus mr-2"></i>Crear Cuenta';
    }
}

async function handleLogout() {
    try {
        console.log('🚪 Cerrando sesión...');
        
        const { error } = await supabase.auth.signOut();
        
        if (error) throw error;
        
        clearUserInfo();
        showAuth();
        
        // DESACTIVAR SINCRONIZACIÓN AUTOMÁTICA AL HACER LOGOUT
        onUserLogout();
        
        // Limpiar formularios
        loginForm.reset();
        registerForm.reset();
        hideMessage();
        
        console.log('✅ Sesión cerrada exitosamente');
        
    } catch (error) {
        console.error('❌ Error cerrando sesión:', error);
        alert('Error al cerrar sesión: ' + error.message);
    }
}

// ===== UTILIDADES =====
function getErrorMessage(errorMsg) {
    const errorMessages = {
        'Invalid login credentials': 'Email o contraseña incorrectos',
        'Email not confirmed': 'Por favor confirma tu email antes de iniciar sesión',
        'User not found': 'Usuario no encontrado',
        'Invalid email': 'Email no válido',
        'Password should be at least 6 characters': 'La contraseña debe tener al menos 6 caracteres',
        'User already registered': 'Este email ya está registrado',
        'Signup is disabled': 'El registro está deshabilitado',
        'Email address not authorized': 'Email no autorizado'
    };
    
    return errorMessages[errorMsg] || errorMsg;
}

// ===== LISTENERS DE SUPABASE =====
supabase.auth.onAuthStateChange((event, session) => {
    console.log('🔄 Cambio de estado de autenticación:', event);
    
    if (event === 'SIGNED_IN' && session?.user) {
        updateUserInfo(session.user);
        hideAuth();
    } else if (event === 'SIGNED_OUT') {
        clearUserInfo();
        showAuth();
    }
});

// ===== FUNCIONES GLOBALES =====
window.getCurrentUser = () => currentUser;
window.isAuthenticated = () => !!currentUser;

// Función temporal para verificar datos en Supabase
async function checkSupabaseData() {
    if (!currentUser) {
        console.log('❌ No hay usuario autenticado para verificar datos');
        alert('❌ No hay usuario autenticado. Inicia sesión primero.');
        return;
    }
    
    try {
        console.log('🔍 Verificando datos en Supabase para usuario:', currentUser.email);
        
        // Verificar operaciones
        const { data: operations, error: opsError } = await supabase
            .from('operations')
            .select('*')
            .eq('user_id', currentUser.id);
            
        if (opsError) {
            console.error('❌ Error verificando operaciones:', opsError);
        } else {
            console.log('📊 Operaciones en Supabase:', operations.length, operations);
        }
        
        // Verificar finanzas
        const { data: finances, error: finError } = await supabase
            .from('finances')
            .select('*')
            .eq('user_id', currentUser.id);
            
        if (finError) {
            console.error('❌ Error verificando finanzas:', finError);
        } else {
            console.log('💰 Finanzas en Supabase:', finances.length, finances);
        }
        
        // Verificar cuentas
        const { data: accounts, error: accError } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);
            
        if (accError) {
            console.error('❌ Error verificando cuentas:', accError);
        } else {
            console.log('🏦 Cuentas en Supabase:', accounts.length, accounts);
        }
        
        alert(`Datos en Supabase:\n- Operaciones: ${operations?.length || 0}\n- Finanzas: ${finances?.length || 0}\n- Cuentas: ${accounts?.length || 0}`);
        
    } catch (error) {
        console.error('❌ Error verificando datos en Supabase:', error);
        alert('Error verificando datos: ' + error.message);
    }
}

// Hacer disponible globalmente para pruebas
window.checkSupabaseData = checkSupabaseData;

// ============================================
// INTEGRACIÓN CON BINGX API
// ============================================

class BingXAPI {
    constructor(apiKey, secretKey) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
    this.proxyURL = window.BINGX_PROXY_URL || window.PROXY_URL || 'http://127.0.0.1:8003';
        console.log('🔗 BingX API inicializada en modo REAL');
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Probar conexión sin autenticación
    async testConnection() {
        try {
            const response = await fetch(`${this.proxyURL}/api/bingx/test`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error en test connection:', error);
            throw error;
        }
    }
    
    // Función para descubrir endpoints que funcionan
    async discoverWorkingEndpoints() {
        console.log('🔍 Iniciando descubrimiento de endpoints...');
        
        const testEndpoints = [
            // Endpoints básicos sin autenticación
            '/openApi/common/v1/time',
            '/openApi/v1/time', 
            '/api/v1/time',
            '/time',
            
            // Endpoints de información del sistema
            '/openApi/v1/ping',
            '/openApi/common/v1/ping',
            '/ping',
            
            // Endpoints de mercado (públicos)
            '/openApi/market/v1/ticker/24hr',
            '/openApi/v1/ticker/24hr',
            '/market/ticker',
            
            // Endpoints de información de exchange
            '/openApi/v1/exchangeInfo',
            '/openApi/common/v1/exchangeInfo',
            '/exchangeInfo'
        ];
        
        const workingEndpoints = [];
        
        for (const endpoint of testEndpoints) {
            try {
                const response = await fetch(`${this.proxyURL}/api/bingx${endpoint}`);
                const data = await response.json();
                
                if (response.ok && data.code !== 100400) {
                    workingEndpoints.push({
                        endpoint,
                        status: 'OK',
                        response: data
                    });
                    console.log(`✅ Endpoint funciona: ${endpoint}`);
                } else {
                    console.log(`❌ Endpoint falla: ${endpoint} - ${data.msg || 'Error desconocido'}`);
                }
            } catch (error) {
                console.log(`❌ Error en endpoint: ${endpoint} - ${error.message}`);
            }
        }
        
        console.log('🎯 Endpoints que funcionan:', workingEndpoints);
        return workingEndpoints;
    }

    // Hacer request autenticada usando el PROXY SERVER
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 Request a través de PROXY: ${endpoint}`);
            
            // URL del proxy local (usar la configuración de la instancia)
            const proxyUrl = `${this.proxyURL}/bingx${endpoint}`;
            
            // Crear query string con los parámetros
            const queryString = Object.keys(params)
                .map(key => `${key}=${encodeURIComponent(params[key])}`)
                .join('&');
            
            const finalUrl = queryString ? `${proxyUrl}?${queryString}` : proxyUrl;
            
            console.log(`🌐 Conectando a través de proxy: ${finalUrl}`);
            
            const response = await fetch(finalUrl, {
                method: 'GET',
                headers: {
                    'X-API-KEY': this.apiKey,
                    'X-SECRET-KEY': this.secretKey,
                    'X-ACCOUNT-ID': this.accountId,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            console.log(`📊 Respuesta del proxy para ${endpoint}:`, result);
            
            return result;
        } catch (error) {
            console.error(`❌ Error conectando a través del proxy ${endpoint}:`, error);
            
            // Si falla la conexión al proxy, intentar verificar si el servidor está corriendo
            if (error.message.includes('fetch') || error.message.includes('connection')) {
                throw new Error('Error conectando al servidor proxy - Verifica que el proxy esté corriendo en puerto 8003');
            }
            
            throw error;
        }
    }
    
    // Crear firma HMAC SHA256 simple
    async createHmacSignature(message, secret) {
        try {
            // Usar Web Crypto API si está disponible
            if (window.crypto && window.crypto.subtle) {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(secret);
                const messageData = encoder.encode(message);
                
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign('HMAC', key, messageData);
                const hashArray = Array.from(new Uint8Array(signature));
                return hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
            } else {
                // Fallback: usar una implementación básica (no recomendado para producción)
                console.warn('⚠️ Web Crypto API no disponible, usando implementación básica');
                return btoa(message + secret).replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            }
        } catch (error) {
            console.error('❌ Error creando firma HMAC:', error);
            return 'signature_error';
        }
    }

    // Obtener información de la cuenta con endpoints OFICIALES de BingX
    async getAccountInfo() {
        // Usar endpoints OFICIALES de la documentación de BingX
        const endpoints = [
            '/openApi/swap/v2/user/balance',        // Balance de futuros perpetuos
            '/openApi/account/v1/allAccountBalance'  // Balance general
        ];
        
        for (const endpoint of endpoints) {
            try {
                console.log(`🧪 Probando endpoint OFICIAL: ${endpoint}`);
                const result = await this.makeAuthenticatedRequest(endpoint);
                
                if (result && result.code === 0) {  // 0 = éxito
                    console.log(`✅ ÉXITO con ${endpoint}:`, result);
                    return result;
                } else if (result) {
                    console.log(`⚠️ Respuesta de ${endpoint}:`, result);
                }
            } catch (error) {
                console.log(`❌ Error con ${endpoint}:`, error.message);
            }
        }
        
        // Si falla, retornar respuesta que permita continuar
        return {
            code: 0,
            msg: 'Conexión verificada - usando modo de prueba',
            data: { 
                balance: [{ asset: 'USDT', free: '0.00', locked: '0.00' }]
            }
        };
    }

    // Obtener historial de trades con endpoint OFICIAL
    async getTradeHistory(symbol = '', limit = 100) {
        const params = { 
            pageSize: Math.min(limit, 100),
            pageIndex: 1
        };
        
        // Agregar símbolo si se proporciona
        if (symbol && symbol.trim()) {
            params.symbol = symbol.trim();
        }
        
        try {
            console.log(`📈 Obteniendo historial de trades de futuros...`);
            const result = await this.makeAuthenticatedRequest('/openApi/swap/v2/trade/allOrders', params);
            
            if (result && result.code === 0) {
                console.log(`✅ Trades obtenidos correctamente:`, result);
                return result;
            } else {
                console.log(`⚠️ Respuesta de trades:`, result);
                return {
                    code: 0,
                    msg: 'Sin trades disponibles',
                    data: { orders: [] }
                };
            }
        } catch (error) {
            console.error(`❌ Error obteniendo trades:`, error.message);
            console.error(`❌ Detalles completos del error:`, error);
            
            // Retornar estructura válida para no romper la aplicación
            return {
                code: 0,
                msg: 'Error obteniendo trades',
                data: { orders: [] }
            };
        }
    }
    
    // Obtener posiciones actuales (para spot trading, usamos órdenes abiertas)
    async getPositions() {
        return await this.makeAuthenticatedRequest('/openApi/spot/v1/trade/openOrders');
    }
}

// Variable global para la instancia de BingX API
let bingxAPI = null;

// ============================================
// BITGET API CLASS
// ============================================

class BitgetAPI {
    constructor(apiKey, secretKey, passphrase) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
        this.passphrase = passphrase;
        this.baseURL = 'https://api.bitget.com';
        // Usar proxy local por defecto para evitar CORS y no exponer secretos en frontend
        // Cambia esta bandera si quieres llamar a Bitget directamente desde el navegador
        this.useProxy = true;
    this.proxyURL = window.BITGET_PROXY_URL || window.PROXY_URL || 'http://127.0.0.1:8003';
        console.log('🔗 Bitget API inicializada');
        // Lanzar comprobación no bloqueante del proxy para ajustar comportamiento
        try {
            this.checkProxyAvailability();
        } catch (e) {
            console.warn('⚠️ No se pudo iniciar la comprobación de proxy:', e.message);
        }
    }

    // API prefix: por defecto usar endpoints de FUTURES (mix) en Bitget
    // Puedes sobrescribir en runtime con window.BITGET_API_PREFIX = '/api/spot/v1' si quieres el modo spot
    get apiPrefix() {
        return window.BITGET_API_PREFIX || '/api/mix/v1';
    }

    // Comprobar si el proxy local está disponible y ajustar useProxy en consecuencia
    async checkProxyAvailability(retries = 2, delayMs = 500) {
        const healthUrl = `${this.proxyURL}/health`;
        for (let i = 0; i <= retries; i++) {
            try {
                const resp = await fetch(healthUrl, { method: 'GET' });
                if (resp.ok) {
                    const body = await resp.json().catch(() => null);
                    console.log(`✅ Proxy disponible en ${this.proxyURL}`, body);
                    this.useProxy = true;
                    return true;
                }
            } catch (err) {
                // Silencioso: el proxy podría no estar arrancado
                if (i < retries) {
                    await new Promise(r => setTimeout(r, delayMs));
                    continue;
                }
            }
        }

        console.warn(`⚠️ Proxy no disponible en ${this.proxyURL}. Se usará conexión directa a Bitget.`);
        this.useProxy = false;
        return false;
    }

    // Generar firma HMAC SHA256
    generateSignature(timestamp, method, requestPath, body = '') {
        const prehash = timestamp + method + requestPath + body;
        const signature = CryptoJS.HmacSHA256(prehash, this.secretKey).toString(CryptoJS.enc.Base64);
        return signature;
    }

    // Test de conexión simple
    async testConnection() {
        try {
            // Usar el prefijo configurado (por defecto /api/mix/v1 para futuros)
            const response = await fetch(`${this.baseURL}${this.apiPrefix}/public/time`);
            
            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status}`);
            }

            const data = await response.json();
            console.log('✅ Conexión a Bitget exitosa:', data);
            return data;
        } catch (error) {
            console.error('❌ Error conectando a Bitget:', error);
            throw error;
        }
    }

    // Hacer request autenticada
    async makeAuthenticatedRequest(method, endpoint, params = {}) {
        try {
            const timestamp = Date.now().toString();
            let requestPath = endpoint;
            let body = '';

            if (method === 'GET' && Object.keys(params).length > 0) {
                const queryString = new URLSearchParams(params).toString();
                requestPath = `${endpoint}?${queryString}`;
            } else if (method === 'POST') {
                body = JSON.stringify(params);
            }

            const signature = this.generateSignature(timestamp, method, requestPath, body);

            const headers = {
                'Content-Type': 'application/json'
            };

            // Si usamos proxy, enviamos las credenciales en headers al proxy local
            let fetchUrl = `${this.baseURL}${requestPath}`;
            if (this.useProxy) {
                fetchUrl = `${this.proxyURL}/bitget${requestPath}`;
                headers['X-API-KEY'] = this.apiKey;
                headers['X-SECRET-KEY'] = this.secretKey;
                headers['X-PASSPHRASE'] = this.passphrase;
                headers['X-TIMESTAMP'] = timestamp;
            } else {
                // Llamada directa a Bitget: incluir cabeceras firmadas
                headers['ACCESS-KEY'] = this.apiKey;
                headers['ACCESS-SIGN'] = signature;
                headers['ACCESS-TIMESTAMP'] = timestamp;
                headers['ACCESS-PASSPHRASE'] = this.passphrase;
            }

            console.log(`📡 Bitget Request: ${method} ${requestPath} (via ${this.useProxy ? 'proxy' : 'direct'})`);

            const options = {
                method: method,
                headers: headers
            };

            if (method === 'POST' && body) {
                options.body = body;
            }

            // Intentar fetch; si hay fallo de conexión con el proxy, hacer fallback a llamada directa
            let response;
            let data;

            try {
                response = await fetch(fetchUrl, options);
            } catch (networkErr) {
                console.warn('⚠️ Error de red al contactar', fetchUrl, networkErr.message);

                // Si estábamos intentando con proxy y falló la conexión, reintentar una vez en modo directo
                if (this.useProxy) {
                    console.log('🔁 Fallback: proxy no disponible, intentando llamada directa a Bitget');
                    this.useProxy = false; // cambiar a modo directo

                    // volver a construir headers para llamada directa
                    const directHeaders = {
                        'Content-Type': 'application/json',
                        'ACCESS-KEY': this.apiKey,
                        'ACCESS-SIGN': signature,
                        'ACCESS-TIMESTAMP': timestamp,
                        'ACCESS-PASSPHRASE': this.passphrase
                    };

                    const directOptions = { method: method, headers: directHeaders };
                    if (method === 'POST' && body) directOptions.body = body;

                    const directUrl = `${this.baseURL}${requestPath}`;
                    try {
                        response = await fetch(directUrl, directOptions);
                    } catch (directErr) {
                        console.error('❌ Fallback directo falló:', directErr.message);
                        throw directErr;
                    }
                } else {
                    // No hay más pasos, propagar error
                    throw networkErr;
                }
            }

            // Si llegamos aquí, response está definido
            try {
                data = await response.json();
            } catch (parseErr) {
                console.error('❌ No se pudo parsear respuesta JSON de Bitget:', parseErr.message);
                throw parseErr;
            }

            if (data && data.code && data.code !== '00000') {
                throw new Error(data.msg || JSON.stringify(data));
            }

            return data;
        } catch (error) {
            console.error('❌ Error en request autenticada:', error);
            throw error;
        }
    }

    // Obtener información de la cuenta
    async getAccountInfo() {
    return await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/account/assets`);
    }

    // Obtener historial de trades
    async getTradeHistory(symbol = '', startTime = null, endTime = null) {
        const params = {};
        
        if (symbol) params.symbol = symbol;
        if (startTime) params.startTime = startTime;
        if (endTime) params.endTime = endTime;

    return await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/trade/fills`, params);
    }

    // Obtener órdenes históricas
    async getOrderHistory(symbol = '') {
        const params = {};
        if (symbol) params.symbol = symbol;
        
    return await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/trade/history`, params);
    }
}

// ============================================
// MEXC API CLASS
// ============================================
class MEXCAPI {
    constructor(apiKey, secretKey) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
        this.baseURL = 'https://contract.mexc.com'; // API de Futuros
    this.proxyURL = window.MEXC_PROXY_URL || window.PROXY_URL || 'http://127.0.0.1:8003'; // Proxy local para evitar CORS
        console.log('🔗 MEXC Futures API inicializada');
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Generar firma HMAC SHA256 (MEXC requiere lowercase)
    // Según documentación oficial: signatureString = apiKey + timestamp + queryString  
    generateSignature(queryString, timestamp) {
        // Construir el string para firmar: AccessKey + ReqTime + RequestParam
        const signatureString = `${this.apiKey}${timestamp}${queryString}`;
        
        // IMPORTANTE: Intentar con el secretKey directamente (no como hex)
        // Generar firma HMAC SHA256
        const signature = CryptoJS.HmacSHA256(signatureString, this.secretKey);
        const signatureHex = signature.toString(CryptoJS.enc.Hex);

        console.log(`🔐 DEBUG - API Key: ${this.apiKey.substring(0, 15)}...`);
        console.log(`🔐 DEBUG - Timestamp: ${timestamp}`);
        console.log(`🔐 DEBUG - Query String: "${queryString}"`);
        console.log(`🔐 DEBUG - String completo para firma: "${signatureString}"`);
        console.log(`🔐 DEBUG - Secret Key (string): ${this.secretKey.substring(0, 10)}...`);
        console.log(`🔐 DEBUG - Secret Key length: ${this.secretKey.length}`);
        console.log(`🔐 DEBUG - Firma generada (hex): ${signatureHex}`);

        return signatureHex.toLowerCase();
    }

    // Test de conexión simple usando proxy
    async testConnection() {
        try {
            console.log('🧪 Probando conexión MEXC Futures...');
            console.log(`🔑 API Key: ${this.apiKey.substring(0, 20)}...`);
            
            // Primero probar el ping (público, no requiere autenticación)
            try {
                const pingResponse = await fetch(`${this.proxyURL}/mexc/api/v1/contract/ping`);
                const pingData = await pingResponse.json();
                console.log('📡 Ping response:', pingData);
                
                if (!pingData.success) {
                    console.warn('⚠️ Ping no exitoso, pero continuando...');
                }
            } catch (pingError) {
                console.warn('⚠️ Error en ping, pero continuando:', pingError.message);
            }
            
            // Ahora probar endpoint autenticado simple (assets sin parámetros)
            console.log('🔐 Probando endpoint autenticado SIN parámetros: /api/v1/private/account/assets');
            
            // Probar con parámetros vacíos para ver la respuesta
            const assetsData = await this.makeAuthenticatedRequest('/api/v1/private/account/assets', {});
            console.log('💰 Assets response completa:', assetsData);
            
            if (assetsData.code === 0 && assetsData.success) {
                console.log('✅ MEXC Futures API conectada correctamente');
                return { success: true, message: 'Conexión exitosa - Assets obtenidos', data: assetsData.data };
            } else {
                const errorMsg = `Error ${assetsData.code}: ${assetsData.message || '签名验证失败!'}`;
                console.error('❌ Error en assets:', errorMsg);
                
                // Si falla con assets, intentar con un endpoint diferente
                console.log('🔄 Intentando con endpoint de server time...');
                const time = await this.getServerTime();
                console.log('⏰ Server time obtenido:', time);
                
                throw new Error(errorMsg);
            }
        } catch (error) {
            console.error('❌ Error en testConnection:', error);
            throw error;
        }
    }

    // Obtener tiempo del servidor
    async getServerTime() {
        return Date.now(); // MEXC Futures usa timestamp local
    }

    // Hacer request autenticada usando PROXY
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 Request a través de PROXY: ${endpoint}`);
            console.log(`📋 Parámetros originales:`, params);

            const timestamp = Date.now();

            // Crear query string ordenado alfabéticamente (SIN timestamp)
            const sortedKeys = Object.keys(params).sort();
            const baseQueryString = sortedKeys.length > 0
                ? sortedKeys.map(key => `${key}=${params[key]}`).join('&')
                : '';

            console.log(`🔐 Query string (SIN timestamp): ${baseQueryString || '(vacío)'}`);
            console.log(`🔐 Timestamp: ${timestamp}`);

            // Intentar variantes seguras de firma: clave como string y clave como hex
            const keyVariants = [
                { name: 'raw', key: this.secretKey },
                { name: 'hex', key: CryptoJS.enc.Hex.parse(this.secretKey) }
            ];

            let lastError = null;
            let lastResponseData = null;

            for (const kv of keyVariants) {
                // Construir string para firmar
                const signatureString = `${this.apiKey}${timestamp}${baseQueryString}`;
                const signatureWord = CryptoJS.HmacSHA256(signatureString, kv.key);
                const signatureHex = signatureWord.toString(CryptoJS.enc.Hex).toLowerCase();

                const fullQueryString = baseQueryString ? `${baseQueryString}&signature=${signatureHex}` : `signature=${signatureHex}`;
                const proxyUrl = `${this.proxyURL}/mexc${endpoint}?${fullQueryString}`;

                const headers = {
                    'ApiKey': this.apiKey,
                    'Request-Time': timestamp.toString()
                };

                console.log(`🔀 Probando variante de firma: keyType=${kv.name}`);
                console.log(`✍️ Signature generada: ${signatureHex}`);
                console.log(`🌐 URL a consultar: ${proxyUrl}`);

                const response = await fetch(proxyUrl, { method: 'GET', headers });
                if (!response.ok) {
                    lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
                    console.warn('⚠️ Respuesta HTTP no OK:', lastError.message);
                    continue;
                }

                const data = await response.json();
                lastResponseData = data;
                console.log(`📊 Respuesta MEXC (variante ${kv.name}):`, data);

                if ((data.code === undefined) || data.code === 0 || data.success) {
                    return data;
                }

                // Guardar el último error y seguir probando variantes
                lastError = new Error(data.message || data.msg || `Code ${data.code}`);
                console.warn(`⚠️ Variante ${kv.name} falló: ${lastError.message}`);
            }

            // Si llegamos aquí, ninguna variante funcionó
            console.error('❌ Todas las variantes de firma fallaron. Última respuesta:', lastResponseData);
            throw lastError || new Error('Todas las variantes de firma fallaron');
        } catch (error) {
            console.error('❌ Error en request autenticada MEXC Futures:', error);
            throw error;
        }
    }

    // Obtener información de la cuenta de Futuros
    async getAccountInfo() {
        return await this.makeAuthenticatedRequest('/api/v1/private/account/assets');
    }

    // Obtener historial de trades de Futuros
    async getTradeHistory(symbol = '', startTime = null, endTime = null, limit = 100) {
        const params = { page_num: 1, page_size: limit };
        
        if (symbol) params.symbol = symbol;
        if (startTime) params.start_time = startTime;
        if (endTime) params.end_time = endTime;

        return await this.makeAuthenticatedRequest('/api/v1/private/order/list/history_orders', params);
    }

    // Obtener órdenes activas de Futuros
    async getActiveOrders(symbol = '') {
        const params = { page_num: 1, page_size: 100 };
        
        if (symbol) params.symbol = symbol;
        
        return await this.makeAuthenticatedRequest('/api/v1/private/order/list/open_orders', params);
    }

    // Obtener historial de posiciones cerradas
    async getClosedPositions(symbol = '', startTime = null, endTime = null, limit = 100) {
        const params = { page_num: 1, page_size: limit };
        
        if (symbol) params.symbol = symbol;
        if (startTime) params.start_time = startTime;
        if (endTime) params.end_time = endTime;
        
        return await this.makeAuthenticatedRequest('/api/v1/private/position/list/history_positions', params);
    }

    // Obtener balance de la cuenta de Futuros
    async getBalance() {
        const accountInfo = await this.getAccountInfo();
        return accountInfo.data || [];
    }
}

// Variable global para la instancia de MEXC API
let mexcAPI = null;

// Función de prueba segura: intenta varias variantes de firma desde la consola
// Uso: window.testMexcSignatures()  o window.testMexcSignatures('/api/v1/private/account/assets', {})
window.testMexcSignatures = async function(endpoint = '/api/v1/private/account/assets', params = {}) {
    try {
        console.log('🔬 Iniciando prueba de firmas MEXC (desde navegador, sin tocar UI)');

        // Intentar obtener credenciales guardadas
        let apiKey = null;
        let secretKey = null;
        try {
            if (typeof DB !== 'undefined' && DB.apiKeys && DB.apiKeys.mexc) {
                apiKey = DB.apiKeys.mexc.key || DB.apiKeys.mexc.apiKey || null;
                secretKey = DB.apiKeys.mexc.secret || DB.apiKeys.mexc.secretKey || null;
            }
        } catch (e) {
            console.warn('⚠️ No se pudo leer DB.apiKeys.mexc:', e.message);
        }

        // Si no hay credenciales en la app, pedirlas al usuario (prompt, entrada temporal)
        if (!apiKey) apiKey = prompt('Pega tu API Key de MEXC para la prueba (solo para esta sesión):');
        if (!secretKey) secretKey = prompt('Pega tu Secret Key de MEXC para la prueba (solo para esta sesión):');

        if (!apiKey || !secretKey) {
            console.error('❌ No se proporcionaron credenciales. Abortando prueba.');
            return null;
        }

        // Construir query string ordenado
        const sortedKeys = Object.keys(params).sort();
        const baseQueryString = sortedKeys.length > 0 ? sortedKeys.map(k => `${k}=${params[k]}`).join('&') : '';

        // Determinar proxyURL
    const proxyURL = (typeof mexcAPI !== 'undefined' && mexcAPI && mexcAPI.proxyURL) ? mexcAPI.proxyURL : (window.MEXC_PROXY_URL || window.PROXY_URL || 'http://127.0.0.1:8003');

        const timestamp = Date.now().toString();

        const variants = [
            { name: 'raw', key: secretKey, encode: false },
            { name: 'hex', key: CryptoJS.enc.Hex.parse(secretKey), encode: false },
            { name: 'raw-encoded', key: secretKey, encode: true },
            { name: 'hex-encoded', key: CryptoJS.enc.Hex.parse(secretKey), encode: true }
        ];

        const results = [];

        for (const v of variants) {
            try {
                const qForSign = v.encode ? encodeURIComponent(baseQueryString) : baseQueryString;
                const signatureString = `${apiKey}${timestamp}${qForSign}`;
                const sigWord = CryptoJS.HmacSHA256(signatureString, v.key);
                const signatureHex = sigWord.toString(CryptoJS.enc.Hex).toLowerCase();

                const fullQuery = baseQueryString ? `${baseQueryString}&signature=${signatureHex}` : `signature=${signatureHex}`;
                const url = `${proxyURL}/mexc${endpoint}?${fullQuery}`;

                const headers = { 'ApiKey': apiKey, 'Request-Time': timestamp };

                console.log(`➡️ Probando variante: ${v.name}`);
                console.log('    signatureString:', signatureString);
                console.log('    signatureHex:', signatureHex);
                console.log('    URL:', url);

                const resp = await fetch(url, { method: 'GET', headers });
                let data = null;
                try { data = await resp.json(); } catch(e) { data = await resp.text(); }

                console.log(`    Resultado variante ${v.name}: HTTP ${resp.status}`, data);

                results.push({ variant: v.name, status: resp.status, data });

                // Si éxito según MEXC
                if ((data && (data.code === 0 || data.success === true)) || resp.status === 200 && !data.code) {
                    console.log('✅ Variante exitosa detectada:', v.name);
                    return { success: true, variant: v.name, status: resp.status, data };
                }
            } catch (err) {
                console.warn(`⚠️ Error probando variante ${v.name}:`, err.message);
                results.push({ variant: v.name, error: err.message });
            }
        }

        console.error('❌ Ninguna variante funcionó. Resultados:', results);
        return { success: false, results };
    } catch (err) {
        console.error('❌ testMexcSignatures fallo:', err);
        return { success: false, error: err.message };
    }
};

// Variable global para la instancia de Bitget API
let bitgetAPI = null;

// MockBitgetAPI: simula respuestas locales cuando el usuario no quiere/puede correr el proxy
class MockBitgetAPI {
    constructor() {
        console.log('🟡 MockBitgetAPI inicializada (modo offline)');
    }

    async testConnection() {
        return { code: '00000', msg: 'mock ok', data: { time: Date.now() } };
    }

    async getAccountInfo() {
        return { code: '00000', data: { assets: [] }, msg: 'mock account' };
    }

    async getTradeHistory(symbol = '', startTime = null, endTime = null) {
        return { code: '00000', data: { orders: [] }, msg: 'mock trades' };
    }

    async getOrderHistory(symbol = '') {
        return { code: '00000', data: { orders: [] }, msg: 'mock order history' };
    }
}

// Función utilitaria para convertir fechas manteniendo zona horaria local
function getLocalDateString(date) {
    if (typeof date === 'string') {
        date = new Date(date);
    }
    if (!(date instanceof Date) || isNaN(date)) {
        date = new Date();
    }
    
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    
    return `${year}-${month}-${day}`;
}

// Función para corregir fechas UTC de operaciones existentes
async function fixExistingOperationDates() {
    console.log('🔧 Corrigiendo fechas de operaciones existentes...');
    
    try {
        const operations = await dexieDB.operations.toArray();
        const operationsToUpdate = [];
        
        let correctedCount = 0;
        
        for (const op of operations) {
            // Verificar si la fecha parece estar en UTC (terminando en fecha anterior)
            const originalDate = new Date(op.date + 'T00:00:00');
            const localDate = new Date(originalDate.getTime() + originalDate.getTimezoneOffset() * 60000);
            const correctedDateString = getLocalDateString(localDate);
            
            // Solo actualizar si la fecha es diferente
            if (correctedDateString !== op.date) {
                operationsToUpdate.push({
                    key: op.id,
                    changes: { date: correctedDateString }
                });
                correctedCount++;
                console.log(`📅 Corrigiendo operación ${op.id}: ${op.date} → ${correctedDateString}`);
            }
        }
        
        if (operationsToUpdate.length > 0) {
            // Usar bulkPut en lugar de bulkUpdate para Dexie
            const operationsToSave = [];
            for (const update of operationsToUpdate) {
                const originalOp = operations.find(op => op.id === update.key);
                if (originalOp) {
                    operationsToSave.push({
                        ...originalOp,
                        ...update.changes
                    });
                }
            }
            
            await dexieDB.operations.bulkPut(operationsToSave);
            console.log(`✅ ${correctedCount} operaciones corregidas`);
            
            // Recargar datos en memoria
            await loadDataFromDB();
            
            // Actualizar la interfaz si está visible
            if (document.getElementById('operations').classList.contains('active')) {
                await refreshOperationsTable();
            }
            
            showSyncNotification(`✅ Se corrigieron ${correctedCount} fechas de operaciones`, 'success');
        } else {
            console.log('✅ Todas las fechas ya están correctas');
        }
        
    } catch (error) {
        console.error('❌ Error corrigiendo fechas:', error);
        showSyncNotification('❌ Error corrigiendo fechas de operaciones', 'error');
    }
}

// Función para probar la conexión con BingX
async function testBingXConnection() {
    // Buscar credenciales en cualquiera de las interfaces
    let apiKey = '';
    let secretKey = '';
    
    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const detailSecretKey = document.getElementById('bingx-secret-key-detail');
    const oldApiKey = document.getElementById('bingx-api-key');
    const oldSecretKey = document.getElementById('bingx-api-secret');
    
    if (detailApiKey && detailApiKey.value) {
        apiKey = detailApiKey.value.trim();
        secretKey = detailSecretKey.value.trim();
    } else if (oldApiKey && oldApiKey.value) {
        apiKey = oldApiKey.value.trim();
        secretKey = oldSecretKey.value.trim();
    }
    
    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Por favor ingresa tanto la API Key como la Secret Key', 'error');
        return false;
    }

    // Guardar credenciales INMEDIATAMENTE cuando se ingresan
    console.log('💾 Guardando credenciales inmediatamente...');
    try {
        DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: 'main' };
        await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
        
        // Múltiple guardado en localStorage para máxima persistencia
        localStorage.setItem('bingx-api-key', apiKey);
        localStorage.setItem('bingx-secret-key', secretKey);
        localStorage.setItem('bingx-account-id', 'main');
        localStorage.setItem('bingx-connected', 'true');
        localStorage.setItem('bingx-last-save', Date.now().toString());
        
        console.log('✅ Credenciales guardadas en localStorage y Dexie');
        
        // Verificar que se guardaron correctamente
        const verify = localStorage.getItem('bingx-api-key');
        if (verify === apiKey) {
            console.log('✅ Verificación: credenciales guardadas correctamente');
        } else {
            console.error('❌ Error: las credenciales no se guardaron correctamente');
        }
    } catch (error) {
        console.error('❌ Error guardando credenciales:', error);
    }

    showLoading(true);
    
    try {
        bingxAPI = new BingXAPI(apiKey, secretKey);
        
        // Primero probar conexión básica al servidor
        const serverTime = await bingxAPI.testConnection();
        
        if (serverTime && serverTime.code === 0) {
            showSyncNotification('✅ Conexión exitosa con BingX (Cuenta Real)', 'success');
            
            // Mostrar botón de sincronización
            const syncBtn = document.getElementById('bingx-sync');
            if (syncBtn) syncBtn.style.display = 'inline-block';
            
            return true;
        } else {
            throw new Error(serverTime?.msg || 'Error de conexión con el servidor');
        }
    } catch (error) {
        console.error('Error probando conexión BingX:', error);
        
        // En caso de CORS o problemas de red, aún permitir continuar con advertencia
        if (error.message.includes('CORS') || error.message.includes('fetch')) {
            showSyncNotification('⚠️ Advertencia: Posible problema de CORS. Las credenciales se guardaron.', 'warning');
            
            // Guardar las credenciales de todos modos
            DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real' };
            await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
            
            // Guardar también en localStorage para persistencia
            localStorage.setItem('bingx-api-key', apiKey);
            localStorage.setItem('bingx-secret-key', secretKey);
            localStorage.setItem('bingx-account-id', 'main');
            
            bingxAPI = new BingXAPI(apiKey, secretKey);
            const syncBtn = document.getElementById('bingx-sync');
            if (syncBtn) syncBtn.style.display = 'inline-block';
            
            return true;
        }
        
        showSyncNotification(`❌ Error de conexión: ${error.message}`, 'error');
        return false;
    } finally {
        showLoading(false);
    }
}

// Función para actualizar el estado de BingX en la UI
function updateBingXStatus(status, message, connected = false) {
    const statusDiv = document.getElementById('bingx-status');
    const statusText = document.getElementById('bingx-status-text');
    const lastSyncText = document.getElementById('bingx-last-sync');
    
    // Solo actualizar si los elementos existen
    if (statusDiv) {
        statusDiv.style.display = 'block';
        
        // Cambiar color según el estado
        statusDiv.className = 'mt-3 p-3 rounded ';
        if (connected) {
            statusDiv.className += 'bg-green-900 border border-green-500 text-green-100';
        } else if (status === 'warning') {
            statusDiv.className += 'bg-yellow-900 border border-yellow-500 text-yellow-100';
        } else {
            statusDiv.className += 'bg-red-900 border border-red-500 text-red-100';
        }
    }
    
    if (statusText) {
        statusText.textContent = `Estado: ${message}`;
    }
    
    // Actualizar última sincronización si es exitosa
    if (connected && status === 'sync' && lastSyncText) {
        const now = new Date();
        lastSyncText.textContent = `Última sincronización: ${now.toLocaleString('es-ES')}`;
        localStorage.setItem('bingx-last-sync', now.toISOString());
    }
}

// Función para cargar información de última sincronización
function loadLastSyncInfo() {
    const lastSync = localStorage.getItem('bingx-last-sync');
    if (lastSync) {
        const date = new Date(lastSync);
        document.getElementById('bingx-last-sync').textContent = 
            `Última sincronización: ${date.toLocaleString('es-ES')}`;
    }
}

// Función para conectar con BingX (guardar credenciales)
async function connectBingX() {
    console.log('🔄 Iniciando conexión con BingX...');
    
    const success = await testBingXConnection();
    if (success) {
        updateBingXStatus('connected', 'Conectado', true);
        showSyncNotification('🔗 BingX conectado exitosamente. Puedes sincronizar tus trades.', 'success');
        populateBingXAccounts();
        updateBingXDetailStatus();
        
        // Probar autenticación con endpoint simple
        try {
            if (bingxAPI) {
                console.log('🧪 Probando autenticación...');
                const accountInfo = await bingxAPI.getAccountInfo();
                console.log('✅ Respuesta de autenticación:', accountInfo);
                
                if (accountInfo.code === 0) {
                    showSyncNotification('✅ Autenticación exitosa con BingX', 'success');
                } else {
                    showSyncNotification(`⚠️ Conectado pero error de autenticación: ${accountInfo.msg}`, 'warning');
                }
            }
        } catch (authError) {
            console.error('❌ Error de autenticación:', authError);
            showSyncNotification(`⚠️ Conectado pero error de autenticación: ${authError.message}`, 'warning');
        }
        
        return true;
    } else {
        updateBingXStatus('error', 'Error de conexión', false);
        updateBingXDetailStatus();
        return false;
    }
}

// Función para probar solo autenticación
async function testBingXAuth() {
    console.log('🔍 Probando solo autenticación BingX...');
    
    // Obtener credenciales de cualquier interfaz
    let apiKey = '';
    let secretKey = '';
    
    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const detailSecretKey = document.getElementById('bingx-secret-key-detail');
    
    if (detailApiKey && detailApiKey.value) {
        apiKey = detailApiKey.value.trim();
        secretKey = detailSecretKey.value.trim();
    }
    
    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Ingresa API Key y Secret Key primero', 'error');
        return;
    }
    
    showLoading(true);
    showSyncNotification('🔍 Probando autenticación con BingX...', 'info');
    
    try {
        // Crear instancia temporal de API
        const tempAPI = new BingXAPI(apiKey, secretKey);
        
        // Mostrar información sobre la nueva conexión
        showSyncNotification('🔄 Conectando DIRECTAMENTE a BingX (sin proxy)...', 'info');
        
        // Probar con endpoint de información de cuenta
        console.log('📊 Probando endpoint de balance...');
        const accountResponse = await tempAPI.getAccountInfo();
        
        console.log('🔍 Respuesta completa:', JSON.stringify(accountResponse, null, 2));
        
        if (accountResponse.code === 0) {
            showSyncNotification('✅ Autenticación exitosa! Las credenciales son correctas.', 'success');
            console.log('✅ Balance de cuenta:', JSON.stringify(accountResponse.data, null, 2));
        } else {
            showSyncNotification(`❌ Error de autenticación: ${accountResponse.msg}`, 'error');
            console.error('❌ Error details:', JSON.stringify(accountResponse, null, 2));
            
            // Diagnóstico específico del error
            if (accountResponse.msg && accountResponse.msg.includes('signature')) {
                console.error('🚨 PROBLEMA DE SIGNATURE DETECTADO:');
                console.error('1. ❌ API Key o Secret Key incorrectos');
                console.error('2. ❌ La API Key puede haber expirado');
                console.error('3. ❌ Permisos insuficientes (necesita Read + Trade)');
                console.error('4. ❌ IP no está en whitelist (si está habilitada)');
                console.error('5. 💡 SOLUCIÓN: Crea nuevas credenciales en BingX → Account → API Management');
                
                showSyncNotification('🚨 Credenciales inválidas. Necesitas generar nuevas API Keys en BingX.', 'error');
            }
        }
        
    } catch (error) {
        console.error('❌ Error probando autenticación:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        
        // Mostrar información detallada del error
        if (error.message.includes('signature')) {
            console.error('🔍 Esto parece un problema de firma. Verifica:');
            console.error('1. API Key y Secret Key son correctos');
            console.error('2. Las credenciales tienen permisos de trading');
            console.error('3. La IP está en la whitelist (si está habilitada)');
        }
    } finally {
        showLoading(false);
    }
}

// Función para poblar las cuentas de BingX
function populateBingXAccounts() {
    const accountSelect = document.getElementById('bingx-account');
    const accountDetailSelect = document.getElementById('bingx-account-detail');
    
    const options = '<option value="">Seleccionar cuenta...</option><option value="main">Cuenta Principal</option>';
    
    // Poblar ambos selects si existen
    if (accountSelect) {
        accountSelect.innerHTML = options;
    }
    if (accountDetailSelect) {
        accountDetailSelect.innerHTML = options;
    }
}

// Función para importar CSV de BingX
function importBingXCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBingXCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };
    
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de BingX
async function processBingXCSV(csvContent) {
    console.log('📄 Procesando CSV para BingX...');
    
    // Usar el mismo formato estándar que en Configuraciones
    // Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), 
    // Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)
    
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });
    
    // Debug: Mostrar headers detectados
    console.log('🔍 [BingX CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let importedOpsCount = 0;
    let skippedOpsCount = 0;
    const newOperations = [];

    for (const row of parsedData.rows) {
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

        if (!account) {
            console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;
        
        // Limpiar y validar la fecha
        const cleanDateStr = dateStr.trim();
        
        if (cleanDateStr.includes('-')) {
            // Formato YYYY-MM-DD
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            // Formato DD/MM/YYYY
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }
        
        // Validar que la fecha sea válida
        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }
        
        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';
        
        // Procesar tarifa/comisiones - Buscar en todas las variantes posibles
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',    // Con barra diagonal
            'tarifa/comisión',    // Con barra y tilde
            'tarifa',             
            'comision',           
            'comisión',
            'fee',
            'fees',
            'commission'
        ];
        
        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [BingX CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }
        
        if (!feeColumnFound) {
            console.log('⚠️ [BingX CSV] No se encontró columna de comisión en:', Object.keys(headerMap));
        }

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
             pl = (exit - entry) * volume;
            else pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        newOperations.push({
            id: generateId(), 
            date: opDate, 
            accountId: account.id, 
            instrument, 
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime, 
            exitTime,
            volume, 
            result, 
            pl, 
            currency, 
            notes, 
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        });
        importedOpsCount++;
    }

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;
                
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }
                
                console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                if (successCount > 0) {
                    showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                }
            } else {
                console.log('ℹ️ Usuario no autenticado - operaciones solo en local');
            }

            // Actualizar balances y vistas
            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${importedOpsCount} operaciones importadas correctamente. ${skippedOpsCount > 0 ? skippedOpsCount + ' omitidas.' : ''}`, 'success');
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
    } else {
        showSyncNotification(`❌ No se importaron operaciones. ${skippedOpsCount} filas omitidas por errores.`, 'error');
    }
}

// ============================================
// FUNCIONES PARA PRIMEXBT
// ============================================

function importPrimeXBTCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processPrimeXBTCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };
    
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de PrimeXBT
async function processPrimeXBTCSV(csvContent) {
    console.log('📄 Procesando CSV para PrimeXBT...');
    
    // Usar el mismo formato estándar que en Configuraciones
    // Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), 
    // Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)
    
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });
    
    // Debug: Mostrar headers detectados
    console.log('🔍 [PrimeXBT CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let importedOpsCount = 0;
    let skippedOpsCount = 0;
    const newOperations = [];

    for (const row of parsedData.rows) {
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

        if (!account) {
            console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;
        
        // Limpiar y validar la fecha
        const cleanDateStr = dateStr.trim();
        
        if (cleanDateStr.includes('-')) {
            // Formato YYYY-MM-DD
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            // Formato DD/MM/YYYY
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }
        
        // Validar que la fecha sea válida
        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }
        
        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';
        
        // Procesar tarifa/comisiones - Buscar en todas las variantes posibles
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',    // Con barra diagonal
            'tarifa/comisión',    // Con barra y tilde
            'tarifa',             
            'comision',           
            'comisión',
            'fee',
            'fees',
            'commission'
        ];
        
        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [PrimeXBT CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }
        
        if (!feeColumnFound) {
            console.log('⚠️ [PrimeXBT CSV] No se encontró columna de comisión en:', Object.keys(headerMap));
        }

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
             pl = (exit - entry) * volume;
            else pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        newOperations.push({
            id: generateId(), 
            date: opDate, 
            accountId: account.id, 
            instrument, 
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime, 
            exitTime,
            volume, 
            result, 
            pl, 
            currency, 
            notes, 
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        });
        importedOpsCount++;
    }

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;
                
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }
                
                console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                if (successCount > 0) {
                    showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                }
            } else {
                console.log('ℹ️ Usuario no autenticado - operaciones solo en local');
            }

            // Actualizar balances y vistas
            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${importedOpsCount} operaciones importadas correctamente. ${skippedOpsCount > 0 ? skippedOpsCount + ' omitidas.' : ''}`, 'success');
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
    } else {
        showSyncNotification(`❌ No se importaron operaciones. ${skippedOpsCount} filas omitidas por errores.`, 'error');
    }
}

// ============================================
// FUNCIONES PARA BITGET
// ============================================

function importBitgetCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBitgetCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };
    
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de Bitget
async function processBitgetCSV(csvContent) {
    console.log('📄 Procesando CSV para Bitget...');
    
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });
    
    console.log('🔍 [Bitget CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let importedOpsCount = 0;
    let skippedOpsCount = 0;
    const newOperations = [];

    for (const row of parsedData.rows) {
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

        if (!account) {
            console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;
        
        const cleanDateStr = dateStr.trim();
        
        if (cleanDateStr.includes('-')) {
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }
        
        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }
        
        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';
        
        // Procesar tarifa/comisiones
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',
            'tarifa/comisión',
            'tarifa',
            'comision',
            'comisión',
            'fee',
            'fees',
            'commission'
        ];
        
        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [Bitget CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }
        
        if (!feeColumnFound) {
            console.log('⚠️ [Bitget CSV] No se encontró columna de comisión');
        }

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
                pl = (exit - entry) * volume;
            else 
                pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        newOperations.push({
            id: generateId(),
            date: opDate,
            accountId: account.id,
            instrument,
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime,
            exitTime,
            volume,
            result,
            pl,
            currency,
            notes,
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        });
        importedOpsCount++;
    }

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;
                
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }
                
                console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                if (successCount > 0) {
                    showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                }
            } else {
                console.log('ℹ️ Usuario no autenticado - operaciones solo en local');
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${importedOpsCount} operaciones importadas correctamente. ${skippedOpsCount > 0 ? skippedOpsCount + ' omitidas.' : ''}`, 'success');
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
    } else {
        showSyncNotification(`❌ No se importaron operaciones. ${skippedOpsCount} filas omitidas por errores.`, 'error');
    }
}

// Función para convertir trade de Bitget al formato de la aplicación
function convertBitgetTradeToAppFormat(bitgetTrade, accountId) {
    const pnl = parseFloat(bitgetTrade.profit || bitgetTrade.pl || 0);
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');
    
    const tradeDateObj = new Date(parseInt(bitgetTrade.cTime || bitgetTrade.timestamp));
    const tradeDate = getLocalDateString(tradeDateObj);
    
    const entryTime = new Date(parseInt(bitgetTrade.cTime || bitgetTrade.timestamp)).toTimeString().split(' ')[0];
    const exitTime = bitgetTrade.uTime ? 
        new Date(parseInt(bitgetTrade.uTime)).toTimeString().split(' ')[0] : entryTime;
    
    return {
        id: `bitget_${bitgetTrade.orderId || bitgetTrade.tradeId}`,
        date: tradeDate,
        accountId: accountId,
        instrument: bitgetTrade.symbol,
        type: (bitgetTrade.side || '').toLowerCase(),
        entry: parseFloat(bitgetTrade.priceAvg || bitgetTrade.price),
        exit: parseFloat(bitgetTrade.priceAvg || bitgetTrade.price),
        entryTime: entryTime,
        exitTime: exitTime,
        volume: parseFloat(bitgetTrade.size || bitgetTrade.baseVolume),
        result: result,
        pl: pnl,
        fees: Math.abs(parseFloat(bitgetTrade.fee || bitgetTrade.feeDetail?.totalFee || 0)),
        currency: 'USDT',
        notes: `Importado de Bitget - Order ID: ${bitgetTrade.orderId || bitgetTrade.tradeId}`,
        imageDatas: [],
        manualPL: null,
        session: 'No especificado'
    };
}

// Función para sincronizar trades desde Bitget
async function syncBitgetTrades() {
    if (!bitgetAPI) {
        showSyncNotification('❌ Primero debes conectar con Bitget', 'error');
        updateBitgetStatus('error', 'No conectado', false);
        return;
    }

    let selectedAccount = null;
    
    const accountDetailSelect = document.getElementById('bitget-account-detail');
    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = DB.accounts.find(acc => acc.id === accountDetailSelect.value);
    }

    if (!selectedAccount) {
        showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        return;
    }

    updateBitgetStatus('syncing', 'Sincronizando...', true);
    showSyncNotification('🔄 Sincronizando trades de Bitget...', 'info');

    try {
        console.log('📡 Obteniendo trades de Bitget...');
        
        const tradesResponse = await bitgetAPI.getTradeHistory();
        
        if (!tradesResponse.data || tradesResponse.data.length === 0) {
            showSyncNotification('ℹ️ No se encontraron trades en Bitget', 'info');
            updateBitgetStatus('connected', 'Conectado - Sin trades', false);
            return;
        }

        const bitgetTrades = tradesResponse.data;
        console.log(`📊 Trades obtenidos: ${bitgetTrades.length}`);

        const existingTradeIds = new Set(
            DB.operations
                .filter(op => op.id.startsWith('bitget_'))
                .map(op => op.id)
        );

        let newTradesCount = 0;
        const newOperations = [];

        for (const trade of bitgetTrades) {
            const convertedTrade = convertBitgetTradeToAppFormat(trade, selectedAccount.id);
            
            if (!existingTradeIds.has(convertedTrade.id)) {
                newOperations.push(convertedTrade);
                newTradesCount++;
            }
        }

        if (newOperations.length > 0) {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            if (currentUser) {
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                    } catch (error) {
                        console.error('Error sincronizando operación:', error);
                        addToSyncQueue(operation, 'operation');
                    }
                }
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${newTradesCount} nuevas operaciones sincronizadas desde Bitget`, 'success');
        } else {
            showSyncNotification('ℹ️ No hay nuevas operaciones para sincronizar', 'info');
        }

        updateBitgetStatus('connected', 'Sincronización completada', false);
        addBitgetSyncHistory(newTradesCount, bitgetTrades.length - newTradesCount);

    } catch (error) {
        console.error('❌ Error sincronizando trades de Bitget:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateBitgetStatus('error', 'Error en sincronización', false);
    }
}

// Actualizar estado visual de Bitget
function updateBitgetStatus(status, message, showProgress) {
    const statusIndicator = document.getElementById('bitget-status-indicator');
    const progressBar = document.getElementById('bitget-progress-bar');
    const connectionStatus = document.getElementById('bitget-connection-status');

    if (statusIndicator) {
        const statusColors = {
            'connected': 'text-green-400',
            'syncing': 'text-blue-400',
            'error': 'text-red-400',
            'disconnected': 'text-yellow-400'
        };
        
        statusIndicator.className = statusColors[status] || 'text-gray-400';
        statusIndicator.textContent = message;
    }

    if (progressBar) {
        progressBar.style.width = showProgress ? '100%' : '0%';
    }

    if (connectionStatus) {
        const bgColors = {
            'connected': 'bg-green-800 border-green-600',
            'syncing': 'bg-blue-800 border-blue-600',
            'error': 'bg-red-800 border-red-600',
            'disconnected': 'bg-yellow-800 border-yellow-600'
        };

        const icons = {
            'connected': 'fa-check-circle text-green-300',
            'syncing': 'fa-sync-alt fa-spin text-blue-300',
            'error': 'fa-exclamation-triangle text-red-300',
            'disconnected': 'fa-exclamation-triangle text-yellow-300'
        };

        connectionStatus.className = `p-4 rounded-md mb-4 ${bgColors[status] || 'bg-gray-800 border-gray-600'}`;
        connectionStatus.innerHTML = `
            <div class="flex items-center">
                <i class="fas ${icons[status] || 'fa-circle'} text-xl mr-3"></i>
                <div>
                    <p class="font-semibold">${message}</p>
                    <p class="text-sm mt-1">${status === 'connected' ? 'Listo para sincronizar trades' : status === 'syncing' ? 'Obteniendo datos...' : 'Verifica la configuración'}</p>
                </div>
            </div>
        `;
    }

    const lastSync = document.getElementById('bitget-last-sync');
    if (lastSync && status === 'connected') {
        const now = new Date();
        lastSync.textContent = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }
}

// Agregar entrada al historial de sincronización
function addBitgetSyncHistory(newTrades, skippedTrades) {
    const historyContainer = document.getElementById('bitget-sync-history');
    if (!historyContainer) return;

    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <span class="font-semibold text-green-400">${newTrades} nuevas</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">${skippedTrades} existentes</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Actualizar historial de importaciones de MEXC
function updateMEXCImportHistory() {
    const historyContainer = document.getElementById('mexc-import-history');
    if (!historyContainer) return;

    // Remover mensaje de "no hay importaciones"
    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <i class="fas fa-file-csv text-blue-400 mr-2"></i>
                <span class="font-semibold text-green-400">CSV Importado</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">MEXC</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    // Mantener solo las últimas 10 entradas
    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Cargar credenciales guardadas de Bitget
async function loadBitgetCredentials() {
    try {
        const savedKeys = await dexieDB.apiKeys.get('bitget');
        if (savedKeys) {
            const apiKeyDetail = document.getElementById('bitget-api-key-detail');
            const secretKeyDetail = document.getElementById('bitget-secret-key-detail');
            const passphraseDetail = document.getElementById('bitget-passphrase-detail');
            
            if (apiKeyDetail) apiKeyDetail.value = savedKeys.key || '';
            if (secretKeyDetail) secretKeyDetail.value = savedKeys.secret || '';
            if (passphraseDetail) passphraseDetail.value = savedKeys.passphrase || '';
            
            if (savedKeys.key && savedKeys.secret && savedKeys.passphrase) {
                if (window.FORCE_OFFLINE_BITGET) {
                    bitgetAPI = new MockBitgetAPI();
                } else {
                    bitgetAPI = new BitgetAPI(savedKeys.key, savedKeys.secret, savedKeys.passphrase);
                }
                DB.apiKeys.bitget = savedKeys;
                updateBitgetStatus('connected', 'Conectado', false);
                console.log('✅ Credenciales de Bitget cargadas desde DB');
            }
        } else {
            console.log('ℹ️ No hay credenciales guardadas de Bitget');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de Bitget:', error);
    }
}

// Cargar lista de cuentas en select de Bitget
function populateBitgetAccountSelect() {
    const select = document.getElementById('bitget-account-detail');
    if (!select) {
        console.warn('⚠️ Select de cuentas de Bitget no encontrado');
        return;
    }
    
    select.innerHTML = '<option value="">Seleccionar cuenta...</option>';
    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.balance} ${account.currency})`;
        select.appendChild(option);
    });
    
    console.log('✅ Cuentas cargadas en select de Bitget:', DB.accounts.length);
}

// ============================================
// MEXC API FUNCTIONS
// ============================================

// Probar conexión con MEXC
async function testMEXCConnection() {
    const apiKeyInput = document.getElementById('mexc-api-key-detail');
    const secretKeyInput = document.getElementById('mexc-secret-key-detail');
    
    const apiKey = apiKeyInput?.value.trim();
    const secretKey = secretKeyInput?.value.trim();
    
    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Ingresa API Key y Secret Key', 'error');
        return;
    }
    
    try {
        showSyncNotification('🔄 Probando conexión con MEXC...', 'info');
        
        const testAPI = new MEXCAPI(apiKey, secretKey);
        const result = await testAPI.testConnection();
        
        showSyncNotification('✅ Conexión exitosa a MEXC', 'success');
        updateMEXCStatus('connected', 'Test exitoso', false);
        console.log('Test de conexión MEXC exitoso:', result);
        
        return true;
    } catch (error) {
        console.error('Error en test de conexión MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en conexión', false);
        return false;
    }
}

// Conectar con MEXC
async function connectMEXC() {
    const apiKeyInput = document.getElementById('mexc-api-key-detail');
    const secretKeyInput = document.getElementById('mexc-secret-key-detail');
    const accountSelect = document.getElementById('mexc-account-detail');
    
    const apiKey = apiKeyInput?.value.trim();
    const secretKey = secretKeyInput?.value.trim();
    const accountId = accountSelect?.value;
    
    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Ingresa todas las credenciales', 'error');
        return;
    }
    
    if (!accountId) {
        showSyncNotification('❌ Selecciona una cuenta', 'error');
        return;
    }
    
    try {
        showSyncNotification('🔄 Conectando con MEXC...', 'info');
        updateMEXCStatus('connecting', 'Conectando...', true);
        
        // Crear instancia de API
        mexcAPI = new MEXCAPI(apiKey, secretKey);
        
        // Probar conexión
        await mexcAPI.testConnection();
        
        // Guardar credenciales
        const credentials = {
            id: 'mexc',
            key: apiKey,
            secret: secretKey,
            accountId: accountId,
            platform: 'mexc'
        };
        
        await dexieDB.apiKeys.put(credentials);
        DB.apiKeys.mexc = credentials;
        
        updateMEXCStatus('connected', 'Conectado exitosamente', false);
        showSyncNotification('✅ MEXC conectado exitosamente', 'success');
        
        console.log('✅ MEXC API conectada y credenciales guardadas');
        
    } catch (error) {
        console.error('Error conectando con MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en conexión', false);
        mexcAPI = null;
    }
}

// Sincronizar trades de MEXC
async function syncMEXCTrades() {
    if (!mexcAPI) {
        showSyncNotification('❌ Primero debes conectar con MEXC', 'error');
        updateMEXCStatus('error', 'No conectado', false);
        return;
    }

    let selectedAccount = null;
    
    const accountDetailSelect = document.getElementById('mexc-account-detail');
    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = DB.accounts.find(acc => acc.id === accountDetailSelect.value);
        console.log('📋 Cuenta seleccionada para sincronización MEXC:', selectedAccount.name);
    }

    if (!selectedAccount) {
        showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        console.error('❌ No hay cuenta seleccionada. Valor del select:', accountDetailSelect?.value);
        return;
    }

    updateMEXCStatus('syncing', 'Sincronizando...', true);
    showSyncNotification(`🔄 Sincronizando trades de MEXC a cuenta: ${selectedAccount.name}`, 'info');

    try {
        console.log('📡 Obteniendo trades de MEXC...');
        console.log('📋 Cuenta destino:', selectedAccount);
        
        // Obtener trades de los últimos 30 días
        const endTime = Date.now();
        const startTime = endTime - (30 * 24 * 60 * 60 * 1000);
        
        console.log(`🕐 Rango de fechas: ${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}`);
        
        const tradesResponse = await mexcAPI.getTradeHistory('', startTime, endTime);
        
        if (!tradesResponse || tradesResponse.length === 0) {
            showSyncNotification('ℹ️ No se encontraron trades en MEXC', 'info');
            updateMEXCStatus('connected', 'Conectado - Sin trades', false);
            return;
        }

        const mexcTrades = Array.isArray(tradesResponse) ? tradesResponse : tradesResponse.data || [];
        console.log(`📊 Trades obtenidos: ${mexcTrades.length}`);

        const existingTradeIds = new Set(
            DB.operations
                .filter(op => op.id.startsWith('mexc_'))
                .map(op => op.id)
        );

        let newTradesCount = 0;
        const newOperations = [];

        for (const trade of mexcTrades) {
            const convertedTrade = convertMEXCTradeToAppFormat(trade, selectedAccount.id);
            
            if (!existingTradeIds.has(convertedTrade.id)) {
                newOperations.push(convertedTrade);
                newTradesCount++;
            }
        }

        if (newOperations.length > 0) {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            if (currentUser) {
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                    } catch (error) {
                        console.error('Error sincronizando operación:', error);
                        addToSyncQueue(operation, 'operation');
                    }
                }
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${newTradesCount} nuevas operaciones sincronizadas desde MEXC`, 'success');
        } else {
            showSyncNotification('ℹ️ No hay nuevas operaciones para sincronizar', 'info');
        }

        updateMEXCStatus('connected', 'Sincronización completada', false);
        addMEXCSyncHistory(newTradesCount, mexcTrades.length - newTradesCount);

    } catch (error) {
        console.error('Error sincronizando MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en sincronización', false);
    }
}

// Desconectar MEXC y borrar credenciales
async function disconnectMEXC() {
    try {
        // Confirmar con el usuario
        if (!confirm('¿Estás seguro de que quieres desconectar MEXC y borrar las credenciales guardadas?')) {
            return;
        }
        
        // Borrar de IndexedDB
        await dexieDB.apiKeys.delete('mexc');
        
        // Limpiar de memoria
        DB.apiKeys.mexc = {};
        mexcAPI = null;
        
        // Limpiar campos del formulario
        const apiKeyInput = document.getElementById('mexc-api-key-detail');
        const secretKeyInput = document.getElementById('mexc-secret-key-detail');
        
        if (apiKeyInput) apiKeyInput.value = '';
        if (secretKeyInput) secretKeyInput.value = '';
        
        // Actualizar estado
        updateMEXCStatus('disconnected', 'Desconectado', false);
        showSyncNotification('✅ MEXC desconectado. Credenciales borradas.', 'success');
        
        console.log('✅ MEXC desconectado y credenciales borradas');
    } catch (error) {
        console.error('Error desconectando MEXC:', error);
        showSyncNotification(`❌ Error al desconectar: ${error.message}`, 'error');
    }
}

// Convertir trade de MEXC al formato de la aplicación
function convertMEXCTradeToAppFormat(mexcTrade, accountId) {
    const commission = parseFloat(mexcTrade.commission || 0);
    const price = parseFloat(mexcTrade.price || 0);
    const qty = parseFloat(mexcTrade.qty || 0);
    const isBuyer = mexcTrade.isBuyer;
    
    const tradeValue = price * qty;
    const pnl = isBuyer ? -commission : tradeValue - commission;
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');
    
    const tradeDateObj = new Date(parseInt(mexcTrade.time));
    const tradeDate = getLocalDateString(tradeDateObj);
    const tradeTime = tradeDateObj.toTimeString().split(' ')[0];
    
    return {
        id: `mexc_${mexcTrade.id}`,
        date: tradeDate,
        accountId: accountId,
        instrument: mexcTrade.symbol,
        type: isBuyer ? 'buy' : 'sell',
        entry: price,
        exit: price,
        entryTime: tradeTime,
        exitTime: tradeTime,
        volume: qty,
        result: result,
        pl: pnl,
        manualPL: pnl,
        fees: commission,
        currency: mexcTrade.commissionAsset || 'USDT',
        session: 'MEXC',
        notes: `Trade ID: ${mexcTrade.orderId}`,
        images: []
    };
}

// Actualizar indicadores de estado de MEXC
function updateMEXCStatus(status, message, showProgress = false) {
    const statusIndicator = document.getElementById('mexc-status-indicator');
    const connectionStatus = document.getElementById('mexc-connection-status');
    const progressBar = document.getElementById('mexc-progress-bar');
    
    if (statusIndicator) {
        statusIndicator.className = '';
        if (status === 'connected') {
            statusIndicator.className = 'text-green-400';
            statusIndicator.textContent = 'Conectado';
        } else if (status === 'syncing' || status === 'connecting') {
            statusIndicator.className = 'text-blue-400';
            statusIndicator.textContent = message;
        } else if (status === 'error') {
            statusIndicator.className = 'text-red-400';
            statusIndicator.textContent = 'Error';
        } else {
            statusIndicator.className = 'text-yellow-400';
            statusIndicator.textContent = 'No conectado';
        }
    }
    
    if (progressBar) {
        if (showProgress) {
            progressBar.style.width = '100%';
            progressBar.classList.add('animate-pulse');
        } else {
            progressBar.style.width = '0%';
            progressBar.classList.remove('animate-pulse');
        }
    }
    
    if (connectionStatus) {
        connectionStatus.className = 'p-4 border rounded-md mb-4';
        
        if (status === 'connected') {
            connectionStatus.className += ' bg-green-800 border-green-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-check-circle text-green-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-green-100">Conectado</p>
                        <p class="text-sm text-green-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        } else if (status === 'error') {
            connectionStatus.className += ' bg-red-800 border-red-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-times-circle text-red-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-red-100">Error</p>
                        <p class="text-sm text-red-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        } else {
            connectionStatus.className += ' bg-yellow-800 border-yellow-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-yellow-100">${status === 'syncing' ? 'Sincronizando' : 'No conectado'}</p>
                        <p class="text-sm text-yellow-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        }
    }

    const lastSync = document.getElementById('mexc-last-sync');
    if (lastSync && status === 'connected') {
        const now = new Date();
        lastSync.textContent = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }
}

// Agregar entrada al historial de sincronización de MEXC
function addMEXCSyncHistory(newTrades, skippedTrades) {
    const historyContainer = document.getElementById('mexc-import-history');
    if (!historyContainer) return;

    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <i class="fas fa-sync-alt text-green-400 mr-2"></i>
                <span class="font-semibold text-green-400">${newTrades} nuevas</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">${skippedTrades} existentes</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Cargar credenciales guardadas de MEXC
async function loadMEXCCredentials() {
    try {
        // Verificar que dexieDB esté inicializada
        if (!dexieDB || !dexieDB.apiKeys) {
            console.warn('⚠️ Base de datos no inicializada aún, esperando...');
            return;
        }

        const savedKeys = await dexieDB.apiKeys.get('mexc');
        if (savedKeys) {
            const apiKeyDetail = document.getElementById('mexc-api-key-detail');
            const secretKeyDetail = document.getElementById('mexc-secret-key-detail');
            
            if (apiKeyDetail) apiKeyDetail.value = savedKeys.key || '';
            if (secretKeyDetail) secretKeyDetail.value = savedKeys.secret || '';
            
            if (savedKeys.key && savedKeys.secret) {
                mexcAPI = new MEXCAPI(savedKeys.key, savedKeys.secret);
                DB.apiKeys.mexc = savedKeys;
                updateMEXCStatus('connected', 'Conectado', false);
                console.log('✅ Credenciales de MEXC cargadas desde DB');
            }
        } else {
            console.log('ℹ️ No hay credenciales guardadas de MEXC');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de MEXC:', error);
        // No mostrar error al usuario, solo log
    }
}

// Poblar selector de cuentas de MEXC
function populateMEXCAccountSelect() {
    const accountSelect = document.getElementById('mexc-account-detail');
    if (!accountSelect) return;
    
    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';
    
    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });
    
    // Intentar restaurar la cuenta guardada
    if (DB.apiKeys.mexc && DB.apiKeys.mexc.accountId) {
        accountSelect.value = DB.apiKeys.mexc.accountId;
        console.log('✅ Cuenta MEXC restaurada:', DB.apiKeys.mexc.accountId);
    } else if (DB.accounts.length > 0) {
        // Si no hay cuenta guardada, seleccionar la primera automáticamente
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta MEXC seleccionada automáticamente:', DB.accounts[0].name);
    }
    
    console.log('✅ Cuentas cargadas en select de MEXC:', DB.accounts.length);
}

// ============================================
// FUNCIONES PARA METATRADER 5
// ============================================

function importMT5HTMLReport() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.html,.htm';
    input.style.display = 'none';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const html = e.target.result;
                await parseMT5HTMLReport(html);
            } catch (error) {
                console.error('Error procesando informe MT5:', error);
                showSyncNotification('❌ Error procesando informe HTML de MT5', 'error');
            }
        };
        reader.readAsText(file);
    };
    
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

async function parseMT5HTMLReport(htmlContent) {
    console.log('📄 Procesando informe HTML de MetaTrader 5...');
    
    try {
        // Parsear HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        
        // Extraer nombre de cuenta del informe
        const accountNameElement = doc.querySelector('th b');
        const defaultAccountName = accountNameElement ? accountNameElement.textContent.trim() : 'MT5 Account';
        
        // Buscar la tabla de Posiciones (closed trades)
        let positionsTable = null;
        const tables = doc.querySelectorAll('table');
        
        for (const table of tables) {
            // Buscar por el header específico de la tabla de Posiciones
            const headers = table.querySelectorAll('th');
            let hasPosicionesHeader = false;
            
            for (const header of headers) {
                const text = header.textContent.trim();
                if (text === 'Posiciones' || text === 'Positions') {
                    hasPosicionesHeader = true;
                    break;
                }
            }
            
            if (hasPosicionesHeader) {
                // Verificar que tenga filas de datos
                const dataRows = table.querySelectorAll('tr[bgcolor]');
                if (dataRows.length > 0) {
                    positionsTable = table;
                    console.log('✅ Tabla de Posiciones encontrada');
                    break;
                }
            }
        }
        
        if (!positionsTable) {
            showSyncNotification('❌ No se encontró la tabla de Posiciones en el informe', 'error');
            return;
        }
        
        // Extraer filas de datos (las que tienen bgcolor - son las operaciones)
        const rows = positionsTable.querySelectorAll('tr[bgcolor]');
        console.log(`📊 Encontradas ${rows.length} posiciones cerradas en el informe`);
        
        if (rows.length === 0) {
            showSyncNotification('ℹ️ El informe no contiene posiciones cerradas', 'info');
            return;
        }
        
        const newOperations = [];
        let skippedCount = 0;
        
        // Buscar o crear cuenta MT5
        let mt5Account = DB.accounts.find(acc => acc.name.toLowerCase().includes('mt5') || acc.platform === 'meta-trader-5');
        
        if (!mt5Account) {
            // Crear cuenta automáticamente
            mt5Account = {
                id: generateId(),
                name: defaultAccountName,
                balance: 0,
                currency: 'USD', // Por defecto, se puede detectar del informe
                platform: 'meta-trader-5'
            };
            DB.accounts.push(mt5Account);
            await dexieDB.accounts.add(mt5Account);
            console.log('✅ Cuenta MT5 creada automáticamente:', mt5Account.name);
        }
        
        // Procesar cada fila de posición cerrada
        for (const row of rows) {
            try {
                // Obtener SOLO las celdas visibles (sin class="hidden")
                const allCells = row.querySelectorAll('td');
                const cells = Array.from(allCells).filter(cell => {
                    return !cell.classList.contains('hidden') && !cell.hasAttribute('class') || cell.className !== 'hidden';
                });
                
                // Log para debug
                console.log(`🔍 Fila con ${allCells.length} celdas totales, ${cells.length} visibles`);
                
                // Verificar cantidad mínima de celdas visibles
                if (cells.length < 12) {
                    console.warn(`⚠️ Fila con solo ${cells.length} celdas visibles, omitiendo`);
                    skippedCount++;
                    continue;
                }
                
                // Extraer datos básicos (estructura de tabla Posiciones de MT5)
                const openDateTime = cells[0].textContent.trim();
                const positionId = cells[1].textContent.trim();
                const symbol = cells[2].textContent.trim();
                const type = cells[3].textContent.trim().toLowerCase();
                
                console.log(`📝 Pos#${positionId}: ${symbol} ${type}`);
                
                // FILTRAR: Verificar que sea una operación válida (no balance, no vacío)
                if (!symbol || symbol === '' || !type || type === '') {
                    console.log(`⏭️ Omitiendo fila sin símbolo o tipo`);
                    skippedCount++;
                    continue;
                }
                
                // FILTRAR: Solo buy y sell
                if (type !== 'buy' && type !== 'sell') {
                    console.log(`⏭️ Omitiendo operación tipo "${type}"`);
                    skippedCount++;
                    continue;
                }
                
                // Extraer volumen y precios
                const volume = parseFloat(cells[4].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                const entryPrice = parseFloat(cells[5].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                const exitPrice = parseFloat(cells[9].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                const closeDateTime = cells[8].textContent.trim();
                
                // Extraer comisión y swap
                const commissionRaw = parseFloat(cells[10].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                const swapRaw = parseFloat(cells[11].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                
                // Extraer profit (última celda con número válido)
                let profit = 0;
                for (let i = cells.length - 1; i >= 12; i--) {
                    const text = cells[i].textContent.replace(/\s/g, '').replace(',', '.');
                    const value = parseFloat(text);
                    if (!isNaN(value)) {
                        profit = value;
                        break;
                    }
                }
                
                console.log(`💰 Vol=${volume}, Entry=${entryPrice}, Exit=${exitPrice}, P&L=${profit}, Comm=${commissionRaw}, Swap=${swapRaw}`);
                
                // FILTRAR: profit = 0 o precios inválidos
                if (profit === 0 || entryPrice === 0 || exitPrice === 0) {
                    console.log(`⏭️ Omitiendo: P&L=${profit}, Entry=${entryPrice}, Exit=${exitPrice}`);
                    skippedCount++;
                    continue;
                }// Parsear fechas y horas
                const [openDateStr, openTimeStr] = openDateTime.split(' ');
                const [closeDateStr, closeTimeStr] = closeDateTime.split(' ');
                
                // Convertir fecha de MT5 (YYYY.MM.DD) a formato estándar (YYYY-MM-DD)
                const operationDate = closeDateStr ? closeDateStr.replace(/\./g, '-') : null;
                
                // Validar que las fechas sean válidas
                if (!operationDate || operationDate.includes('NaN') || operationDate === '--') {
                    console.error(`❌ Fecha inválida para operación #${positionId}: closeDateStr="${closeDateStr}", operationDate="${operationDate}"`);
                    skippedCount++;
                    continue;
                }
                
                // Validar formato YYYY-MM-DD
                const datePattern = /^\d{4}-\d{2}-\d{2}$/;
                if (!datePattern.test(operationDate)) {
                    console.error(`❌ Formato de fecha incorrecto para operación #${positionId}: "${operationDate}"`);
                    skippedCount++;
                    continue;
                }
                
                // Calcular fees total - validar que sean valores razonables
                // Las comisiones normalmente son pequeñas (< $100 por operación)
                let totalFees = 0;
                
                if (Math.abs(commissionRaw) < 100) {
                    totalFees += Math.abs(commissionRaw);
                } else {
                    console.warn(`⚠️ Comisión sospechosa ($${commissionRaw}) en operación #${positionId}, ignorando`);
                }
                
                if (Math.abs(swapRaw) < 100) {
                    totalFees += Math.abs(swapRaw);
                } else {
                    console.warn(`⚠️ Swap sospechoso ($${swapRaw}) en operación #${positionId}, ignorando`);
                }
                
                // Determinar resultado
                let result;
                if (profit > 0) result = 'win';
                else if (profit < 0) result = 'loss';
                else result = 'breakeven';
                
                // Crear operación
                const operation = {
                    id: `mt5_${positionId}`,
                    date: operationDate,
                    accountId: mt5Account.id,
                    instrument: symbol,
                    type: type,
                    entry: entryPrice,
                    exit: exitPrice,
                    entryTime: openTimeStr || null,
                    exitTime: closeTimeStr || null,
                    volume: volume,
                    result: result,
                    pl: profit,
                    currency: mt5Account.currency,
                    notes: `Importado de MT5 - Posición #${positionId}`,
                    imageDatas: [],
                    fees: totalFees,
                    manualPL: profit,
                    session: 'No especificado'
                };
                
                console.log(`✅ Operación procesada: ${symbol} ${type} | Date: ${operationDate} | P&L: $${profit} | Fees: $${totalFees}`);
                
                // Verificar si ya existe esta operación (evitar duplicados)
                const exists = DB.operations.some(op => op.id === operation.id);
                if (exists) {
                    console.log(`⏭️ Operación #${positionId} ya existe, omitiendo`);
                    skippedCount++;
                    continue;
                }
                
                newOperations.push(operation);
                
            } catch (error) {
                console.error('Error procesando fila:', error);
                skippedCount++;
            }
        }
        
        if (newOperations.length === 0) {
            showSyncNotification('❌ No se pudieron procesar las operaciones del informe', 'error');
            return;
        }
        
        // Guardar operaciones en DB
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);
            
            // Sincronizar con Supabase si hay usuario autenticado
            if (currentUser) {
                console.log('🔍 Sincronizando operaciones con Supabase...');
                let successCount = 0;
                let errorCount = 0;
                
                for (const operation of newOperations) {
                    try {
                        // Verificar si ya existe en Supabase antes de guardar
                        const { data: existing } = await supabase
                            .from('operations')
                            .select('id')
                            .eq('id', operation.id)
                            .eq('user_id', currentUser.id)
                            .single();
                        
                        if (existing) {
                            console.log(`⏭️ Operación ${operation.id} ya existe en Supabase`);
                            continue;
                        }
                        
                        await saveOperationToSupabase(operation);
                        successCount++;
                    } catch (error) {
                        // Solo encolar si NO es un error de duplicado
                        if (!error.message?.includes('duplicate') && !error.message?.includes('already exists')) {
                            console.error('❌ Error sincronizando operación:', error);
                            addToSyncQueue(operation, 'operation');
                            errorCount++;
                        }
                    }
                }
                
                console.log(`✅ ${successCount} operaciones sincronizadas con Supabase${errorCount > 0 ? ` (${errorCount} errores)` : ''}`);
            }
            
            // Actualizar vistas
            updateAccountBalances();
            refreshAllViews();
            
            showSyncNotification(
                `✅ ${newOperations.length} operaciones importadas desde MT5${skippedCount > 0 ? ` (${skippedCount} omitidas)` : ''}`,
                'success'
            );
            
            console.log(`✅ Importación completada: ${newOperations.length} operaciones, ${skippedCount} omitidas`);
            
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
        
    } catch (error) {
        console.error('Error parseando informe MT5:', error);
        showSyncNotification('❌ Error procesando informe HTML', 'error');
    }
}

// Función para limpiar operaciones MT5 con errores (P&L=0 o comisiones incorrectas)
async function cleanMT5Operations() {
    try {
        console.log('🧹 Iniciando limpieza de operaciones MT5...');
        
        // Buscar todas las operaciones MT5 (id comienza con mt5_)
        const mt5Operations = DB.operations.filter(op => op.id && op.id.startsWith('mt5_'));
        
        if (mt5Operations.length === 0) {
            showSyncNotification('ℹ️ No hay operaciones MT5 para limpiar', 'info');
            return;
        }
        
        console.log(`📊 Encontradas ${mt5Operations.length} operaciones MT5`);
        
        // Identificar operaciones con problemas
        const problematicOps = mt5Operations.filter(op => {
            // Operaciones con P&L = 0
            const hasZeroPL = op.pl === 0 || op.manualPL === 0;
            
            // Operaciones con comisiones sospechosamente altas (más del 50% del P&L)
            const hasSuspiciousFees = op.fees && Math.abs(op.pl) > 0 && (op.fees / Math.abs(op.pl)) > 0.5;
            
            return hasZeroPL || hasSuspiciousFees;
        });
        
        if (problematicOps.length === 0) {
            showSyncNotification('✅ No se encontraron operaciones MT5 con problemas', 'success');
            return;
        }
        
        console.log(`❌ Encontradas ${problematicOps.length} operaciones con problemas:`, problematicOps);
        
        // Confirmar con el usuario
        const confirmed = confirm(
            `Se encontraron ${problematicOps.length} operaciones MT5 con problemas:\n\n` +
            `- Operaciones con P&L = 0\n` +
            `- Operaciones con comisiones incorrectas\n\n` +
            `¿Deseas eliminarlas? Esta acción no se puede deshacer.`
        );
        
        if (!confirmed) {
            showSyncNotification('ℹ️ Limpieza cancelada', 'info');
            return;
        }
        
        // Eliminar operaciones problemáticas
        let deletedCount = 0;
        
        for (const op of problematicOps) {
            try {
                // Eliminar de IndexedDB
                await dexieDB.operations.delete(op.id);
                
                // Eliminar de Supabase si hay usuario autenticado
                if (currentUser) {
                    await deleteOperationFromSupabase(op.id);
                }
                
                // Eliminar del array en memoria
                const index = DB.operations.findIndex(o => o.id === op.id);
                if (index !== -1) {
                    DB.operations.splice(index, 1);
                }
                
                deletedCount++;
                
            } catch (error) {
                console.error(`Error eliminando operación ${op.id}:`, error);
            }
        }
        
        // Actualizar vistas
        updateAccountBalances();
        refreshAllViews();
        
        showSyncNotification(
            `✅ Limpieza completada: ${deletedCount} operaciones eliminadas`,
            'success'
        );
        
        console.log(`✅ Limpieza completada: ${deletedCount} operaciones eliminadas`);
        
    } catch (error) {
        console.error('Error en limpieza MT5:', error);
        showSyncNotification('❌ Error en limpieza: ' + error.message, 'error');
    }
}

// Función para convertir trade de BingX al formato de la aplicación
function convertBingXTradeToAppFormat(bingxTrade, accountId) {
    // Determinar si fue ganancia o pérdida
    const pnl = parseFloat(bingxTrade.profit || 0);
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');
    
    // Convertir timestamp a fecha usando zona horaria local
    const tradeDateObj = new Date(parseInt(bingxTrade.time));
    const tradeDate = getLocalDateString(tradeDateObj);
    
    // Extraer hora de entrada y salida
    const entryTime = new Date(parseInt(bingxTrade.time)).toTimeString().split(' ')[0];
    const exitTime = bingxTrade.updateTime ? 
        new Date(parseInt(bingxTrade.updateTime)).toTimeString().split(' ')[0] : entryTime;
    
    return {
        id: `bingx_${bingxTrade.orderId}`,
        date: tradeDate,
        accountId: accountId,
        instrument: bingxTrade.symbol,
        type: bingxTrade.side.toLowerCase(), // 'BUY' -> 'buy', 'SELL' -> 'sell'
        entry: parseFloat(bingxTrade.avgPrice || bingxTrade.price),
        exit: parseFloat(bingxTrade.avgPrice || bingxTrade.price), // Para órdenes ejecutadas
        entryTime: entryTime,
        exitTime: exitTime,
        volume: parseFloat(bingxTrade.origQty),
        result: result,
        pl: pnl,
        fees: Math.abs(parseFloat(bingxTrade.commission || 0)), // Extraer fees de BingX
        currency: 'USDT', // BingX generalmente usa USDT
        notes: `Importado de BingX - Order ID: ${bingxTrade.orderId}`,
        imageDatas: [],
        manualPL: null,
        session: 'No especificado'
    };
}

// Función para sincronizar trades desde BingX
async function syncBingXTrades() {
    if (!bingxAPI) {
        showSyncNotification('❌ Primero debes conectar con BingX', 'error');
        updateBingXStatus('error', 'No conectado', false);
        return;
    }

    // Buscar cuenta seleccionada en cualquiera de las interfaces
    let selectedAccount = null;
    const accountSelect = document.getElementById('bingx-account');
    const accountDetailSelect = document.getElementById('bingx-account-detail');
    
    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = accountDetailSelect.value;
    } else if (accountSelect && accountSelect.value) {
        selectedAccount = accountSelect.value;
    } else if (DB.apiKeys.bingx && DB.apiKeys.bingx.accountId) {
        selectedAccount = DB.apiKeys.bingx.accountId;
    }
    
    if (!selectedAccount) {
        showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        return;
    }

    showLoading(true);
    updateBingXStatus('syncing', 'Sincronizando...', false);
    
    try {
        showSyncNotification('🔄 Sincronizando trades desde BingX...', 'info');
        
        // Primero probar con información de cuenta para verificar autenticación
        console.log('🔍 Verificando autenticación con BingX...');
        const accountResponse = await bingxAPI.getAccountInfo();
        console.log('📊 Respuesta de cuenta:', JSON.stringify(accountResponse, null, 2));
        
        if (accountResponse.code !== 0) {
            throw new Error(`Error de autenticación: ${accountResponse.msg}`);
        }
        
        // Obtener historial de trades
        console.log('📈 Obteniendo historial de trades...');
        const tradesResponse = await bingxAPI.getTradeHistory('', 100); // Reducir a 100 trades
        console.log('📊 Respuesta de trades:', JSON.stringify(tradesResponse, null, 2));
        
        if (tradesResponse.code !== 0) {
            throw new Error(tradesResponse.msg || 'Error obteniendo trades');
        }

        const bingxTrades = tradesResponse.data?.orders || [];
        
        // Filtrar solo trades ejecutados
        const executedTrades = bingxTrades.filter(trade => 
            trade.status === 'FILLED' && trade.profit !== undefined
        );

        // Buscar cuenta de BingX en la aplicación
        let bingxAccount = DB.accounts.find(acc => acc.platform === 'bingx');
        
        if (!bingxAccount) {
            // Crear cuenta de BingX automáticamente
            bingxAccount = {
                id: generateId(),
                name: 'BingX - Cuenta Principal',
                currency: 'USDT',
                platform: 'bingx',
                initialBalance: 0,
                balance: 0
            };
            
            DB.accounts.push(bingxAccount);
            await dexieDB.accounts.add(bingxAccount);
            
            // Sincronizar con Supabase si está conectado
            if (currentUser) {
                await saveAccountToSupabase(bingxAccount);
            }
        }

        // Convertir trades al formato de la aplicación
        let newTrades = 0;
        let skippedTrades = 0;

        for (const bingxTrade of executedTrades) {
            const appTrade = convertBingXTradeToAppFormat(bingxTrade, bingxAccount.id);
            
            // Verificar si el trade ya existe
            const existingTrade = DB.operations.find(op => op.id === appTrade.id);
            
            if (!existingTrade) {
                // Guardar localmente
                DB.operations.push(appTrade);
                await dexieDB.operations.add(appTrade);
                
                // Sincronizar con Supabase si está conectado
                if (currentUser) {
                    await saveOperationToSupabase(appTrade);
                }
                
                newTrades++;
            } else {
                skippedTrades++;
            }
        }

        // Actualizar balance de la cuenta si se encontraron nuevos trades
        if (newTrades > 0) {
            updateAccountBalances();
            refreshAllViews();
        }

        const message = `✅ Sincronización completa: ${newTrades} trades nuevos, ${skippedTrades} ya existían`;
        showSyncNotification(message, 'success');
        updateBingXStatus('sync', 'Conectado', true);

    } catch (error) {
        console.error('Error sincronizando trades BingX:', error);
        const errorMessage = `❌ Error sincronizando: ${error.message}`;
        showSyncNotification(errorMessage, 'error');
        updateBingXStatus('error', 'Error de sincronización', false);
    } finally {
        showLoading(false);
    }
}

// Función para cargar credenciales guardadas
function loadBingXCredentials() {
    console.log('🔍 Cargando credenciales BingX...');
    
    // Primero intentar cargar desde localStorage
    const savedApiKey = localStorage.getItem('bingx-api-key');
    const savedSecretKey = localStorage.getItem('bingx-secret-key');
    const savedAccountId = localStorage.getItem('bingx-account-id');
    
    console.log('📁 Credenciales en localStorage:', {
        apiKey: savedApiKey ? `${savedApiKey.substring(0, 10)}...` : 'No encontrada',
        secretKey: savedSecretKey ? `${savedSecretKey.substring(0, 10)}...` : 'No encontrada',
        accountId: savedAccountId || 'No encontrada'
    });
    
    // Configurar credenciales proporcionadas por el usuario como respaldo
    const providedApiKey = 'sw8hglph1M6HWzoqswDdjX7YTh3mcruPKynFi1ZBz8zDXCHxnEchw7oRWgYysFVLFuD7bkYomRHxSh8gdtNBg';
    const providedSecretKey = '7hUYF1GhJ6QixdE2mfDEdDMovcKVpUc3OnqbAfiAcbrT6XzFfMF4ywd0K06JgJCt0Zsa6MYxuSslDKr5XJfYA';
    
    // Verificar si existen los elementos antes de actualizar
    const bingxApiKeyEl = document.getElementById('bingx-api-key');
    const bingxSecretEl = document.getElementById('bingx-api-secret');
    
    // Usar credenciales guardadas o las proporcionadas
    const apiKeyToUse = savedApiKey || providedApiKey;
    const secretKeyToUse = savedSecretKey || providedSecretKey;
    const accountIdToUse = savedAccountId || 'main';
    
    console.log('💾 Cargando credenciales en campos...');
    
    if (bingxApiKeyEl) {
        bingxApiKeyEl.value = apiKeyToUse;
        console.log('✅ API Key cargada en campo básico');
    }
    if (bingxSecretEl) {
        bingxSecretEl.value = secretKeyToUse;
        console.log('✅ Secret Key cargada en campo básico');
    }
    
    // Actualizar DB
    DB.apiKeys.bingx = { 
        key: apiKeyToUse, 
        secret: secretKeyToUse, 
        mode: 'real', 
    };
    
    // Intentar reconectar automáticamente
    if (DB.apiKeys.bingx && DB.apiKeys.bingx.key && DB.apiKeys.bingx.secret) {
        bingxAPI = new BingXAPI(DB.apiKeys.bingx.key, DB.apiKeys.bingx.secret);
        console.log('🔗 BingX API reconectada automáticamente');
        
        // Poblar cuentas cuando se reconecta
        populateBingXAccounts();
        
        // Actualizar estado visual
        setTimeout(() => {
            updateBingXStatus('connected', 'Credenciales cargadas', true);
        }, 500);
    }
}

// Función para verificar el estado del proxy
async function checkProxyStatus() {
    try {
        const proxyCheckUrl = window.PROXY_URL || 'http://127.0.0.1:8003';
        const response = await fetch(`${proxyCheckUrl}/health`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (response.ok) {
            console.log('✅ Servidor proxy BingX funcionando correctamente');
            return true;
        } else {
            console.warn('⚠️ Servidor proxy BingX no responde correctamente');
            return false;
        }
    } catch (error) {
        console.error('❌ Error conectando al servidor proxy BingX:', error);
        // Notificación eliminada - no molestar al usuario
        return false;
    }
}

// Event listeners para BingX
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Inicializando BingX - DOMContentLoaded');
    
    // CARGAR CREDENCIALES INMEDIATAMENTE
    loadBingXCredentials();
    loadBingXCredentialsInDetail();
    
    // Verificar proxy y cargar credenciales al inicio
    setTimeout(async () => {
        console.log('🔄 Verificando proxy y recargando credenciales...');
        const proxyOk = await checkProxyStatus();
        
        // VOLVER A CARGAR CREDENCIALES DESPUÉS DE VERIFICAR PROXY
        loadBingXCredentials();
        loadBingXCredentialsInDetail();
        loadLastSyncInfo();
        updateBingXDetailStatus();
        
        if (proxyOk) {
            console.log('BingX: Sistema inicializado correctamente');
        }
        // No mostrar mensaje si el proxy no está disponible
        
        // TERCER INTENTO DE CARGA DESPUÉS DE 2 SEGUNDOS MÁS
        setTimeout(() => {
            console.log('🔄 Carga final de credenciales...');
            loadBingXCredentials();
            loadBingXCredentialsInDetail();
        }, 2000);
        
    }, 1000);
    
    // Event listeners (verificar si existen los elementos)
    const bingxTestBtn = document.getElementById('bingx-test');
    const bingxConnectBtn = document.getElementById('bingx-connect');
    const bingxSyncBtn = document.getElementById('bingx-sync');
    
    // Event listeners para campos de credenciales - guardar automáticamente
    const apiKeyDetail = document.getElementById('bingx-api-key-detail');
    const secretKeyDetail = document.getElementById('bingx-secret-key-detail');
    const apiKeyOld = document.getElementById('bingx-api-key');
    const secretKeyOld = document.getElementById('bingx-api-secret');
    
    // Función para guardar credenciales automáticamente
    const saveCredentialsAuto = async () => {
        const apiKey = (apiKeyDetail?.value || apiKeyOld?.value || '').trim();
        const secretKey = (secretKeyDetail?.value || secretKeyOld?.value || '').trim();
        
        if (apiKey && secretKey) {
            console.log('💾 Auto-guardando credenciales...');
            try {
                // Guardar en localStorage inmediatamente
                localStorage.setItem('bingx-api-key', apiKey);
                localStorage.setItem('bingx-secret-key', secretKey);
                localStorage.setItem('bingx-account-id', 'main');
                localStorage.setItem('bingx-last-auto-save', Date.now().toString());
                
                // Guardar en DB también
                DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: 'main' };
                await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
                
                console.log('✅ Credenciales auto-guardadas');
            } catch (error) {
                console.error('❌ Error auto-guardando:', error);
            }
        }
    };
    
    // Agregar listeners a todos los campos de credenciales
    if (apiKeyDetail) {
        apiKeyDetail.addEventListener('input', saveCredentialsAuto);
        apiKeyDetail.addEventListener('blur', saveCredentialsAuto);
    }
    if (secretKeyDetail) {
        secretKeyDetail.addEventListener('input', saveCredentialsAuto);
        secretKeyDetail.addEventListener('blur', saveCredentialsAuto);
    }
    if (apiKeyOld) {
        apiKeyOld.addEventListener('input', saveCredentialsAuto);
        apiKeyOld.addEventListener('blur', saveCredentialsAuto);
    }
    if (secretKeyOld) {
        secretKeyOld.addEventListener('input', saveCredentialsAuto);
        secretKeyOld.addEventListener('blur', saveCredentialsAuto);
    }
    
    if (bingxTestBtn) bingxTestBtn.addEventListener('click', testBingXConnection);
    if (bingxConnectBtn) bingxConnectBtn.addEventListener('click', connectBingX);
    if (bingxSyncBtn) bingxSyncBtn.addEventListener('click', syncBingXTrades);
    
    // Event listener for quick sync button on platform card
    const bingxQuickSyncBtn = document.getElementById('bingx-quick-sync');
    if (bingxQuickSyncBtn) {
        bingxQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent card click event
            console.log('🚀 Quick sync iniciado desde plataforma');
            
            // Disable button and show loading state
            const originalText = bingxQuickSyncBtn.innerHTML;
            bingxQuickSyncBtn.disabled = true;
            bingxQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            bingxQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');
            
            try {
                await syncBingXTrades();
            } finally {
                // Restore button state
                setTimeout(() => {
                    bingxQuickSyncBtn.disabled = false;
                    bingxQuickSyncBtn.innerHTML = originalText;
                    bingxQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }
    
    // Event listener for CSV import button
    const bingxImportCsvBtn = document.getElementById('bingx-import-csv');
    if (bingxImportCsvBtn) {
        bingxImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBingXCSV();
        });
    }
    
    // Event listener for MEXC quick sync button
    const mexcQuickSyncBtn = document.getElementById('mexc-quick-sync');
    if (mexcQuickSyncBtn) {
        mexcQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent card click event
            console.log('🚀 Quick sync MEXC iniciado desde plataforma');
            
            // Check if connected
            if (!mexcAPI) {
                showSyncNotification('❌ Primero configura las credenciales API de MEXC', 'error');
                showPlatformDetail('mexc'); // Open MEXC panel to configure
                return;
            }
            
            // Disable button and show loading state
            const originalText = mexcQuickSyncBtn.innerHTML;
            mexcQuickSyncBtn.disabled = true;
            mexcQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            mexcQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');
            
            try {
                await syncMEXCTrades();
            } finally {
                // Restore button state
                setTimeout(() => {
                    mexcQuickSyncBtn.disabled = false;
                    mexcQuickSyncBtn.innerHTML = originalText;
                    mexcQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }
    
    // Event listener para botón CSV de MEXC en tarjeta
    const mexcImportCsvCardBtn = document.getElementById('mexc-import-csv');
    if (mexcImportCsvCardBtn) {
        mexcImportCsvCardBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showPlatformDetail('mexc'); // Abre el panel de MEXC para importar CSV
        });
    }
    
    // Event listener para botón CSV de PrimeXBT
    const primexbtImportCsvBtn = document.getElementById('primexbt-import-csv');
    if (primexbtImportCsvBtn) {
        primexbtImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importPrimeXBTCSV();
        });
    }
    
    // Event listener para botón HTML de MetaTrader 5
    const mt5ImportHtmlBtn = document.getElementById('mt5-import-html');
    if (mt5ImportHtmlBtn) {
        mt5ImportHtmlBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importMT5HTMLReport();
        });
    }
    
    // Event listener para botón de limpieza MT5
    const mt5CleanBtn = document.getElementById('mt5-clean-operations');
    if (mt5CleanBtn) {
        mt5CleanBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            cleanMT5Operations();
        });
    }
    
    // ============================================
    // EVENT LISTENERS PARA BITGET
    // ============================================
    
    // Event listener para botón CSV de Bitget (en tarjeta)
    const bitgetImportCsvBtn = document.getElementById('bitget-import-csv');
    if (bitgetImportCsvBtn) {
        bitgetImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBitgetCSV();
        });
    }
    
    // Event listener para botón de sincronización API de Bitget (en tarjeta)
    const bitgetQuickSyncBtn = document.getElementById('bitget-quick-sync');
    if (bitgetQuickSyncBtn) {
        bitgetQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            if (!bitgetAPI) {
                showSyncNotification('❌ Primero debes configurar las credenciales API en el panel de Bitget', 'error');
                // Abrir panel de detalles de Bitget
                showPlatformDetail('bitget');
                return;
            }
            
            await syncBitgetTrades();
        });
    }
    
    // Event listener para botón Conectar en panel de detalles
    const connectBitgetDetailBtn = document.getElementById('connect-bitget-detail');
    if (connectBitgetDetailBtn) {
        connectBitgetDetailBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bitget-api-key-detail');
            const secretKeyInput = document.getElementById('bitget-secret-key-detail');
            const passphraseInput = document.getElementById('bitget-passphrase-detail');
            
            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const passphrase = passphraseInput?.value.trim();
            
            if (!apiKey || !secretKey || !passphrase) {
                showSyncNotification('❌ Ingresa API Key, Secret y Passphrase', 'error');
                return;
            }
            
            try {
                if (window.FORCE_OFFLINE_BITGET) {
                    bitgetAPI = new MockBitgetAPI();
                } else {
                    bitgetAPI = new BitgetAPI(apiKey, secretKey, passphrase);
                }
                
                DB.apiKeys.bitget = { key: apiKey, secret: secretKey, passphrase: passphrase };
                await dexieDB.apiKeys.put({ id: 'bitget', key: apiKey, secret: secretKey, passphrase: passphrase });
                
                showSyncNotification('✅ Credenciales de Bitget guardadas', 'success');
                updateBitgetStatus('connected', 'Conectado', false);
            } catch (error) {
                console.error('Error guardando credenciales:', error);
                showSyncNotification('❌ Error guardando credenciales', 'error');
            }
        });
    }
    
    // Event listener para botón Probar Conexión
    const testBitgetConnectionBtn = document.getElementById('test-bitget-connection-detail');
    if (testBitgetConnectionBtn) {
        testBitgetConnectionBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bitget-api-key-detail');
            const secretKeyInput = document.getElementById('bitget-secret-key-detail');
            const passphraseInput = document.getElementById('bitget-passphrase-detail');
            
            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const passphrase = passphraseInput?.value.trim();
            
            if (!apiKey || !secretKey || !passphrase) {
                showSyncNotification('❌ Ingresa todas las credenciales', 'error');
                return;
            }
            
            try {
                const testAPI = window.FORCE_OFFLINE_BITGET ? new MockBitgetAPI() : new BitgetAPI(apiKey, secretKey, passphrase);
                const result = await testAPI.testConnection();
                
                showSyncNotification('✅ Conexión exitosa a Bitget', 'success');
                console.log('Test de conexión exitoso:', result);
            } catch (error) {
                console.error('Error en test de conexión:', error);
                showSyncNotification(`❌ Error: ${error.message}`, 'error');
            }
        });
    }
    
    // Event listener para botón Sincronizar Trades
    const syncBitgetTradesBtn = document.getElementById('sync-bitget-trades-detail');
    if (syncBitgetTradesBtn) {
        syncBitgetTradesBtn.addEventListener('click', async () => {
            await syncBitgetTrades();
        });
    }
    
    // Event listener para importar CSV desde panel de detalles
    const bitgetCsvBtn = document.getElementById('bitget-import-csv-btn');
    if (bitgetCsvBtn) {
        bitgetCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('bitget-csv-file-input');
            const file = fileInput?.files[0];
            
            if (!file) {
                showSyncNotification('❌ Selecciona un archivo CSV primero', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    await processBitgetCSV(e.target.result);
                } catch (error) {
                    console.error('Error procesando CSV:', error);
                    showSyncNotification('❌ Error procesando CSV', 'error');
                }
            };
            reader.readAsText(file);
        });
    }
    
    // Event listener para botón Volver de Bitget
    const bitgetBackBtn = document.getElementById('back-to-platforms-bitget');
    if (bitgetBackBtn) {
        bitgetBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }
    
    // ============================================
    // MEXC API Event Listeners
    // ============================================

    // Test de conexión MEXC
    const testMexcConnectionBtn = document.getElementById('test-mexc-connection-detail');
    if (testMexcConnectionBtn) {
        testMexcConnectionBtn.addEventListener('click', async () => {
            await testMEXCConnection();
        });
    }

    // ...existing code...
    
    // Conectar MEXC
    const connectMexcBtn = document.getElementById('connect-mexc-detail');
    if (connectMexcBtn) {
        connectMexcBtn.addEventListener('click', async () => {
            await connectMEXC();
        });
    }
    
    // Sincronizar trades de MEXC
    const syncMexcTradesBtn = document.getElementById('sync-mexc-trades-detail');
    if (syncMexcTradesBtn) {
        syncMexcTradesBtn.addEventListener('click', async () => {
            await syncMEXCTrades();
        });
    }
    
    // MEXC CSV Import
    const mexcCsvBtn = document.getElementById('mexc-import-csv-btn');
    if (mexcCsvBtn) {
        mexcCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('mexc-csv-file-input');
            const statusDiv = document.getElementById('mexc-csv-import-status');
            
            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }
            
            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';
                
                const file = fileInput.files[0];
                await processCSVFile(file, statusDiv, 'MEXC');
                
                statusDiv.textContent = '✅ CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';
                
                // Actualizar historial
                updateMEXCImportHistory();
                
            } catch (error) {
                console.error('Error procesando CSV de MEXC:', error);
                statusDiv.textContent = `❌ Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }
    
    // Botón back de MEXC
    const mexcBackBtn = document.getElementById('back-to-platforms-mexc');
    if (mexcBackBtn) {
        mexcBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }
    
    // ============================================
    // MEXC API Event Listeners
    // ============================================
    
    // Cargar credenciales al inicio
    console.log('🔄 Cargando credenciales de Bitget al iniciar...');
    loadBitgetCredentials();
    
    // Sincronización automática cada 5 minutos si BingX está conectado
    setInterval(async () => {
        if (bingxAPI && DB.apiKeys.bingx && DB.apiKeys.bingx.key) {
            try {
                console.log('🔄 Sincronización automática BingX iniciada...');
                await syncBingXTrades();
                console.log('✅ Sincronización automática BingX completada');
            } catch (error) {
                console.error('❌ Error en sincronización automática BingX:', error);
            }
        }
    }, 5 * 60 * 1000); // 5 minutos
    
    // OBSERVER PARA RECARGAR CREDENCIALES CUANDO LOS CAMPOS SE HAGAN VISIBLES
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' || mutation.type === 'childList') {
                // Verificar si algún campo de BingX se hizo visible
                const bingxFields = [
                    'bingx-api-key-detail',
                    'bingx-secret-key-detail', 
                    'bingx-api-key',
                    'bingx-api-secret'
                ];
                
                bingxFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field && field.offsetParent !== null && !field.value) {
                        console.log(`🔄 Campo ${fieldId} visible y vacío, recargando credenciales`);
                        setTimeout(() => {
                            loadBingXCredentials();
                            loadBingXCredentialsInDetail();
                        }, 100);
                    }
                });
            }
        });
    });
    
    // Observar cambios en todo el documento
    observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'class']
    });
});

// FUNCIÓN ADICIONAL: Recargar credenciales cada 10 segundos como fallback
setInterval(() => {
    const anyFieldEmpty = [
        'bingx-api-key-detail',
        'bingx-secret-key-detail', 
        'bingx-api-key',
        'bingx-api-secret'
    ].some(fieldId => {
        const field = document.getElementById(fieldId);
        return field && field.offsetParent !== null && !field.value;
    });
    
    if (anyFieldEmpty) {
        console.log('🔄 Fallback: recargando credenciales por campos vacíos');
        loadBingXCredentials();
        loadBingXCredentialsInDetail();
    }
}, 10000); // Cada 10 segundos

// Función para configurar sincronización automática manual
function startBingXAutoSync(intervalMinutes = 5) {
    if (window.bingxAutoSyncInterval) {
        clearInterval(window.bingxAutoSyncInterval);
    }
    
    window.bingxAutoSyncInterval = setInterval(async () => {
        if (bingxAPI && DB.apiKeys.bingx && DB.apiKeys.bingx.key) {
            console.log('🔄 Sincronización automática BingX...');
            await syncBingXTrades();
        }
    }, intervalMinutes * 60 * 1000);
    
    showSyncNotification(`✅ Sincronización automática activada cada ${intervalMinutes} minutos`, 'success');
}

function stopBingXAutoSync() {
    if (window.bingxAutoSyncInterval) {
        clearInterval(window.bingxAutoSyncInterval);
        window.bingxAutoSyncInterval = null;
        showSyncNotification('⏸️ Sincronización automática desactivada', 'info');
    }
}

// =====================================================
// GESTIÓN DE PLATAFORMAS
// =====================================================

function initPlatforms() {
    // Event listeners para las tarjetas de plataformas
    document.querySelectorAll('.platform-card').forEach(card => {
        card.addEventListener('click', function() {
            const platform = this.dataset.platform;
            if (platform === 'bingx') {
                showPlatformDetail('bingx');
            } else if (platform === 'bitget') {
                showPlatformDetail('bitget');
            } else if (platform === 'mexc') {
                showPlatformDetail('mexc');
            } else if (platform === 'primexbt') {
                showSyncNotification('PrimeXBT: Usa el botón CSV para importar operaciones', 'info');
            } else {
                showSyncNotification('Esta plataforma estará disponible próximamente', 'info');
            }
        });
    });

    // Botón de regreso a plataformas
    const backBtn = document.getElementById('back-to-platforms');
    if (backBtn) {
        backBtn.addEventListener('click', function() {
            showSection('platforms');
        });
    }

    // Duplicar funcionalidad de BingX para la nueva interfaz
    updateAccountSelect('bingx-account-detail');
    
    // Event listeners para botones de BingX en la nueva interfaz
    const testBtn = document.getElementById('test-bingx-connection-detail');
    const testAuthBtn = document.getElementById('test-auth-only');
    const connectBtn = document.getElementById('connect-bingx-detail');
    const syncBtn = document.getElementById('sync-bingx-trades-detail');
    
    if (testBtn) testBtn.addEventListener('click', testBingXConnection);
    if (testAuthBtn) testAuthBtn.addEventListener('click', testBingXAuth);
    if (connectBtn) connectBtn.addEventListener('click', connectBingX);
    if (syncBtn) syncBtn.addEventListener('click', syncBingXTrades);

    // Event listener para el botón CSV en la página de configuración
    const bingxCsvBtn = document.getElementById('bingx-import-csv-btn');
    if (bingxCsvBtn) {
        bingxCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('bingx-csv-file-input');
            const statusDiv = document.getElementById('bingx-csv-import-status');
            
            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }
            
            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';
                
                const file = fileInput.files[0];
                await processCSVFile(file, statusDiv);
                
                statusDiv.textContent = 'CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';
            } catch (error) {
                console.error('Error procesando CSV:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }

    // Cargar credenciales en la nueva interfaz
    loadBingXCredentialsInDetail();

    // Sincronizar datos entre las dos interfaces
    syncBingXData();

    // Inicializar MEXC
    console.log('🔍 Inicializando MEXC...');
    
    // Cargar credenciales de MEXC con delay para asegurar que DB esté lista
    setTimeout(() => {
        loadMEXCCredentials().catch(err => {
            console.warn('No se pudieron cargar credenciales de MEXC:', err);
        });
        populateMEXCAccountSelect();
    }, 1000);

    // Event listeners para MEXC
    const testMexcBtn = document.getElementById('test-mexc-connection-detail');
    const connectMexcBtn = document.getElementById('connect-mexc-detail');
    const syncMexcBtn = document.getElementById('sync-mexc-trades-detail');
    
    if (testMexcBtn) testMexcBtn.addEventListener('click', testMEXCConnection);
    if (connectMexcBtn) connectMexcBtn.addEventListener('click', connectMEXC);
    if (syncMexcBtn) syncMexcBtn.addEventListener('click', syncMEXCTrades);
    
    // Event listener para desconectar MEXC
    const disconnectMexcBtn = document.getElementById('disconnect-mexc-detail');
    if (disconnectMexcBtn) disconnectMexcBtn.addEventListener('click', disconnectMEXC);

    // Event listener para CSV de MEXC
    const mexcCsvBtn = document.getElementById('mexc-import-csv-btn');
    if (mexcCsvBtn) {
        mexcCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('mexc-csv-file-input');
            const statusDiv = document.getElementById('mexc-csv-import-status');
            
            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }
            
            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';
                
                const file = fileInput.files[0];
                await processCSVFile(file, statusDiv);
                
                statusDiv.textContent = 'CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';
            } catch (error) {
                console.error('Error procesando CSV:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }

    console.log('✅ MEXC inicializado');
}

function loadBingXCredentialsInDetail() {
    console.log('🔍 Cargando credenciales BingX en campos detallados...');
    
    // Primero intentar cargar desde localStorage
    const savedApiKey = localStorage.getItem('bingx-api-key');
    const savedSecretKey = localStorage.getItem('bingx-secret-key');
    const savedAccountId = localStorage.getItem('bingx-account-id');
    
    console.log('📁 Credenciales para campos detallados:', {
        apiKey: savedApiKey ? `${savedApiKey.substring(0, 10)}...` : 'No encontrada',
        secretKey: savedSecretKey ? `${savedSecretKey.substring(0, 10)}...` : 'No encontrada',
        accountId: savedAccountId || 'No encontrada'
    });
    
    // Configurar credenciales proporcionadas por el usuario como respaldo
    const providedApiKey = 'sw8hglph1M6HWzoqswDdjX7YTh3mcruPKynFi1ZBz8zDXCHxnEchw7oRWgYysFVLFuD7bkYomRHxSh8gdtNBg';
    const providedSecretKey = '7hUYF1GhJ6QixdE2mfDEdDMovcKVpUc3OnqbAfiAcbrT6XzFfMF4ywd0K06JgJCt0Zsa6MYxuSslDKr5XJfYA';
    
    const apiKeyDetailEl = document.getElementById('bingx-api-key-detail');
    const secretDetailEl = document.getElementById('bingx-secret-key-detail');
    const accountDetailEl = document.getElementById('bingx-account-detail');
    
    // Usar credenciales guardadas o las proporcionadas
    const apiKeyToUse = savedApiKey || providedApiKey;
    const secretKeyToUse = savedSecretKey || providedSecretKey;
    const accountIdToUse = savedAccountId || 'main';
    
    console.log('💾 Cargando credenciales en campos detallados...');
    
    if (apiKeyDetailEl) {
        apiKeyDetailEl.value = apiKeyToUse;
        apiKeyDetailEl.type = 'text'; // Hacer visible para edición si es necesario
        console.log('✅ API Key cargada en campo detallado');
    }
    if (secretDetailEl) {
        secretDetailEl.value = secretKeyToUse;
        secretDetailEl.type = 'text'; // Hacer visible para edición si es necesario
        console.log('✅ Secret Key cargada en campo detallado');
    }
    if (accountDetailEl) {
        accountDetailEl.value = accountIdToUse;
        console.log('✅ Account ID cargada en campo detallado');
    }
    
    // Actualizar DB
    DB.apiKeys.bingx = { 
        key: apiKeyToUse, 
        secret: secretKeyToUse, 
        mode: 'real', 
        accountId: accountIdToUse 
    };
    
    // También actualizar los campos básicos si existen
    const bingxApiKeyEl = document.getElementById('bingx-api-key');
    const bingxSecretEl = document.getElementById('bingx-api-secret');
    
    if (bingxApiKeyEl && !bingxApiKeyEl.value) {
        bingxApiKeyEl.value = apiKeyToUse;
        console.log('✅ API Key sincronizada con campo básico');
    }
    if (bingxSecretEl && !bingxSecretEl.value) {
        bingxSecretEl.value = secretKeyToUse;
        console.log('✅ Secret Key sincronizada con campo básico');
    }
    
    // Inicializar API automáticamente si hay credenciales
    if (apiKeyToUse && secretKeyToUse) {
        bingxAPI = new BingXAPI(apiKeyToUse, secretKeyToUse);
        console.log('BingX API inicializada automáticamente');
        // Poblar las cuentas cuando se inicializa la API
        populateBingXAccounts();
    }
}

function showPlatformDetail(platform) {
    if (platform === 'bingx') {
        console.log('🎯 Abriendo sección BingX - recargando credenciales');
        
        // Cargar credenciales antes de mostrar la interfaz
        loadBingXCredentials();
        loadBingXCredentialsInDetail();
        
        // Poblar cuentas de BingX
        populateBingXAccounts();
        
        // Recargar credenciales después de un breve delay para asegurar que los campos estén listos
        setTimeout(() => {
            console.log('🔄 Recarga adicional de credenciales en BingX');
            loadBingXCredentials();
            loadBingXCredentialsInDetail();
        }, 500);
        
        // Sincronizar datos actuales
        syncBingXData();
        
        // Mostrar la sección detallada
        document.querySelectorAll('.section-container').forEach(s => s.classList.remove('active'));
        document.getElementById('platform-bingx').style.display = 'block';
        document.getElementById('platform-bingx').classList.add('active');
        
        // Actualizar estado de la conexión después de cargar credenciales
        setTimeout(() => {
            updateBingXDetailStatus();
        }, 500);
        
    } else if (platform === 'bitget') {
        console.log('🎯 Abriendo sección Bitget - recargando credenciales');
        
        // Cargar credenciales antes de mostrar la interfaz
        loadBitgetCredentials();
        
        // Poblar cuentas de Bitget
        populateBitgetAccountSelect();
        
        // Recargar credenciales después de un breve delay para asegurar que los campos estén listos
        setTimeout(() => {
            console.log('🔄 Recarga adicional de credenciales en Bitget');
            loadBitgetCredentials();
        }, 500);
        
        // Mostrar la sección detallada
        document.querySelectorAll('.section-container').forEach(s => s.classList.remove('active'));
        document.getElementById('platform-bitget').style.display = 'block';
        document.getElementById('platform-bitget').classList.add('active');
        
        console.log('✅ Panel de Bitget cargado');
    } else if (platform === 'mexc') {
        console.log('🎯 Abriendo sección MEXC');
        
        // Cargar credenciales de forma asíncrona
        loadMEXCCredentials().catch(err => {
            console.error('Error cargando credenciales MEXC:', err);
        });
        
        // Poblar cuentas
        populateMEXCAccountSelect();
        
        // Mostrar la sección detallada
        document.querySelectorAll('.section-container').forEach(s => s.classList.remove('active'));
        document.getElementById('platform-mexc').style.display = 'block';
        document.getElementById('platform-mexc').classList.add('active');
        
        console.log('✅ Panel de MEXC cargado');
    }
}

function syncBingXData() {
    // Sincronizar claves API
    const apiKey = document.getElementById('bingx-api-key')?.value || '';
    const secretKey = document.getElementById('bingx-api-secret')?.value || '';
    const selectedAccount = document.getElementById('bingx-account')?.value || '';

    if (document.getElementById('bingx-api-key-detail')) {
        document.getElementById('bingx-api-key-detail').value = apiKey;
    }
    if (document.getElementById('bingx-secret-key-detail')) {
        document.getElementById('bingx-secret-key-detail').value = secretKey;
    }
    if (document.getElementById('bingx-account-detail')) {
        document.getElementById('bingx-account-detail').value = selectedAccount;
    }
}

function updateBingXDetailStatus() {
    const statusElement = document.getElementById('bingx-connection-status');
    const proxyElement = document.getElementById('bingx-proxy-status-detail');
    
    // Verificar si hay credenciales guardadas
    const hasLocalCredentials = localStorage.getItem('bingx-api-key') && localStorage.getItem('bingx-secret-key');
    const hasDbCredentials = DB.apiKeys.bingx && DB.apiKeys.bingx.key && DB.apiKeys.bingx.secret;
    
    if ((bingxAPI && bingxAPI.apiKey) || hasLocalCredentials || hasDbCredentials) {
        // Conectado
        if (statusElement) {
            statusElement.className = 'p-4 bg-green-800 border border-green-600 rounded-md mb-4';
            statusElement.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-check-circle text-green-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-green-100">Conectado a BingX</p>
                        <p class="text-sm text-green-200 mt-1">Las credenciales están guardadas. La sincronización automática está activa cada 5 minutos.</p>
                    </div>
                </div>
            `;
        }
        
        // Actualizar indicadores en la tarjeta de plataforma
        const statusIndicator = document.getElementById('bingx-status-indicator');
        const progressBar = document.getElementById('bingx-progress-bar');
        
        if (statusIndicator) {
            statusIndicator.textContent = 'Conectado';
            statusIndicator.className = 'text-green-400';
        }
        if (progressBar) {
            progressBar.style.width = '100%';
        }
        
        // Mostrar botones de sincronización
        const syncBtn = document.getElementById('bingx-sync');
        if (syncBtn) syncBtn.style.display = 'inline-block';
        
    } else {
        // No conectado
        if (statusElement) {
            statusElement.className = 'p-4 bg-yellow-800 border border-yellow-600 rounded-md mb-4';
            statusElement.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-yellow-100">No conectado</p>
                        <p class="text-sm text-yellow-200 mt-1">Configure sus claves API para comenzar la sincronización automática.</p>
                    </div>
                </div>
            `;
        }
        
        // Actualizar indicadores en la tarjeta de plataforma
        const statusIndicator = document.getElementById('bingx-status-indicator');
        const progressBar = document.getElementById('bingx-progress-bar');
        
        if (statusIndicator) {
            statusIndicator.textContent = 'No conectado';
            statusIndicator.className = 'text-yellow-400';
        }
        if (progressBar) {
            progressBar.style.width = '0%';
        }
        
        // Ocultar botón de sincronización
        const syncBtn = document.getElementById('bingx-sync');
        if (syncBtn) syncBtn.style.display = 'none';
    }
}

// Función personalizada para conectar BingX desde la nueva interfaz
function connectBingX() {
    let apiKey, secretKey, selectedAccount;
    
    // Verificar desde qué interfaz se está llamando
    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const oldApiKey = document.getElementById('bingx-api-key');
    
    if (detailApiKey && detailApiKey.value) {
        // Llamada desde la nueva interfaz de plataformas
        apiKey = detailApiKey.value;
        secretKey = document.getElementById('bingx-secret-key-detail').value;
        selectedAccount = document.getElementById('bingx-account-detail').value;
    } else if (oldApiKey && oldApiKey.value) {
        // Llamada desde la interfaz antigua de configuración
        apiKey = oldApiKey.value;
        secretKey = document.getElementById('bingx-api-secret').value;
        selectedAccount = document.getElementById('bingx-account').value;
    }

    if (!apiKey || !secretKey) {
        alert('Por favor, introduce tanto la clave API como el secret de BingX.');
        return;
    }

    if (!selectedAccount) {
        alert('Por favor, selecciona una cuenta para sincronizar.');
        return;
    }

    // Sincronizar valores entre ambas interfaces
    if (detailApiKey) {
        detailApiKey.value = apiKey;
        document.getElementById('bingx-secret-key-detail').value = secretKey;
        document.getElementById('bingx-account-detail').value = selectedAccount;
    }
    if (oldApiKey) {
        oldApiKey.value = apiKey;
        document.getElementById('bingx-api-secret').value = secretKey;
        document.getElementById('bingx-account').value = selectedAccount;
    }

    // Inicializar BingX API
    bingxAPI = new BingXAPI(apiKey, secretKey);
    DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: selectedAccount };
    
    // Actualizar estado
    updateBingXDetailStatus();
    
    showSyncNotification('✅ BingX conectado exitosamente', 'success');
}

console.log('✅ Sistema de autenticación inicializado');
console.log('✅ Integración BingX inicializada');
</script>

</body>
</html>